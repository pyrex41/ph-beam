This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: assets/, .taskmaster/, .cursor/, docs/, test/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
config/
  config.exs
  dev.exs
  prod.exs
  runtime.exs
  test.exs
lib/
  collab_canvas/
    accounts/
      user.ex
    ai/
      agent.ex
      component_builder.ex
      layout.ex
      themes.ex
      tools.ex
    canvases/
      canvas_user_viewport.ex
      canvas.ex
      object.ex
    color_palettes/
      user_color_preference.ex
    components/
      component.ex
    styles/
      style.ex
    accounts.ex
    application.ex
    canvases.ex
    color_palettes.ex
    components.ex
    mailer.ex
    release.ex
    repo.ex
    styles.ex
  collab_canvas_web/
    components/
      layouts/
        root.html.heex
      color_picker.ex
      core_components.ex
      layouts.ex
    controllers/
      page_html/
        home.html.heex
      auth_controller.ex
      error_html.ex
      error_json.ex
      health_controller.ex
      page_controller.ex
      page_html.ex
    live/
      canvas_live.ex
      components_panel_live.ex
      dashboard_live.ex
      styles_panel_live.ex
    plugs/
      auth.ex
    endpoint.ex
    gettext.ex
    presence.ex
    router.ex
    telemetry.ex
  collab_canvas_web.ex
  collab_canvas.ex
priv/
  gettext/
    en/
      LC_MESSAGES/
        errors.po
    errors.pot
  repo/
    migrations/
      .formatter.exs
      20251013211812_create_users.exs
      20251013211824_create_canvases.exs
      20251013211830_create_objects.exs
      20251014120000_add_locked_by_to_objects.exs
      20251016171355_create_components.exs
      20251016171421_create_styles.exs
      20251016171424_add_component_fields_to_objects.exs
      20251017023740_create_canvas_user_viewports.exs
      20251017041802_create_user_color_preferences.exs
    seeds.exs
  static/
    images/
      logo.svg
    robots.txt
rel/
  env.sh.eex
.dockerignore
.env.example
.formatter.exs
.gitignore
AGENTS.md
CLAUDE.md
Dockerfile
fly.toml
mix.exs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="config/config.exs">
# This file is responsible for configuring your application
# and its dependencies with the aid of the Config module.
#
# This configuration file is loaded before any dependency and
# is restricted to this project.

# General application configuration
import Config

config :collab_canvas,
  ecto_repos: [CollabCanvas.Repo],
  generators: [timestamp_type: :utc_datetime]

# Configures the endpoint
config :collab_canvas, CollabCanvasWeb.Endpoint,
  url: [host: "localhost"],
  adapter: Bandit.PhoenixAdapter,
  render_errors: [
    formats: [html: CollabCanvasWeb.ErrorHTML, json: CollabCanvasWeb.ErrorJSON],
    layout: false
  ],
  pubsub_server: CollabCanvas.PubSub,
  live_view: [signing_salt: "04fK4JjR"]

# Configures the mailer
#
# By default it uses the "Local" adapter which stores the emails
# locally. You can see the emails in your browser, at "/dev/mailbox".
#
# For production it's recommended to configure a different adapter
# at the `config/runtime.exs`.
config :collab_canvas, CollabCanvas.Mailer, adapter: Swoosh.Adapters.Local

# Configure Vite for better ESM support (recommended for PixiJS v8)
# Note: Vite runs via npm scripts, Phoenix just needs to know about the watcher
# The actual build happens via: npm run build (production) or npm run dev (development)

# Configure tailwind (the version is required)
config :tailwind,
  version: "4.1.7",
  collab_canvas: [
    args: ~w(
      --input=assets/css/app.css
      --output=priv/static/assets/css/app.css
    ),
    cd: Path.expand("..", __DIR__)
  ]

# Configures Elixir's Logger
config :logger, :default_formatter,
  format: "$time $metadata[$level] $message\n",
  metadata: [:request_id]

# Use Jason for JSON parsing in Phoenix
config :phoenix, :json_library, Jason

# Configure Ueberauth for Auth0
config :ueberauth, Ueberauth,
  providers: [
    auth0: {Ueberauth.Strategy.Auth0, []}
  ]

# Auth0 OAuth configuration is set in runtime.exs

# Import environment specific config. This must remain at the bottom
# of this file so it overrides the configuration defined above.
import_config "#{config_env()}.exs"
</file>

<file path="config/dev.exs">
import Config

# Configure your database
# Uses DATABASE_PATH env var if set, otherwise defaults to local dev database
config :collab_canvas, CollabCanvas.Repo,
  database: System.get_env("DATABASE_PATH") || Path.expand("../collab_canvas_dev.db", __DIR__),
  pool_size: 5,
  stacktrace: true,
  show_sensitive_data_on_connection_error: true

# For development, we disable any cache and enable
# debugging and code reloading.
#
# The watchers configuration can be used to run external
# watchers to your application. For example, we can use it
# to bundle .js and .css sources.
config :collab_canvas, CollabCanvasWeb.Endpoint,
  # Binding to loopback ipv4 address prevents access from other machines.
  # Change to `ip: {0, 0, 0, 0}` to allow access from other machines.
  http: [ip: {127, 0, 0, 1}, port: String.to_integer(System.get_env("PORT") || "4000")],
  check_origin: false,
  code_reloader: true,
  debug_errors: true,
  secret_key_base: "CQPu1mFoqMKdCSJNFEDBk2GGpwDiqpi+cUPqSiYhQM3nmqOVlR00+8RcCxcQFpJL",
  watchers: [
    vite: {System, :cmd, ["npm", ["run", "dev"], [cd: Path.expand("../assets", __DIR__)]]},
    tailwind: {Tailwind, :install_and_run, [:collab_canvas, ~w(--watch)]}
  ]

# ## SSL Support
#
# In order to use HTTPS in development, a self-signed
# certificate can be generated by running the following
# Mix task:
#
#     mix phx.gen.cert
#
# Run `mix help phx.gen.cert` for more information.
#
# The `http:` config above can be replaced with:
#
#     https: [
#       port: 4001,
#       cipher_suite: :strong,
#       keyfile: "priv/cert/selfsigned_key.pem",
#       certfile: "priv/cert/selfsigned.pem"
#     ],
#
# If desired, both `http:` and `https:` keys can be
# configured to run both http and https servers on
# different ports.

# Watch static and templates for browser reloading.
config :collab_canvas, CollabCanvasWeb.Endpoint,
  live_reload: [
    web_console_logger: true,
    patterns: [
      ~r"priv/static/(?!uploads/).*(js|css|png|jpeg|jpg|gif|svg)$",
      ~r"priv/gettext/.*(po)$",
      ~r"lib/collab_canvas_web/(?:controllers|live|components|router)/?.*\.(ex|heex)$"
    ]
  ]

# Enable dev routes for dashboard and mailbox
config :collab_canvas, dev_routes: true

# Do not include metadata nor timestamps in development logs
config :logger, :default_formatter, format: "[$level] $message\n"

# Set a higher stacktrace during development. Avoid configuring such
# in production as building large stacktraces may be expensive.
config :phoenix, :stacktrace_depth, 20

# Initialize plugs at runtime for faster development compilation
config :phoenix, :plug_init_mode, :runtime

config :phoenix_live_view,
  # Include debug annotations and locations in rendered markup.
  # Changing this configuration will require mix clean and a full recompile.
  debug_heex_annotations: true,
  debug_attributes: true,
  # Enable helpful, but potentially expensive runtime checks
  enable_expensive_runtime_checks: true

# Disable swoosh api client as it is only required for production adapters.
config :swoosh, :api_client, false

# Auth0 configuration is handled in config/runtime.exs via .env file
</file>

<file path="config/prod.exs">
import Config

# Note we also include the path to a cache manifest
# containing the digested version of static files. This
# manifest is generated by the `mix assets.deploy` task,
# which you should run after static files are built and
# before starting your production server.
config :collab_canvas, CollabCanvasWeb.Endpoint,
  cache_static_manifest: "priv/static/cache_manifest.json"

# Configures Swoosh API Client
config :swoosh, api_client: Swoosh.ApiClient.Req

# Disable Swoosh Local Memory Storage
config :swoosh, local: false

# Do not print debug messages in production
config :logger, level: :info

# Runtime production configuration, including reading
# of environment variables, is done on config/runtime.exs.
</file>

<file path="config/runtime.exs">
import Config

# config/runtime.exs is executed for all environments, including
# during releases. It is executed after compilation and before the
# system starts, so it is typically used to load production configuration
# and secrets from environment variables or elsewhere. Do not define
# any compile-time configuration in here, as it won't be applied.
# The block below contains prod specific runtime configuration.

# Load .env file in development
if config_env() == :dev do
  env_file = Path.expand("../.env", __DIR__)
  if File.exists?(env_file) do
    # Load .env file into System environment
    env_file
    |> File.read!()
    |> String.split("\n")
    |> Enum.each(fn line ->
      line = String.trim(line)
      # Skip empty lines and comments
      unless line == "" or String.starts_with?(line, "#") do
        case String.split(line, "=", parts: 2) do
          [key, value] ->
            key = String.trim(key)
            value = String.trim(value)
            System.put_env(key, value)
          _ -> :ok
        end
      end
    end)
  end

  # Configure Auth0 for development (after loading .env)
  config :ueberauth, Ueberauth.Strategy.Auth0.OAuth,
    domain: System.get_env("AUTH0_DOMAIN") || "dev-placeholder.us.auth0.com",
    client_id: System.get_env("AUTH0_CLIENT_ID") || "your-client-id",
    client_secret: System.get_env("AUTH0_CLIENT_SECRET") || "your-client-secret"
end

# Configure Auth0 for production
if config_env() == :prod and System.get_env("AUTH0_DOMAIN") do
  config :ueberauth, Ueberauth.Strategy.Auth0.OAuth,
    domain: System.get_env("AUTH0_DOMAIN"),
    client_id: System.get_env("AUTH0_CLIENT_ID"),
    client_secret: System.get_env("AUTH0_CLIENT_SECRET")
end

# ## Using releases
#
# If you use `mix release`, you need to explicitly enable the server
# by passing the PHX_SERVER=true when you start it:
#
#     PHX_SERVER=true bin/collab_canvas start
#
# Alternatively, you can use `mix phx.gen.release` to generate a `bin/server`
# script that automatically sets the env var above.
if System.get_env("PHX_SERVER") do
  config :collab_canvas, CollabCanvasWeb.Endpoint, server: true
end

if config_env() == :prod do
  database_path =
    System.get_env("DATABASE_PATH") ||
      raise """
      environment variable DATABASE_PATH is missing.
      For example: /etc/collab_canvas/collab_canvas.db
      """

  config :collab_canvas, CollabCanvas.Repo,
    database: database_path,
    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "5")

  # The secret key base is used to sign/encrypt cookies and other secrets.
  # A default value is used in config/dev.exs and config/test.exs but you
  # want to use a different value for prod and you most likely don't want
  # to check this value into version control, so we use an environment
  # variable instead.
  secret_key_base =
    System.get_env("SECRET_KEY_BASE") ||
      raise """
      environment variable SECRET_KEY_BASE is missing.
      You can generate one by calling: mix phx.gen.secret
      """

  host = System.get_env("PHX_HOST") || "example.com"
  port = String.to_integer(System.get_env("PORT") || "4000")

  config :collab_canvas, :dns_cluster_query, System.get_env("DNS_CLUSTER_QUERY")

  config :collab_canvas, CollabCanvasWeb.Endpoint,
    url: [host: host, port: 443, scheme: "https"],
    http: [
      # Enable IPv6 and bind on all interfaces.
      # Set it to  {0, 0, 0, 0, 0, 0, 0, 1} for local network only access.
      # See the documentation on https://hexdocs.pm/bandit/Bandit.html#t:options/0
      # for details about using IPv6 vs IPv4 and loopback vs public addresses.
      ip: {0, 0, 0, 0, 0, 0, 0, 0},
      port: port
    ],
    secret_key_base: secret_key_base

  # ## SSL Support
  #
  # To get SSL working, you will need to add the `https` key
  # to your endpoint configuration:
  #
  #     config :collab_canvas, CollabCanvasWeb.Endpoint,
  #       https: [
  #         ...,
  #         port: 443,
  #         cipher_suite: :strong,
  #         keyfile: System.get_env("SOME_APP_SSL_KEY_PATH"),
  #         certfile: System.get_env("SOME_APP_SSL_CERT_PATH")
  #       ]
  #
  # The `cipher_suite` is set to `:strong` to support only the
  # latest and more secure SSL ciphers. This means old browsers
  # and clients may not be supported. You can set it to
  # `:compatible` for wider support.
  #
  # `:keyfile` and `:certfile` expect an absolute path to the key
  # and cert in disk or a relative path inside priv, for example
  # "priv/ssl/server.key". For all supported SSL configuration
  # options, see https://hexdocs.pm/plug/Plug.SSL.html#configure/1
  #
  # We also recommend setting `force_ssl` in your config/prod.exs,
  # ensuring no data is ever sent via http, always redirecting to https:
  #
  #     config :collab_canvas, CollabCanvasWeb.Endpoint,
  #       force_ssl: [hsts: true]
  #
  # Check `Plug.SSL` for all available options in `force_ssl`.

  # ## Configuring the mailer
  #
  # In production you need to configure the mailer to use a different adapter.
  # Here is an example configuration for Mailgun:
  #
  #     config :collab_canvas, CollabCanvas.Mailer,
  #       adapter: Swoosh.Adapters.Mailgun,
  #       api_key: System.get_env("MAILGUN_API_KEY"),
  #       domain: System.get_env("MAILGUN_DOMAIN")
  #
  # Most non-SMTP adapters require an API client. Swoosh supports Req, Hackney,
  # and Finch out-of-the-box. This configuration is typically done at
  # compile-time in your config/prod.exs:
  #
  #     config :swoosh, :api_client, Swoosh.ApiClient.Req
  #
  # See https://hexdocs.pm/swoosh/Swoosh.html#module-installation for details.
end
</file>

<file path="config/test.exs">
import Config

# Configure your database
#
# The MIX_TEST_PARTITION environment variable can be used
# to provide built-in test partitioning in CI environment.
# Run `mix help test` for more information.
config :collab_canvas, CollabCanvas.Repo,
  database: Path.expand("../collab_canvas_test.db", __DIR__),
  pool_size: 5,
  pool: Ecto.Adapters.SQL.Sandbox

# We don't run a server during test. If one is required,
# you can enable the server option below.
config :collab_canvas, CollabCanvasWeb.Endpoint,
  http: [ip: {127, 0, 0, 1}, port: 4002],
  secret_key_base: "Rv4Jy3cJyGC9S/mXKopNXxHCtW4jQkkbUgmVKSn49nU4uMot7h8YiaW3Y8wNmBw0",
  server: false

# In test we don't send emails
config :collab_canvas, CollabCanvas.Mailer, adapter: Swoosh.Adapters.Test

# Disable swoosh api client as it is only required for production adapters
config :swoosh, :api_client, false

# Print only warnings and errors during test
config :logger, level: :warning

# Initialize plugs at runtime for faster test compilation
config :phoenix, :plug_init_mode, :runtime

# Enable helpful, but potentially expensive runtime checks
config :phoenix_live_view,
  enable_expensive_runtime_checks: true
</file>

<file path="lib/collab_canvas/accounts/user.ex">
defmodule CollabCanvas.Accounts.User do
  @moduledoc """
  User schema for the CollabCanvas application.
  Represents authenticated users with OAuth provider information.
  """

  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :email, :string
    field :name, :string
    field :avatar, :string
    field :provider, :string
    field :provider_uid, :string
    field :last_login, :utc_datetime

    timestamps(type: :utc_datetime)
  end

  @doc """
  Changeset for creating or updating a user.

  ## Required fields
    * `:email` - Must be a valid email format and unique

  ## Optional fields
    * `:name` - User's display name
    * `:avatar` - URL to user's avatar image
    * `:provider` - OAuth provider name (e.g., "auth0", "google", "github")
    * `:provider_uid` - Unique identifier from the OAuth provider
    * `:last_login` - Timestamp of user's last login
  """
  def changeset(user, attrs) do
    user
    |> cast(attrs, [:email, :name, :avatar, :provider, :provider_uid, :last_login])
    |> validate_required([:email])
    |> validate_email()
    |> unique_constraint(:email)
    |> unique_constraint([:provider, :provider_uid])
  end

  @doc """
  Changeset specifically for updating last login timestamp.
  Only allows updating the last_login field.
  """
  def login_changeset(user, attrs) do
    user
    |> cast(attrs, [:last_login])
    |> validate_required([:last_login])
  end

  # Private helper to validate email format
  defp validate_email(changeset) do
    changeset
    |> validate_format(:email, ~r/^[^\s]+@[^\s]+$/, message: "must be a valid email address")
    |> validate_length(:email, max: 160)
  end
end
</file>

<file path="lib/collab_canvas/ai/agent.ex">
defmodule CollabCanvas.AI.Agent do
  @moduledoc """
  AI Agent for executing natural language commands on canvas objects.

  This module provides an intelligent interface for canvas manipulation through natural language.
  It integrates with the Anthropic Claude API to parse user commands and translate them into
  specific canvas operations using function calling tools.

  ## Purpose

  The AI Agent serves as a bridge between human language and canvas operations, allowing users to:
  - Create shapes, text, and complex UI components with natural descriptions
  - Move, resize, and delete objects using conversational commands
  - List and query canvas objects
  - Group multiple objects together

  ## Claude API Integration

  The agent uses Claude 3.5 Sonnet with function calling to:
  1. Parse natural language commands into structured tool calls
  2. Validate canvas operations before execution
  3. Handle multi-step operations in a single command
  4. Provide error handling and fallback responses

  ## Function Calling Tools

  The following tools are available for canvas operations:
  - `create_shape` - Creates rectangles, circles, and other basic shapes
  - `create_text` - Adds text objects with customizable styling
  - `create_component` - Builds complex UI components (login forms, navbars, cards, etc.)
  - `move_shape` - Repositions objects on the canvas
  - `resize_shape` - Changes object dimensions
  - `delete_object` - Removes objects from the canvas
  - `list_objects` - Retrieves all objects on a canvas
  - `group_objects` - Groups multiple objects together
  - `resize_object` - Resizes objects with optional aspect ratio preservation
  - `rotate_object` - Rotates objects by a specified angle around a pivot point
  - `change_style` - Changes styling properties (fill, stroke, opacity, fonts, etc.)
  - `update_text` - Updates text content and formatting options
  - `move_object` - Moves objects using delta or absolute coordinates

  Tool definitions are managed by `CollabCanvas.AI.Tools` module.

  ## Error Handling

  The agent implements comprehensive error handling:
  - API key validation before requests
  - Canvas existence verification
  - HTTP error response handling
  - Malformed response detection
  - Unknown tool call logging
  - Object not found errors

  All errors are returned as `{:error, reason}` tuples for consistent handling.

  ## Configuration

  Requires the `CLAUDE_API_KEY` environment variable to be set with a valid
  Anthropic API key.

  ## Examples

      # Simple shape creation
      Agent.execute_command("create a red square at 100, 100", canvas_id)
      {:ok, [%{tool: "create_shape", result: {:ok, %Object{}}}]}

      # Multiple operations
      Agent.execute_command("create a blue circle and a login form", canvas_id)
      {:ok, [
        %{tool: "create_shape", result: {:ok, %Object{}}},
        %{tool: "create_component", result: {:ok, [%Object{}, ...]}}
      ]}

      # Error case
      Agent.execute_command("create a shape", 999)
      {:error, :canvas_not_found}
  """

  require Logger
  alias CollabCanvas.Canvases
  alias CollabCanvas.AI.Tools
  alias CollabCanvas.AI.ComponentBuilder
  alias CollabCanvas.AI.Layout

  @claude_api_url "https://api.anthropic.com/v1/messages"
  @claude_model "claude-3-5-sonnet-20241022"
  @claude_api_version "2023-06-01"

  @groq_api_url "https://api.groq.com/openai/v1/chat/completions"
  @default_groq_model "llama-3.3-70b-versatile"

  @openai_api_url "https://api.openai.com/v1/chat/completions"
  @default_openai_model "gpt-4o"

  @doc """
  Executes a natural language command on a canvas.

  ## Parameters
    * `command` - Natural language command string (e.g., "create a red rectangle at 100,100")
    * `canvas_id` - The ID of the canvas to operate on
    * `selected_ids` - Optional list of selected object IDs for layout/arrangement commands (default: [])
    * `opts` - Optional keyword list with:
      - `:current_color` - Current color from color picker to use as default for new objects

  ## Returns
    * `{:ok, results}` - List of operation results
    * `{:error, reason}` - Error description

  ## Examples

      iex> execute_command("create a rectangle", 1)
      {:ok, [%{type: "create_shape", result: {:ok, %Object{}}}]}

      iex> execute_command("arrange horizontally", 1, [1, 2, 3])
      {:ok, [%{type: "arrange_objects", result: {:ok, %{updated: 3}}}]}

      iex> execute_command("create a circle", 1, [], current_color: "#FF0000")
      {:ok, [%{type: "create_shape", result: {:ok, %Object{data: "{\"color\":\"#FF0000\"}"}}}]}

      iex> execute_command("invalid command", 999)
      {:error, :canvas_not_found}

  """
  def execute_command(command, canvas_id, selected_ids \\ [], opts \\ []) do
    # Extract current color from options
    current_color = Keyword.get(opts, :current_color, "#000000")

    # Verify canvas exists
    case Canvases.get_canvas(canvas_id) do
      nil ->
        {:error, :canvas_not_found}

      _canvas ->
        # Build enhanced command with selection context if provided
        enhanced_command = build_command_with_context(command, selected_ids, canvas_id, current_color)

        Logger.info("Calling AI API with command: #{command}")

        # Call Claude API with function calling
        case call_claude_api(enhanced_command) do
          {:ok, {:text_response, text}} ->
            # AI returned text (e.g., asking for clarification)
            Logger.info("AI returned text response: #{text}")
            {:ok, {:text_response, text}}

          {:ok, tool_calls} when is_list(tool_calls) ->
            # Log when AI returns no tools (might indicate confusion)
            Logger.info("AI returned #{length(tool_calls)} tool call(s)")

            if length(tool_calls) == 0 do
              Logger.warning("AI returned no tool calls for command: #{command}")
            end

            # Inject selected_ids into arrange_objects tool calls if not provided
            enriched_tool_calls = enrich_tool_calls(tool_calls, selected_ids)

            # Process tool calls and execute canvas operations
            results = process_tool_calls(enriched_tool_calls, canvas_id, current_color)
            {:ok, results}

          {:error, reason} ->
            Logger.error("AI API call failed: #{inspect(reason)}")
            {:error, reason}
        end
    end
  end

  @doc """
  Calls Claude API with function calling tools to parse the command.

  Makes an HTTP POST request to the Anthropic API with the user's natural language
  command and the available tool definitions. Claude analyzes the command and returns
  structured tool calls that can be executed against the canvas.

  ## Parameters
    * `command` - Natural language command string (e.g., "create a red rectangle")

  ## Returns
    * `{:ok, tool_calls}` - List of tool call maps with `:id`, `:name`, and `:input` keys
    * `{:error, :missing_api_key}` - CLAUDE_API_KEY environment variable not set
    * `{:error, {:api_error, status, body}}` - API returned non-200 status code
    * `{:error, {:request_failed, reason}}` - HTTP request failed
    * `{:error, :invalid_response_format}` - API response format unexpected

  ## Examples

      iex> call_claude_api("create a blue circle at 50, 50")
      {:ok, [
        %{
          id: "toolu_123",
          name: "create_shape",
          input: %{"type" => "circle", "x" => 50, "y" => 50, "color" => "#0000FF"}
        }
      ]}

      iex> call_claude_api("list all objects")
      {:ok, [%{id: "toolu_456", name: "list_objects", input: %{}}]}

      iex> System.delete_env("CLAUDE_API_KEY")
      iex> call_claude_api("create shape")
      {:error, :missing_api_key}
  """
  def call_claude_api(command) do
    provider = get_ai_provider()

    case provider do
      "openai" -> call_openai_api(command)
      "groq" -> call_groq_api(command)
      "claude" -> call_anthropic_api(command)
      _ -> call_anthropic_api(command)  # Default to Claude
    end
  end

  defp call_anthropic_api(command) do
    api_key = System.get_env("CLAUDE_API_KEY")

    if is_nil(api_key) or api_key == "" or api_key == "your_key_here" do
      {:error, :missing_api_key}
    else
      headers = [
        {"x-api-key", api_key},
        {"anthropic-version", @claude_api_version},
        {"content-type", "application/json"}
      ]

      body = %{
        model: @claude_model,
        max_tokens: 1024,
        tools: Tools.get_tool_definitions(),
        messages: [
          %{
            role: "user",
            content: command
          }
        ]
      }

      case Req.post(@claude_api_url, json: body, headers: headers) do
        {:ok, %{status: 200, body: response_body}} ->
          parse_claude_response(response_body)

        {:ok, %{status: status, body: body}} ->
          Logger.error("Claude API error: #{status} - #{inspect(body)}")
          {:error, {:api_error, status, body}}

        {:error, reason} ->
          Logger.error("Claude API request failed: #{inspect(reason)}")
          {:error, {:request_failed, reason}}
      end
    end
  end

  defp call_groq_api(command) do
    api_key = System.get_env("GROQ_API_KEY")
    model = System.get_env("GROQ_MODEL") || @default_groq_model

    Logger.info("Using Groq API with model: #{model}")

    if is_nil(api_key) or api_key == "" do
      {:error, :missing_api_key}
    else
      headers = [
        {"Authorization", "Bearer #{api_key}"},
        {"content-type", "application/json"}
      ]

      # Convert Claude tool format to OpenAI function format (Groq uses OpenAI-compatible format)
      tools = Enum.map(Tools.get_tool_definitions(), fn tool ->
        %{
          type: "function",
          function: %{
            name: tool.name,
            description: tool.description,
            parameters: tool.input_schema
          }
        }
      end)

      body = %{
        model: model,
        messages: [
          %{
            role: "user",
            content: command
          }
        ],
        tools: tools,
        tool_choice: "auto",
        max_completion_tokens: 4096,
        temperature: 0.5
      }

      Logger.debug("Sending request to Groq API...")

      case Req.post(@groq_api_url, json: body, headers: headers) do
        {:ok, %{status: 200, body: response_body}} ->
          Logger.debug("Groq API responded successfully")
          parse_openai_response(response_body)

        {:ok, %{status: status, body: body}} ->
          Logger.error("Groq API error: #{status} - #{inspect(body)}")
          {:error, {:api_error, status, body}}

        {:error, reason} ->
          Logger.error("Groq API request failed: #{inspect(reason)}")
          {:error, {:request_failed, reason}}
      end
    end
  end

  defp call_openai_api(command) do
    api_key = System.get_env("OPENAI_API_KEY")
    model = System.get_env("OPENAI_MODEL") || @default_openai_model

    if is_nil(api_key) or api_key == "" or String.starts_with?(api_key, "sk-proj-") == false do
      {:error, :missing_api_key}
    else
      headers = [
        {"Authorization", "Bearer #{api_key}"},
        {"content-type", "application/json"}
      ]

      # Convert Claude tool format to OpenAI function format
      tools = Enum.map(Tools.get_tool_definitions(), fn tool ->
        %{
          type: "function",
          function: %{
            name: tool.name,
            description: tool.description,
            parameters: tool.input_schema
          }
        }
      end)

      body = %{
        model: model,
        messages: [
          %{
            role: "user",
            content: command
          }
        ],
        tools: tools,
        tool_choice: "auto"
      }

      case Req.post(@openai_api_url, json: body, headers: headers) do
        {:ok, %{status: 200, body: response_body}} ->
          parse_openai_response(response_body)

        {:ok, %{status: status, body: body}} ->
          Logger.error("OpenAI API error: #{status} - #{inspect(body)}")
          {:error, {:api_error, status, body}}

        {:error, reason} ->
          Logger.error("OpenAI API request failed: #{inspect(reason)}")
          {:error, {:request_failed, reason}}
      end
    end
  end

  @doc """
  Processes tool calls from Claude API response and executes canvas operations.

  Takes the structured tool calls returned by Claude and executes each one sequentially
  against the canvas. Each tool call is translated into the appropriate canvas operation
  (create, update, delete, etc.) and the results are collected.

  ## Parameters
    * `tool_calls` - List of tool call maps from Claude API, each containing:
      - `:id` - Unique identifier for the tool call
      - `:name` - Name of the tool to execute
      - `:input` - Map of parameters for the tool
    * `canvas_id` - The ID of the canvas to operate on
    * `current_color` - Current color from color picker to use as default for new objects

  ## Returns
    * List of operation result maps, each containing:
      - `:tool` - Name of the tool that was executed
      - `:input` - Original input parameters
      - `:result` - Result tuple from the operation (e.g., `{:ok, %Object{}}` or `{:error, reason}`)

  ## Examples

      iex> tool_calls = [
      ...>   %{id: "t1", name: "create_shape", input: %{"type" => "rectangle", "x" => 10, "y" => 10}},
      ...>   %{id: "t2", name: "create_text", input: %{"text" => "Hello", "x" => 50, "y" => 50}}
      ...> ]
      iex> process_tool_calls(tool_calls, canvas_id, "#FF0000")
      [
        %{tool: "create_shape", input: %{...}, result: {:ok, %Object{}}},
        %{tool: "create_text", input: %{...}, result: {:ok, %Object{}}}
      ]

      iex> unknown_call = [%{id: "t1", name: "unknown_tool", input: %{}}]
      iex> process_tool_calls(unknown_call, canvas_id, "#000000")
      [%{tool: "unknown", input: %{...}, result: {:error, :unknown_tool}}]
  """
  def process_tool_calls(tool_calls, canvas_id, current_color \\ "#000000") do
    Enum.map(tool_calls, fn tool_call ->
      # Normalize tool call input (coerce string IDs to integers)
      normalized_call = normalize_tool_input(tool_call)
      execute_tool_call(normalized_call, canvas_id, current_color)
    end)
  end

  # Normalizes tool call inputs by coercing string IDs to integers
  # Some AI providers (like Groq) return object_id as strings despite schema specifying integer
  defp normalize_tool_input(%{name: name, input: input} = tool_call) do
    normalized_input = input
    |> normalize_id_field("object_id")
    |> normalize_id_field("shape_id")
    |> normalize_id_array_field("object_ids")

    %{tool_call | input: normalized_input}
  end

  # Coerces a single ID field from string to integer if present
  defp normalize_id_field(input, field_name) do
    case Map.get(input, field_name) do
      id when is_binary(id) ->
        case Integer.parse(id) do
          {int_id, _} -> Map.put(input, field_name, int_id)
          :error -> input
        end
      _ -> input
    end
  end

  # Coerces an array of IDs from strings to integers if present
  defp normalize_id_array_field(input, field_name) do
    case Map.get(input, field_name) do
      ids when is_list(ids) ->
        normalized_ids = Enum.map(ids, fn
          id when is_binary(id) ->
            case Integer.parse(id) do
              {int_id, _} -> int_id
              :error -> id
            end
          id -> id
        end)
        Map.put(input, field_name, normalized_ids)
      _ -> input
    end
  end

  # Private Functions

  # Retrieves the AI provider setting from environment variables.
  # Returns "claude" or "groq". Defaults to "claude" if not set.
  defp get_ai_provider do
    System.get_env("AI_PROVIDER") || "claude"
  end

  # Builds an enhanced command with all canvas objects and their human-readable names
  defp build_command_with_context(command, selected_ids, canvas_id, current_color) do
    # Fetch all canvas objects
    all_objects = Canvases.list_objects(canvas_id)

    # Generate human-readable display names (e.g., "Rectangle 1", "Circle 2")
    objects_with_names = generate_display_names(all_objects)

    # Build context with all objects and their display names
    available_objects_str = objects_with_names
    |> Enum.map(fn {obj, display_name} ->
      data = if is_binary(obj.data), do: Jason.decode!(obj.data), else: obj.data || %{}
      "  - #{display_name} (ID: #{obj.id}): #{obj.type} at (#{get_in(obj.position, ["x"])||0}, #{get_in(obj.position, ["y"])||0})"
    end)
    |> Enum.join("\n")

    # Build selected objects context if any
    selected_context = if is_list(selected_ids) and length(selected_ids) > 0 do
      selected_names = objects_with_names
      |> Enum.filter(fn {obj, _name} -> obj.id in selected_ids end)
      |> Enum.map(fn {_obj, name} -> name end)
      |> Enum.join(", ")

      "\nCurrently selected: #{selected_names}"
    else
      ""
    end

    # Build full context
    context = """
    CURRENT COLOR PICKER: #{current_color}
    - Use this color when creating new shapes/text UNLESS the user specifies a different color
    - If user says "create a rectangle" (without color), use #{current_color}
    - If user says "create a blue rectangle", use blue (#0000FF or similar)

    CANVAS OBJECTS (use these human-readable names in your responses):
    #{available_objects_str}#{selected_context}

    DISAMBIGUATION RULES:
    - When the user refers to "that square", "the circle", "that rectangle", etc. without specifying which one:
      * If objects are currently selected, operate on the selected objects
      * If no selection, ask the user to specify which one using the display names above (e.g., "Rectangle 1", "Circle 2")
      * If ambiguous and you must assume, use the most recently created object of that type

    - When referencing objects in tool calls, ALWAYS use the database ID (the number in parentheses), not the display name

    LAYOUT INTERPRETATION RULES:
    - "next to each other" / "side by side" = horizontal layout
    - "one after another horizontally" / "in a row" = horizontal layout
    - "one after another vertically" / "in a column" = vertical layout
    - "on top of each other" / "stacked" = vertical layout (stack type)
    - "line up" without direction specified = horizontal layout (most common interpretation)

    - When using horizontal or vertical layouts:
      * ALWAYS check object sizes before choosing spacing
      * If objects have vastly different sizes (>2x difference in width/height), use FIXED spacing (e.g., 20-30px) instead of :even
      * Fixed spacing prevents overlaps when size differences are large
      * Example: arrange_objects with layout_type="horizontal" and spacing=30 for different-sized objects

    - Default spacing recommendations:
      * Small objects (< 100px): spacing = 20
      * Medium objects (100-200px): spacing = 30
      * Large objects (> 200px): spacing = 40
      * Mixed sizes: use spacing >= largest dimension difference

    TOOL USAGE PHILOSOPHY - BE CREATIVE:
    - Your layout tools are HIGHLY FLEXIBLE - don't give up just because a pattern isn't explicitly named!
    - For complex formations (triangles, pyramids, spirals, custom patterns):
      * Use `arrange_objects_with_pattern` with line/diagonal/wave/arc patterns
      * Use `define_object_relationships` to build shapes with spatial constraints
      * Make MULTIPLE tool calls if needed to build complex shapes row by row or layer by layer
    - CRITICAL: How to create TRIANGLE/PYRAMID formations:
      * TRIANGLE = pyramid shape with rows getting wider (1 at top, 2 below, 3 below that, etc.)
      * For 6 objects triangle: Row 1 (1 object), Row 2 (2 objects), Row 3 (3 objects)
      * For 10 objects triangle: Rows of 1, 2, 3, 4 objects
      * METHOD 1: Make MULTIPLE `arrange_objects_with_pattern` calls - one line/horizontal per row
      * METHOD 2: Use `define_object_relationships` with "below" and "left_of"/"right_of" constraints
      * NEVER use just "diagonal" for triangles - that creates a diagonal LINE, not a triangle
    - Other examples:
      * Zigzag: `arrange_objects_with_pattern` with diagonal pattern alternating directions
      * Custom formations: Combine tools creatively or make sequential calls
    - Default to ATTEMPTING a layout with available tools before saying you can't do it
    - Only respond with text if the request is truly impossible with available tools

    CRITICAL EXECUTION RULES:
    - NEVER ask for permission or confirmation - JUST DO IT
    - NEVER respond with "Should I proceed?" or "Let me know if you'd like me to..." - EXECUTE IMMEDIATELY
    - When creating shapes/objects: Calculate positions and CALL create_shape/create_text tools multiple times
    - For grids/patterns: Make MULTIPLE tool calls in sequence with calculated x,y positions for each object
    - Example: "10x10 grid of circles" = make 100 create_shape tool calls with calculated positions (0,0), (50,0), (100,0)... etc.

    WHEN TO RESPOND WITH TEXT VS TOOLS:
    - USE TOOLS (ALWAYS PREFERRED): For any spatial arrangement, creation, or manipulation task
    - MAKE MULTIPLE TOOL CALLS: When creating patterns or grids, calculate positions and call create_shape for each object
    - USE TEXT ONLY WHEN: Truly impossible with available tools (e.g., "delete the database") or genuinely ambiguous (e.g., "that one" with no context)
    - You CAN show visual labels using show_object_labels tool when users ask to see IDs or names

    IMPORTANT: Your job is to EXECUTE, not to explain plans or ask permission. Users expect ACTION, not proposals.

    USER COMMAND: #{command}
    """

    context
  end

  # Generates human-readable display names for objects based on type and creation order
  # Returns list of {object, "Display Name"} tuples
  defp generate_display_names(objects) do
    # Sort by insertion time (oldest first)
    sorted_objects = Enum.sort_by(objects, & &1.inserted_at, DateTime)

    # Group by type and number them
    sorted_objects
    |> Enum.group_by(& &1.type)
    |> Enum.flat_map(fn {type, type_objects} ->
      type_objects
      |> Enum.with_index(1)
      |> Enum.map(fn {obj, index} ->
        display_name = format_display_name(type, index)
        {obj, display_name}
      end)
    end)
    |> Enum.sort_by(fn {obj, _name} -> obj.id end)
  end

  # Formats a display name for an object (e.g., "Rectangle 1", "Circle 2")
  defp format_display_name(type, index) do
    type_str = type |> String.capitalize()
    "#{type_str} #{index}"
  end

  # Enriches tool calls by injecting selected object IDs into arrange_objects calls
  defp enrich_tool_calls(tool_calls, []), do: tool_calls

  defp enrich_tool_calls(tool_calls, selected_ids) when is_list(selected_ids) and length(selected_ids) > 0 do
    Enum.map(tool_calls, fn tool_call ->
      case tool_call.name do
        "arrange_objects" ->
          # If object_ids not provided or empty, use selected_ids (as integers, matching schema)
          input = tool_call.input
          object_ids = Map.get(input, "object_ids", [])

          updated_input = if length(object_ids) == 0 do
            Map.put(input, "object_ids", selected_ids)
          else
            input
          end

          %{tool_call | input: updated_input}

        _ ->
          tool_call
      end
    end)
  end


  # Parses the Claude API response to extract tool calls or text responses.
  #
  # Handles different stop_reason values:
  # - "tool_use" - Response contains tool calls to execute
  # - "end_turn" - Response is text-only (e.g., AI asking for clarification)
  # - other - Logs warning and returns empty list
  #
  # Returns {:ok, tool_calls} list, {:ok, {:text_response, text}}, or {:error, :invalid_response_format}
  defp parse_claude_response(%{"content" => content, "stop_reason" => stop_reason}) do
    case stop_reason do
      "tool_use" ->
        tool_calls =
          content
          |> Enum.filter(fn item -> item["type"] == "tool_use" end)
          |> Enum.map(fn tool_use ->
            %{
              id: tool_use["id"],
              name: tool_use["name"],
              input: tool_use["input"]
            }
          end)

        {:ok, tool_calls}

      "end_turn" ->
        # Extract text response (AI might be asking for clarification)
        text_items = content
        |> Enum.filter(fn item -> item["type"] == "text" end)
        |> Enum.map(fn item -> item["text"] end)
        |> Enum.join("\n")

        if text_items != "" do
          {:ok, {:text_response, text_items}}
        else
          {:ok, []}
        end

      other ->
        Logger.warning("Unexpected stop_reason: #{other}")
        {:ok, []}
    end
  end

  defp parse_claude_response(response) do
    Logger.error("Unexpected Claude API response format: #{inspect(response)}")
    {:error, :invalid_response_format}
  end

  # Parses OpenAI/Groq API response (OpenAI format) to extract tool calls or text responses.
  #
  # The response format is different from Claude's:
  # - Uses "choices" array with "message" object
  # - Tool calls are in message.tool_calls array
  # - finish_reason can be "tool_calls" or "stop"
  #
  # Returns {:ok, tool_calls} list, {:ok, {:text_response, text}}, or {:error, :invalid_response_format}
  defp parse_openai_response(%{"choices" => [%{"message" => message} | _]}) do
    Logger.debug("Parsing OpenAI/Groq response message: #{inspect(Map.keys(message))}")

    case message do
      %{"tool_calls" => tool_calls} when is_list(tool_calls) ->
        Logger.debug("Found #{length(tool_calls)} tool calls")
        parsed_calls = Enum.map(tool_calls, fn tool_call ->
          %{
            id: tool_call["id"],
            name: tool_call["function"]["name"],
            input: Jason.decode!(tool_call["function"]["arguments"])
          }
        end)
        {:ok, parsed_calls}

      %{"content" => content} when is_binary(content) and content != "" ->
        # AI returned text response (asking for clarification)
        Logger.debug("Found text response: #{String.slice(content, 0, 100)}...")
        {:ok, {:text_response, content}}

      _ ->
        # No tool calls and no text
        Logger.warning("No tool calls or text content in response")
        {:ok, []}
    end
  end

  defp parse_openai_response(response) do
    Logger.error("Unexpected OpenAI API response format: #{inspect(response)}")
    {:error, :invalid_response_format}
  end

  # Executes a create_shape tool call to create a basic shape on the canvas.
  #
  # Supported shape types: rectangle, circle, triangle, etc.
  # Extracts width, height, color from input and creates object at specified x,y position.
  # Uses current_color as default if no color is specified in the input.
  defp execute_tool_call(%{name: "create_shape", input: input}, canvas_id, current_color) do
    data = %{
      width: input["width"],
      height: input["height"],
      color: Map.get(input, "color", current_color)
    }

    attrs = %{
      position: %{
        x: input["x"],
        y: input["y"]
      },
      data: Jason.encode!(data)
    }

    result = Canvases.create_object(canvas_id, input["type"], attrs)

    %{
      tool: "create_shape",
      input: input,
      result: result
    }
  end

  # Executes a create_text tool call to add a text object to the canvas.
  #
  # Extracts text content, font_size (default 16), and color from input.
  # Creates text object at specified x,y position.
  # Uses current_color as default if no color is specified in the input.
  defp execute_tool_call(%{name: "create_text", input: input}, canvas_id, current_color) do
    data = %{
      text: input["text"],
      font_size: Map.get(input, "font_size", 16),
      color: Map.get(input, "color", current_color)
    }

    attrs = %{
      position: %{
        x: input["x"],
        y: input["y"]
      },
      data: Jason.encode!(data)
    }

    result = Canvases.create_object(canvas_id, "text", attrs)

    %{
      tool: "create_text",
      input: input,
      result: result
    }
  end

  # Executes a move_shape tool call to reposition an object on the canvas.
  #
  # Updates the object's position to the new x,y coordinates specified in input.
  defp execute_tool_call(%{name: "move_shape", input: input}, _canvas_id, _current_color) do
    # Get object_id from either shape_id or object_id (for backwards compatibility)
    object_id = input["shape_id"] || input["object_id"]

    attrs = %{
      position: %{
        x: input["x"],
        y: input["y"]
      }
    }

    result = Canvases.update_object(object_id, attrs)

    %{
      tool: "move_shape",
      input: input,
      result: result
    }
  end

  # Executes a resize_shape tool call to change an object's dimensions.
  #
  # Fetches existing object, merges width/height into data, and updates.
  # Returns error if object not found.
  defp execute_tool_call(%{name: "resize_shape", input: input}, _canvas_id, _current_color) do
    # Get object_id from either shape_id or object_id (for backwards compatibility)
    object_id = input["shape_id"] || input["object_id"]

    # First get the existing object to merge data
    case Canvases.get_object(object_id) do
      nil ->
        %{
          tool: "resize_shape",
          input: input,
          result: {:error, :not_found}
        }

      object ->
        # Decode existing data, update width/height, re-encode
        existing_data = if object.data, do: Jason.decode!(object.data), else: %{}

        updated_data =
          existing_data
          |> Map.put("width", input["width"])
          |> Map.put("height", input["height"])

        attrs = %{
          data: Jason.encode!(updated_data)
        }

        result = Canvases.update_object(object_id, attrs)

        %{
          tool: "resize_shape",
          input: input,
          result: result
        }
    end
  end

  # Executes a delete_object tool call to remove an object from the canvas.
  #
  # Deletes the object with the specified object_id.
  defp execute_tool_call(%{name: "delete_object", input: input}, _canvas_id, _current_color) do
    result = Canvases.delete_object(input["object_id"])

    %{
      tool: "delete_object",
      input: input,
      result: result
    }
  end

  # Executes a list_objects tool call to retrieve all objects on the canvas.
  #
  # Fetches all objects and formats them for AI response with decoded data.
  defp execute_tool_call(%{name: "list_objects", input: _input}, canvas_id, _current_color) do
    objects = Canvases.list_objects(canvas_id)

    # Format objects for AI response
    formatted_objects =
      Enum.map(objects, fn object ->
        decoded_data = if object.data, do: Jason.decode!(object.data), else: %{}

        %{
          id: object.id,
          type: object.type,
          position: object.position,
          data: decoded_data
        }
      end)

    %{
      tool: "list_objects",
      input: %{},
      result: {:ok, formatted_objects}
    }
  end

  # Executes a create_component tool call to build complex UI components.
  #
  # Supports multiple component types: login_form, navbar, card, button, sidebar.
  # Delegates to ComponentBuilder module with specified dimensions, theme, and content.
  defp execute_tool_call(%{name: "create_component", input: input}, canvas_id, _current_color) do
    component_type = input["type"]
    x = input["x"]
    y = input["y"]
    width = Map.get(input, "width", 200)
    height = Map.get(input, "height", 100)
    theme = Map.get(input, "theme", "light")
    content = Map.get(input, "content", %{})

    result =
      case component_type do
        "login_form" ->
          ComponentBuilder.create_login_form(canvas_id, x, y, width, height, theme, content)

        "navbar" ->
          ComponentBuilder.create_navbar(canvas_id, x, y, width, height, theme, content)

        "card" ->
          ComponentBuilder.create_card(canvas_id, x, y, width, height, theme, content)

        "button" ->
          ComponentBuilder.create_button_group(canvas_id, x, y, width, height, theme, content)

        "sidebar" ->
          ComponentBuilder.create_sidebar(canvas_id, x, y, width, height, theme, content)

        _ ->
          {:error, :unknown_component_type}
      end

    %{
      tool: "create_component",
      input: input,
      result: result
    }
  end

  # Executes a group_objects tool call to group multiple objects together.
  #
  # Currently returns success with generated group_id.
  # Full grouping logic would need to be implemented in Canvases context.
  defp execute_tool_call(%{name: "group_objects", input: input}, _canvas_id, _current_color) do
    # For now, just return success - actual grouping logic would need to be implemented in Canvases
    %{
      tool: "group_objects",
      input: input,
      result: {:ok, %{group_id: Ecto.UUID.generate(), object_ids: input["object_ids"]}}
    }
  end

  # Executes a resize_object tool call to resize an object with optional aspect ratio preservation.
  #
  # Fetches existing object, calculates new dimensions (with aspect ratio if requested),
  # merges into data, and updates. Returns error if object not found.
  defp execute_tool_call(%{name: "resize_object", input: input}, _canvas_id, _current_color) do
    case Canvases.get_object(input["object_id"]) do
      nil ->
        %{
          tool: "resize_object",
          input: input,
          result: {:error, :not_found}
        }

      object ->
        existing_data = if object.data, do: Jason.decode!(object.data), else: %{}

        # Calculate dimensions based on aspect ratio setting
        {new_width, new_height} =
          if Map.get(input, "maintain_aspect_ratio", false) do
            # Preserve aspect ratio: calculate height based on width
            old_width = Map.get(existing_data, "width", 100)
            old_height = Map.get(existing_data, "height", 100)
            aspect_ratio = old_height / old_width
            calculated_height = input["width"] * aspect_ratio
            {input["width"], calculated_height}
          else
            # Use provided dimensions
            {input["width"], Map.get(input, "height", Map.get(existing_data, "height", input["width"]))}
          end

        updated_data =
          existing_data
          |> Map.put("width", new_width)
          |> Map.put("height", new_height)

        attrs = %{data: Jason.encode!(updated_data)}
        result = Canvases.update_object(input["object_id"], attrs)

        %{
          tool: "resize_object",
          input: input,
          result: result
        }
    end
  end

  # Executes a rotate_object tool call to rotate an object by a specified angle.
  #
  # Stores rotation angle and pivot point in object data. Frontend will apply the rotation.
  defp execute_tool_call(%{name: "rotate_object", input: input}, _canvas_id, _current_color) do
    case Canvases.get_object(input["object_id"]) do
      nil ->
        %{
          tool: "rotate_object",
          input: input,
          result: {:error, :not_found}
        }

      object ->
        existing_data = if object.data, do: Jason.decode!(object.data), else: %{}

        # Normalize angle to 0-360 range
        normalized_angle = rem(round(input["angle"]), 360)
        normalized_angle = if normalized_angle < 0, do: normalized_angle + 360, else: normalized_angle

        updated_data =
          existing_data
          |> Map.put("rotation", normalized_angle)
          |> Map.put("pivot_point", Map.get(input, "pivot_point", "center"))

        attrs = %{data: Jason.encode!(updated_data)}
        result = Canvases.update_object(input["object_id"], attrs)

        %{
          tool: "rotate_object",
          input: input,
          result: result
        }
    end
  end

  # Executes a change_style tool call to modify styling properties of an object.
  #
  # Supports fill, stroke, stroke_width, opacity, font properties, and color changes.
  defp execute_tool_call(%{name: "change_style", input: input}, _canvas_id, _current_color) do
    case Canvases.get_object(input["object_id"]) do
      nil ->
        %{
          tool: "change_style",
          input: input,
          result: {:error, :not_found}
        }

      object ->
        existing_data = if object.data, do: Jason.decode!(object.data), else: %{}

        # Parse value based on property type
        value =
          case input["property"] do
            prop when prop in ["stroke_width", "font_size"] ->
              # Numeric properties
              case Float.parse(input["value"]) do
                {num, _} -> num
                :error -> String.to_integer(input["value"])
              end
            "opacity" ->
              # Opacity is 0-1
              case Float.parse(input["value"]) do
                {num, _} -> max(0.0, min(1.0, num))
                :error -> 1.0
              end
            _ ->
              # String properties (colors, fonts)
              input["value"]
          end

        updated_data = Map.put(existing_data, input["property"], value)
        attrs = %{data: Jason.encode!(updated_data)}
        result = Canvases.update_object(input["object_id"], attrs)

        %{
          tool: "change_style",
          input: input,
          result: result
        }
    end
  end

  # Executes an update_text tool call to modify text content and formatting.
  #
  # Updates text content and any formatting options provided (font_size, font_family, color, etc.).
  defp execute_tool_call(%{name: "update_text", input: input}, _canvas_id, _current_color) do
    case Canvases.get_object(input["object_id"]) do
      nil ->
        %{
          tool: "update_text",
          input: input,
          result: {:error, :not_found}
        }

      object ->
        # Verify it's a text object
        if object.type != "text" do
          %{
            tool: "update_text",
            input: input,
            result: {:error, :not_text_object}
          }
        else
          existing_data = if object.data, do: Jason.decode!(object.data), else: %{}

          # Update text and formatting options
          updated_data = existing_data
          updated_data = if Map.has_key?(input, "new_text"), do: Map.put(updated_data, "text", input["new_text"]), else: updated_data
          updated_data = if Map.has_key?(input, "font_size"), do: Map.put(updated_data, "font_size", input["font_size"]), else: updated_data
          updated_data = if Map.has_key?(input, "font_family"), do: Map.put(updated_data, "font_family", input["font_family"]), else: updated_data
          updated_data = if Map.has_key?(input, "color"), do: Map.put(updated_data, "color", input["color"]), else: updated_data
          updated_data = if Map.has_key?(input, "align"), do: Map.put(updated_data, "align", input["align"]), else: updated_data
          updated_data = if Map.has_key?(input, "bold"), do: Map.put(updated_data, "bold", input["bold"]), else: updated_data
          updated_data = if Map.has_key?(input, "italic"), do: Map.put(updated_data, "italic", input["italic"]), else: updated_data

          attrs = %{data: Jason.encode!(updated_data)}
          result = Canvases.update_object(input["object_id"], attrs)

          %{
            tool: "update_text",
            input: input,
            result: result
          }
        end
    end
  end

  # Executes a move_object tool call to reposition an object using delta or absolute coordinates.
  #
  # Supports both relative movement (delta_x, delta_y) and absolute positioning (x, y).
  defp execute_tool_call(%{name: "move_object", input: input}, _canvas_id, _current_color) do
    case Canvases.get_object(input["object_id"]) do
      nil ->
        %{
          tool: "move_object",
          input: input,
          result: {:error, :not_found}
        }

      object ->
        current_position = object.position || %{"x" => 0, "y" => 0}
        current_x = Map.get(current_position, "x") || Map.get(current_position, :x) || 0
        current_y = Map.get(current_position, "y") || Map.get(current_position, :y) || 0

        # Calculate new position based on delta or absolute coordinates
        new_x =
          cond do
            Map.has_key?(input, "delta_x") -> current_x + input["delta_x"]
            Map.has_key?(input, "x") -> input["x"]
            true -> current_x
          end

        new_y =
          cond do
            Map.has_key?(input, "delta_y") -> current_y + input["delta_y"]
            Map.has_key?(input, "y") -> input["y"]
            true -> current_y
          end

        attrs = %{
          position: %{
            x: new_x,
            y: new_y
          }
        }

        result = Canvases.update_object(input["object_id"], attrs)

        %{
          tool: "move_object",
          input: input,
          result: result
        }
    end
  end

  # Executes an arrange_objects tool call to layout multiple objects in a specified pattern.
  #
  # Supports horizontal, vertical, grid, circular, and stack layouts.
  # Applies layout algorithms from CollabCanvas.AI.Layout module and batch updates all objects.
  defp execute_tool_call(%{name: "arrange_objects", input: input}, canvas_id, _current_color) do
    object_ids = input["object_ids"]
    layout_type = input["layout_type"]

    # Start performance timer
    start_time = System.monotonic_time(:millisecond)

    # Fetch all objects to arrange
    objects = Enum.map(object_ids, fn id ->
      case Canvases.get_object(id) do
        nil -> nil
        obj ->
          # Decode data if it's a JSON string
          data = if is_binary(obj.data) do
            Jason.decode!(obj.data)
          else
            obj.data || %{}
          end

          %{
            id: obj.id,
            position: obj.position,
            data: data
          }
      end
    end)
    |> Enum.reject(&is_nil/1)

    if length(objects) == 0 do
      %{
        tool: "arrange_objects",
        input: input,
        result: {:error, :no_objects_found}
      }
    else
      # Apply layout algorithm based on type
      updates = case layout_type do
        "horizontal" ->
          spacing = Map.get(input, "spacing", :even)
          Layout.distribute_horizontally(objects, spacing)

        "vertical" ->
          spacing = Map.get(input, "spacing", :even)
          Layout.distribute_vertically(objects, spacing)

        "grid" ->
          columns = Map.get(input, "columns", 3)
          spacing = Map.get(input, "spacing", 20)
          Layout.arrange_grid(objects, columns, spacing)

        "circular" ->
          radius = Map.get(input, "radius", 200)
          Layout.circular_layout(objects, radius)

        "stack" ->
          # Stack is vertical distribution with optional alignment
          alignment = Map.get(input, "alignment")
          distributed = Layout.distribute_vertically(objects, Map.get(input, "spacing", 20))

          if alignment do
            # Apply alignment after stacking
            aligned_objects = Enum.map(distributed, fn update ->
              obj = Enum.find(objects, fn o -> o.id == update.id end)
              %{obj | position: update.position}
            end)
            Layout.align_objects(aligned_objects, alignment)
          else
            distributed
          end

        _ ->
          []
      end

      # Apply alignment if specified and not already applied
      final_updates = if Map.has_key?(input, "alignment") and layout_type != "stack" do
        # Reconstruct objects with new positions for alignment
        aligned_objects = Enum.map(updates, fn update ->
          obj = Enum.find(objects, fn o -> o.id == update.id end)
          %{obj | position: update.position}
        end)
        Layout.align_objects(aligned_objects, input["alignment"])
      else
        updates
      end

      # Batch update all objects atomically
      results = Enum.map(final_updates, fn update ->
        attrs = %{position: update.position}
        Canvases.update_object(update.id, attrs)
      end)

      # Broadcast updates to all connected clients for real-time sync
      Enum.each(results, fn
        {:ok, updated_object} ->
          Phoenix.PubSub.broadcast(
            CollabCanvas.PubSub,
            "canvas:#{canvas_id}",
            {:object_updated, updated_object}
          )
        _ -> :ok
      end)

      # Check if any updates failed
      failed = Enum.any?(results, fn
        {:error, _} -> true
        _ -> false
      end)

      # Calculate performance metrics
      end_time = System.monotonic_time(:millisecond)
      duration_ms = end_time - start_time

      # Log performance (should be <500ms for up to 50 objects per PRD requirement)
      Logger.info("Layout operation completed: #{layout_type} layout for #{length(results)} objects in #{duration_ms}ms")

      if duration_ms > 500 do
        Logger.warning("Layout operation exceeded 500ms target: #{duration_ms}ms for #{length(results)} objects")
      end

      if failed do
        %{
          tool: "arrange_objects",
          input: input,
          result: {:error, :partial_update_failure}
        }
      else
        %{
          tool: "arrange_objects",
          input: input,
          result: {:ok, %{updated: length(results), layout: layout_type, duration_ms: duration_ms}}
        }
      end
    end
  end

  # Executes a show_object_labels tool call to toggle display of visual labels on canvas objects.
  #
  # Returns a special result type that the frontend can handle to show/hide labels.
  defp execute_tool_call(%{name: "show_object_labels", input: input}, _canvas_id, _current_color) do
    show = Map.get(input, "show", true)

    %{
      tool: "show_object_labels",
      input: input,
      result: {:ok, {:toggle_labels, show}}
    }
  end

  # Executes an arrange_objects_with_pattern tool call for flexible programmatic layouts.
  #
  # Supports custom patterns like line, diagonal, wave, arc for arrangements not covered by standard layouts.
  defp execute_tool_call(%{name: "arrange_objects_with_pattern", input: input}, canvas_id, _current_color) do
    object_ids = input["object_ids"]
    pattern = input["pattern"]

    start_time = System.monotonic_time(:millisecond)

    # Fetch all objects to arrange
    objects = Enum.map(object_ids, fn id ->
      case Canvases.get_object(id) do
        nil -> nil
        obj ->
          data = if is_binary(obj.data) do
            Jason.decode!(obj.data)
          else
            obj.data || %{}
          end

          %{
            id: obj.id,
            position: obj.position,
            data: data
          }
      end
    end)
    |> Enum.reject(&is_nil/1)

    if length(objects) == 0 do
      %{
        tool: "arrange_objects_with_pattern",
        input: input,
        result: {:error, :no_objects_found}
      }
    else
      # Apply pattern-based layout
      updates = Layout.pattern_layout(objects, pattern, input)

      # Batch update all objects
      results = Enum.map(updates, fn update ->
        attrs = %{position: update.position}
        Canvases.update_object(update.id, attrs)
      end)

      # Broadcast updates to all connected clients for real-time sync
      Enum.each(results, fn
        {:ok, updated_object} ->
          Phoenix.PubSub.broadcast(
            CollabCanvas.PubSub,
            "canvas:#{canvas_id}",
            {:object_updated, updated_object}
          )
        _ -> :ok
      end)

      failed = Enum.any?(results, fn
        {:error, _} -> true
        _ -> false
      end)

      end_time = System.monotonic_time(:millisecond)
      duration_ms = end_time - start_time

      Logger.info("Pattern layout operation completed: #{pattern} for #{length(results)} objects in #{duration_ms}ms")

      if failed do
        %{
          tool: "arrange_objects_with_pattern",
          input: input,
          result: {:error, :partial_update_failure}
        }
      else
        %{
          tool: "arrange_objects_with_pattern",
          input: input,
          result: {:ok, %{updated: length(results), pattern: pattern, duration_ms: duration_ms}}
        }
      end
    end
  end

  # Executes a define_object_relationships tool call for constraint-based positioning.
  #
  # Uses declarative constraints (above, below, left_of, etc.) to calculate object positions.
  defp execute_tool_call(%{name: "define_object_relationships", input: input}, canvas_id, _current_color) do
    relationships = input["relationships"]
    apply_constraints = Map.get(input, "apply_constraints", true)

    start_time = System.monotonic_time(:millisecond)

    # Collect all unique object IDs from relationships
    object_ids = relationships
    |> Enum.flat_map(fn rel ->
      [rel["subject_id"], rel["reference_id"], Map.get(rel, "reference_id_2")]
    end)
    |> Enum.reject(&is_nil/1)
    |> Enum.uniq()

    # Fetch all objects involved
    objects = Enum.map(object_ids, fn id ->
      case Canvases.get_object(id) do
        nil -> nil
        obj ->
          data = if is_binary(obj.data) do
            Jason.decode!(obj.data)
          else
            obj.data || %{}
          end

          %{
            id: obj.id,
            position: obj.position,
            data: data
          }
      end
    end)
    |> Enum.reject(&is_nil/1)

    if length(objects) == 0 do
      %{
        tool: "define_object_relationships",
        input: input,
        result: {:error, :no_objects_found}
      }
    else
      # Apply relationship-based positioning
      updates = Layout.apply_relationships(objects, relationships, apply_constraints)

      # Batch update all objects
      results = Enum.map(updates, fn update ->
        attrs = %{position: update.position}
        Canvases.update_object(update.id, attrs)
      end)

      # Broadcast updates to all connected clients for real-time sync
      Enum.each(results, fn
        {:ok, updated_object} ->
          Phoenix.PubSub.broadcast(
            CollabCanvas.PubSub,
            "canvas:#{canvas_id}",
            {:object_updated, updated_object}
          )
        _ -> :ok
      end)

      failed = Enum.any?(results, fn
        {:error, _} -> true
        _ -> false
      end)

      end_time = System.monotonic_time(:millisecond)
      duration_ms = end_time - start_time

      Logger.info("Relationship layout completed: #{length(relationships)} constraints for #{length(results)} objects in #{duration_ms}ms")

      if failed do
        %{
          tool: "define_object_relationships",
          input: input,
          result: {:error, :partial_update_failure}
        }
      else
        %{
          tool: "define_object_relationships",
          input: input,
          result: {:ok, %{updated: length(results), relationships: length(relationships), duration_ms: duration_ms}}
        }
      end
    end
  end

  # Fallback handler for unknown tool calls.
  #
  # Logs a warning and returns an error result for any unrecognized tool.
  defp execute_tool_call(tool_call, _canvas_id, _current_color) do
    Logger.warning("Unknown tool call: #{inspect(tool_call)}")

    %{
      tool: "unknown",
      input: tool_call,
      result: {:error, :unknown_tool}
    }
  end
end
</file>

<file path="lib/collab_canvas/ai/component_builder.ex">
defmodule CollabCanvas.AI.ComponentBuilder do
  @moduledoc """
  Builds complex UI components for the AI agent.

  This module provides functions to create multi-element UI components like login forms,
  navbars, cards, button groups, and sidebars. Each component consists of multiple shapes
  and text elements that are created and positioned together.
  """

  alias CollabCanvas.Canvases
  alias CollabCanvas.AI.Themes

  @doc """
  Creates a login form component with username, password fields, and submit button.

  ## Parameters
    * `canvas_id` - The canvas to create the component on
    * `x`, `y` - Position coordinates
    * `width`, `height` - Component dimensions
    * `theme` - Color theme ("light", "dark", "blue", or "green")
    * `content` - Map with optional :title key

  ## Returns
    * `{:ok, %{component_type: "login_form", object_ids: [...]}}` on success
  """
  def create_login_form(canvas_id, x, y, width, height, theme, content) do
    colors = Themes.get_theme_colors(theme)
    title = Map.get(content, "title", "Login")

    created_objects = []

    # Create background container
    {:ok, bg} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x,
      y,
      width,
      height,
      colors.bg,
      colors.border,
      2
    )
    created_objects = [bg.id | created_objects]

    # Create title text
    {:ok, title_text} = create_text_for_component(
      canvas_id,
      title,
      x + width / 2,
      y + 20,
      24,
      "Arial",
      colors.text_primary,
      "center"
    )
    created_objects = [title_text.id | created_objects]

    # Username label
    {:ok, username_label} = create_text_for_component(
      canvas_id,
      "Username:",
      x + 20,
      y + 60,
      14,
      "Arial",
      colors.text_secondary,
      "left"
    )
    created_objects = [username_label.id | created_objects]

    # Username input box
    {:ok, username_input} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x + 20,
      y + 80,
      width - 40,
      40,
      colors.input_bg,
      colors.input_border,
      1
    )
    created_objects = [username_input.id | created_objects]

    # Password label
    {:ok, password_label} = create_text_for_component(
      canvas_id,
      "Password:",
      x + 20,
      y + 130,
      14,
      "Arial",
      colors.text_secondary,
      "left"
    )
    created_objects = [password_label.id | created_objects]

    # Password input box
    {:ok, password_input} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x + 20,
      y + 150,
      width - 40,
      40,
      colors.input_bg,
      colors.input_border,
      1
    )
    created_objects = [password_input.id | created_objects]

    # Submit button
    {:ok, submit_btn} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x + 20,
      y + 210,
      width - 40,
      45,
      colors.button_bg,
      colors.button_border,
      0
    )
    created_objects = [submit_btn.id | created_objects]

    # Button text
    {:ok, btn_text} = create_text_for_component(
      canvas_id,
      "Sign In",
      x + width / 2,
      y + 225,
      16,
      "Arial",
      colors.button_text,
      "center"
    )
    created_objects = [btn_text.id | created_objects]

    {:ok, %{component_type: "login_form", object_ids: Enum.reverse(created_objects)}}
  end

  @doc """
  Creates a navigation bar component with logo and menu items.

  ## Parameters
    * `canvas_id` - The canvas to create the component on
    * `x`, `y` - Position coordinates
    * `width`, `height` - Component dimensions
    * `theme` - Color theme
    * `content` - Map with optional :title and :items keys

  ## Returns
    * `{:ok, %{component_type: "navbar", object_ids: [...]}}` on success
  """
  def create_navbar(canvas_id, x, y, width, height, theme, content) do
    colors = Themes.get_theme_colors(theme)
    items = Map.get(content, "items", ["Home", "About", "Services", "Contact"])
    title = Map.get(content, "title", "Brand")

    created_objects = []

    # Create navbar background
    {:ok, bg} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x,
      y,
      width,
      height,
      colors.navbar_bg,
      colors.border,
      0
    )
    created_objects = [bg.id | created_objects]

    # Create logo/brand text
    {:ok, logo} = create_text_for_component(
      canvas_id,
      title,
      x + 20,
      y + height / 2 - 10,
      20,
      "Arial",
      colors.text_primary,
      "left"
    )
    created_objects = [logo.id | created_objects]

    # Calculate spacing for menu items
    item_count = length(items)
    available_width = width - 200
    item_spacing = if item_count > 1, do: available_width / (item_count - 1), else: 0

    # Create menu items
    created_objects = items
    |> Enum.with_index()
    |> Enum.reduce(created_objects, fn {item, index}, acc ->
      item_x = x + 200 + index * item_spacing
      {:ok, menu_item} = create_text_for_component(
        canvas_id,
        item,
        item_x,
        y + height / 2 - 8,
        16,
        "Arial",
        colors.text_secondary,
        "center"
      )
      [menu_item.id | acc]
    end)

    {:ok, %{component_type: "navbar", object_ids: Enum.reverse(created_objects)}}
  end

  @doc """
  Creates a card component with header, content, and footer sections.

  ## Parameters
    * `canvas_id` - The canvas to create the component on
    * `x`, `y` - Position coordinates
    * `width`, `height` - Component dimensions
    * `theme` - Color theme
    * `content` - Map with optional :title and :subtitle keys

  ## Returns
    * `{:ok, %{component_type: "card", object_ids: [...]}}` on success
  """
  def create_card(canvas_id, x, y, width, height, theme, content) do
    colors = Themes.get_theme_colors(theme)
    title = Map.get(content, "title", "Card Title")
    subtitle = Map.get(content, "subtitle", "Card description goes here")

    created_objects = []

    # Create shadow effect (slightly offset darker rectangle)
    {:ok, shadow} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x + 4,
      y + 4,
      width,
      height,
      colors.shadow,
      colors.shadow,
      0
    )
    created_objects = [shadow.id | created_objects]

    # Create card background
    {:ok, bg} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x,
      y,
      width,
      height,
      colors.card_bg,
      colors.border,
      1
    )
    created_objects = [bg.id | created_objects]

    # Create header section
    {:ok, header} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x,
      y,
      width,
      60,
      colors.card_header_bg,
      colors.border,
      0
    )
    created_objects = [header.id | created_objects]

    # Create title text
    {:ok, title_text} = create_text_for_component(
      canvas_id,
      title,
      x + 20,
      y + 20,
      18,
      "Arial",
      colors.text_primary,
      "left"
    )
    created_objects = [title_text.id | created_objects]

    # Create content area text
    {:ok, content_text} = create_text_for_component(
      canvas_id,
      subtitle,
      x + 20,
      y + 80,
      14,
      "Arial",
      colors.text_secondary,
      "left"
    )
    created_objects = [content_text.id | created_objects]

    # Create footer section
    footer_y = y + height - 50
    {:ok, footer} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x,
      footer_y,
      width,
      50,
      colors.card_footer_bg,
      colors.border,
      0
    )
    created_objects = [footer.id | created_objects]

    {:ok, %{component_type: "card", object_ids: Enum.reverse(created_objects)}}
  end

  @doc """
  Creates a button group component with multiple buttons side by side.

  ## Parameters
    * `canvas_id` - The canvas to create the component on
    * `x`, `y` - Position coordinates
    * `width`, `height` - Component dimensions
    * `theme` - Color theme
    * `content` - Map with optional :items key (array of button labels)

  ## Returns
    * `{:ok, %{component_type: "button_group", object_ids: [...]}}` on success
  """
  def create_button_group(canvas_id, x, y, width, height, theme, content) do
    colors = Themes.get_theme_colors(theme)
    items = Map.get(content, "items", ["Button 1", "Button 2", "Button 3"])

    created_objects = []
    button_width = (width - 20 * (length(items) - 1)) / length(items)

    created_objects = items
    |> Enum.with_index()
    |> Enum.reduce(created_objects, fn {label, index}, acc ->
      btn_x = x + index * (button_width + 20)

      # Button background
      {:ok, btn} = create_shape_for_component(
        canvas_id,
        "rectangle",
        btn_x,
        y,
        button_width,
        height,
        colors.button_bg,
        colors.button_border,
        1
      )
      acc = [btn.id | acc]

      # Button text
      {:ok, btn_text} = create_text_for_component(
        canvas_id,
        label,
        btn_x + button_width / 2,
        y + height / 2 - 8,
        14,
        "Arial",
        colors.button_text,
        "center"
      )
      [btn_text.id | acc]
    end)

    {:ok, %{component_type: "button_group", object_ids: Enum.reverse(created_objects)}}
  end

  @doc """
  Creates a sidebar component with title and menu items.

  ## Parameters
    * `canvas_id` - The canvas to create the component on
    * `x`, `y` - Position coordinates
    * `width`, `height` - Component dimensions
    * `theme` - Color theme
    * `content` - Map with optional :title and :items keys

  ## Returns
    * `{:ok, %{component_type: "sidebar", object_ids: [...]}}` on success
  """
  def create_sidebar(canvas_id, x, y, width, height, theme, content) do
    colors = Themes.get_theme_colors(theme)
    items = Map.get(content, "items", ["Dashboard", "Profile", "Settings", "Logout"])
    title = Map.get(content, "title", "Menu")

    created_objects = []

    # Create sidebar background
    {:ok, bg} = create_shape_for_component(
      canvas_id,
      "rectangle",
      x,
      y,
      width,
      height,
      colors.sidebar_bg,
      colors.border,
      1
    )
    created_objects = [bg.id | created_objects]

    # Create title
    {:ok, title_text} = create_text_for_component(
      canvas_id,
      title,
      x + 20,
      y + 20,
      20,
      "Arial",
      colors.text_primary,
      "left"
    )
    created_objects = [title_text.id | created_objects]

    # Create menu items
    created_objects = items
    |> Enum.with_index()
    |> Enum.reduce(created_objects, fn {item, index}, acc ->
      item_y = y + 60 + index * 50

      # Menu item background (hover state)
      {:ok, item_bg} = create_shape_for_component(
        canvas_id,
        "rectangle",
        x + 10,
        item_y,
        width - 20,
        40,
        colors.sidebar_item_bg,
        colors.sidebar_item_border,
        1
      )
      acc = [item_bg.id | acc]

      # Menu item text
      {:ok, item_text} = create_text_for_component(
        canvas_id,
        item,
        x + 25,
        item_y + 12,
        14,
        "Arial",
        colors.text_secondary,
        "left"
      )
      [item_text.id | acc]
    end)

    {:ok, %{component_type: "sidebar", object_ids: Enum.reverse(created_objects)}}
  end

  # Helper functions for component creation

  @doc """
  Creates a shape object for use within a component.

  Internal helper function used by component builders to create individual shape elements.
  """
  def create_shape_for_component(canvas_id, type, x, y, width, height, fill, stroke, stroke_width) do
    data = %{
      width: width,
      height: height,
      fill: fill,
      stroke: stroke,
      stroke_width: stroke_width
    }

    attrs = %{
      position: %{x: x, y: y},
      data: Jason.encode!(data)
    }

    Canvases.create_object(canvas_id, type, attrs)
  end

  @doc """
  Creates a text object for use within a component.

  Internal helper function used by component builders to create individual text elements.
  """
  def create_text_for_component(canvas_id, text, x, y, font_size, font_family, color, align) do
    data = %{
      text: text,
      font_size: font_size,
      font_family: font_family,
      color: color,
      align: align
    }

    attrs = %{
      position: %{x: x, y: y},
      data: Jason.encode!(data)
    }

    Canvases.create_object(canvas_id, "text", attrs)
  end
end
</file>

<file path="lib/collab_canvas/ai/layout.ex">
defmodule CollabCanvas.AI.Layout do
  @moduledoc """
  AI-powered layout algorithms for arranging and aligning canvas objects.

  This module provides intelligent layout functions that can be triggered by AI commands
  to organize selected objects on the canvas. All algorithms are designed to meet
  performance requirements of <500ms for up to 50 objects.

  ## Available Layout Functions

  - `distribute_horizontally/2` - Distribute objects evenly along the X-axis
  - `distribute_vertically/2` - Distribute objects evenly along the Y-axis
  - `arrange_grid/3` - Arrange objects in a grid pattern
  - `align_objects/2` - Align objects to a common edge or center
  - `circular_layout/2` - Arrange objects in a circular pattern

  ## Layout Precision

  All layout calculations maintain precision within ±1px to ensure pixel-perfect
  alignment and spacing.

  ## Input Format

  Objects should be provided as a list of maps with the following structure:

      %{
        id: "object-uuid",
        position: %{x: 100, y: 200},
        data: %{width: 50, height: 50}  # or decoded JSON string
      }

  ## Output Format

  Functions return a list of update maps that can be applied to objects:

      [
        %{id: "object-1-uuid", position: %{x: 100, y: 200}},
        %{id: "object-2-uuid", position: %{x: 150, y: 200}}
      ]
  """

  @doc """
  Distributes objects horizontally with even spacing.

  ## Parameters
    * `objects` - List of object maps with id, position, and data
    * `spacing` - Spacing option:
      - `:even` - Calculate even spacing based on available space (default)
      - number - Use fixed spacing in pixels

  ## Returns
    List of update maps with new positions

  ## Examples

      iex> objects = [
      ...>   %{id: "1", position: %{x: 0, y: 100}, data: %{width: 50, height: 50}},
      ...>   %{id: "2", position: %{x: 100, y: 100}, data: %{width: 50, height: 50}}
      ...> ]
      iex> distribute_horizontally(objects, 20)
      [
        %{id: "1", position: %{x: 0, y: 100}},
        %{id: "2", position: %{x: 70, y: 100}}
      ]
  """
  def distribute_horizontally(objects, spacing \\ :even)

  def distribute_horizontally([], _spacing), do: []
  def distribute_horizontally([single], _spacing), do: [%{id: single.id, position: single.position}]

  def distribute_horizontally(objects, spacing) when is_list(objects) do
    # Sort objects by X position
    sorted_objects = Enum.sort_by(objects, &get_position_x/1)

    case spacing do
      :even ->
        distribute_horizontally_even(sorted_objects)

      spacing_value when is_number(spacing_value) ->
        distribute_horizontally_fixed(sorted_objects, spacing_value)

      _ ->
        distribute_horizontally_even(sorted_objects)
    end
  end

  @doc """
  Distributes objects vertically with even spacing.

  ## Parameters
    * `objects` - List of object maps with id, position, and data
    * `spacing` - Spacing option:
      - `:even` - Calculate even spacing based on available space (default)
      - number - Use fixed spacing in pixels

  ## Returns
    List of update maps with new positions

  ## Examples

      iex> objects = [
      ...>   %{id: "1", position: %{x: 100, y: 0}, data: %{width: 50, height: 50}},
      ...>   %{id: "2", position: %{x: 100, y: 100}, data: %{width: 50, height: 50}}
      ...> ]
      iex> distribute_vertically(objects, 20)
      [
        %{id: "1", position: %{x: 100, y: 0}},
        %{id: "2", position: %{x: 100, y: 70}}
      ]
  """
  def distribute_vertically(objects, spacing \\ :even)

  def distribute_vertically([], _spacing), do: []
  def distribute_vertically([single], _spacing), do: [%{id: single.id, position: single.position}]

  def distribute_vertically(objects, spacing) when is_list(objects) do
    # Sort objects by Y position
    sorted_objects = Enum.sort_by(objects, &get_position_y/1)

    case spacing do
      :even ->
        distribute_vertically_even(sorted_objects)

      spacing_value when is_number(spacing_value) ->
        distribute_vertically_fixed(sorted_objects, spacing_value)

      _ ->
        distribute_vertically_even(sorted_objects)
    end
  end

  @doc """
  Arranges objects in a grid layout.

  ## Parameters
    * `objects` - List of object maps with id, position, and data
    * `columns` - Number of columns in the grid
    * `spacing` - Spacing between objects in pixels (default: 20)

  ## Returns
    List of update maps with new positions

  ## Examples

      iex> objects = [
      ...>   %{id: "1", position: %{x: 0, y: 0}, data: %{width: 50, height: 50}},
      ...>   %{id: "2", position: %{x: 100, y: 0}, data: %{width: 50, height: 50}},
      ...>   %{id: "3", position: %{x: 200, y: 0}, data: %{width: 50, height: 50}}
      ...> ]
      iex> arrange_grid(objects, 2, 10)
      [
        %{id: "1", position: %{x: 0, y: 0}},
        %{id: "2", position: %{x: 60, y: 0}},
        %{id: "3", position: %{x: 0, y: 60}}
      ]
  """
  def arrange_grid(objects, columns, spacing \\ 20)

  def arrange_grid([], _columns, _spacing), do: []

  def arrange_grid(objects, columns, spacing) when is_list(objects) and is_integer(columns) and columns > 0 do
    # Start from the top-left position of the first object
    first_obj = Enum.at(objects, 0)
    start_x = get_position_x(first_obj) |> round()
    start_y = get_position_y(first_obj) |> round()

    # Calculate max width and height for uniform grid cells
    max_width = objects
                |> Enum.map(fn obj -> get_object_width(obj) end)
                |> Enum.max(fn -> 0 end)
                |> round()

    max_height = objects
                 |> Enum.map(fn obj -> get_object_height(obj) end)
                 |> Enum.max(fn -> 0 end)
                 |> round()

    # Place objects in grid
    objects
    |> Enum.with_index()
    |> Enum.map(fn {obj, index} ->
      row = div(index, columns)
      col = rem(index, columns)

      new_x = start_x + col * (max_width + spacing)
      new_y = start_y + row * (max_height + spacing)

      %{
        id: obj.id,
        position: %{x: new_x, y: new_y}
      }
    end)
  end

  @doc """
  Aligns objects to a common edge or center.

  ## Parameters
    * `objects` - List of object maps with id, position, and data
    * `alignment` - Alignment type:
      - `"left"` - Align left edges
      - `"right"` - Align right edges
      - `"center"` - Align horizontal centers
      - `"top"` - Align top edges
      - `"bottom"` - Align bottom edges
      - `"middle"` - Align vertical centers

  ## Returns
    List of update maps with new positions

  ## Examples

      iex> objects = [
      ...>   %{id: "1", position: %{x: 0, y: 0}, data: %{width: 50, height: 50}},
      ...>   %{id: "2", position: %{x: 100, y: 50}, data: %{width: 50, height: 50}}
      ...> ]
      iex> align_objects(objects, "left")
      [
        %{id: "1", position: %{x: 0, y: 0}},
        %{id: "2", position: %{x: 0, y: 50}}
      ]
  """
  def align_objects([], _alignment), do: []
  def align_objects([single], _alignment), do: [%{id: single.id, position: single.position}]

  def align_objects(objects, alignment) when is_list(objects) do
    case alignment do
      "left" -> align_left(objects)
      "right" -> align_right(objects)
      "center" -> align_center_horizontal(objects)
      "top" -> align_top(objects)
      "bottom" -> align_bottom(objects)
      "middle" -> align_middle_vertical(objects)
      _ -> Enum.map(objects, fn obj -> %{id: obj.id, position: obj.position} end)
    end
  end

  @doc """
  Arranges objects in a circular pattern.

  ## Parameters
    * `objects` - List of object maps with id, position, and data
    * `radius` - Radius of the circle in pixels

  ## Returns
    List of update maps with new positions

  ## Examples

      iex> objects = [
      ...>   %{id: "1", position: %{x: 0, y: 0}, data: %{width: 50, height: 50}},
      ...>   %{id: "2", position: %{x: 100, y: 0}, data: %{width: 50, height: 50}}
      ...> ]
      iex> circular_layout(objects, 100)
      [
        %{id: "1", position: %{x: 100, y: 0}},
        %{id: "2", position: %{x: 0, y: 100}}
      ]
  """
  def circular_layout([], _radius), do: []
  def circular_layout([single], _radius), do: [%{id: single.id, position: single.position}]

  def circular_layout(objects, radius) when is_list(objects) and is_number(radius) do
    require Logger

    # Calculate center point based on average position
    position_x_values = Enum.map(objects, &get_position_x/1)
    Logger.debug("Position X values: #{inspect(position_x_values)}")

    center_x = position_x_values
               |> Enum.sum()
               |> Kernel./(length(objects))
               |> round()

    Logger.debug("Center X: #{inspect(center_x)}, is_number: #{is_number(center_x)}")

    position_y_values = Enum.map(objects, &get_position_y/1)
    Logger.debug("Position Y values: #{inspect(position_y_values)}")

    center_y = position_y_values
               |> Enum.sum()
               |> Kernel./(length(objects))
               |> round()

    Logger.debug("Center Y: #{inspect(center_y)}, is_number: #{is_number(center_y)}")

    # Distribute objects evenly around the circle
    count = length(objects)
    angle_step = 2 * :math.pi() / count

    Logger.debug("Radius: #{inspect(radius)}, Count: #{count}, Angle step: #{inspect(angle_step)}")

    objects
    |> Enum.with_index()
    |> Enum.map(fn {obj, index} ->
      angle = index * angle_step

      Logger.debug("Object #{index}: angle=#{inspect(angle)}")

      # Calculate position on circle, accounting for object size to center it
      obj_width = get_object_width(obj)
      obj_height = get_object_height(obj)

      Logger.debug("Object #{index}: width=#{inspect(obj_width)} (is_number: #{is_number(obj_width)}), height=#{inspect(obj_height)} (is_number: #{is_number(obj_height)})")

      cos_value = :math.cos(angle)
      sin_value = :math.sin(angle)
      Logger.debug("Object #{index}: cos(#{angle})=#{inspect(cos_value)}, sin(#{angle})=#{inspect(sin_value)}")

      radius_cos = radius * cos_value
      Logger.debug("Object #{index}: radius * cos = #{inspect(radius_cos)} (is_number: #{is_number(radius_cos)})")

      width_half = obj_width / 2
      Logger.debug("Object #{index}: width / 2 = #{inspect(width_half)} (is_number: #{is_number(width_half)})")

      offset_x = radius_cos - width_half
      Logger.debug("Object #{index}: offset_x = #{inspect(offset_x)} (is_number: #{is_number(offset_x)})")

      new_x = center_x + round(offset_x)
      new_y = center_y + round(radius * sin_value - obj_height / 2)

      Logger.debug("Object #{index}: new_x=#{inspect(new_x)}, new_y=#{inspect(new_y)}")

      %{
        id: obj.id,
        position: %{x: new_x, y: new_y}
      }
    end)
  end

  # Private helper functions

  # Distributes objects horizontally with even spacing between them
  defp distribute_horizontally_even(sorted_objects) do
    first = List.first(sorted_objects)
    last = List.last(sorted_objects)

    # Calculate total available space
    first_x = get_position_x(first)
    last_x = get_position_x(last)
    last_width = get_object_width(last)

    total_width = (last_x + last_width) - first_x

    # Calculate total object widths
    total_object_width = sorted_objects
                         |> Enum.map(&get_object_width/1)
                         |> Enum.sum()

    # Calculate even spacing
    total_gap_space = total_width - total_object_width
    gap_count = length(sorted_objects) - 1
    spacing = if gap_count > 0, do: total_gap_space / gap_count, else: 0

    # Position objects with calculated spacing
    {result, _} = Enum.reduce(sorted_objects, {[], first_x}, fn obj, {acc, current_x} ->
      new_position = %{x: round(current_x), y: get_position_y(obj)}
      update = %{id: obj.id, position: new_position}
      next_x = current_x + get_object_width(obj) + spacing

      {acc ++ [update], next_x}
    end)

    result
  end

  # Distributes objects horizontally with fixed spacing
  defp distribute_horizontally_fixed(sorted_objects, spacing) do
    first = List.first(sorted_objects)
    start_x = get_position_x(first)

    {result, _} = Enum.reduce(sorted_objects, {[], start_x}, fn obj, {acc, current_x} ->
      new_position = %{x: round(current_x), y: get_position_y(obj)}
      update = %{id: obj.id, position: new_position}
      next_x = current_x + get_object_width(obj) + spacing

      {acc ++ [update], next_x}
    end)

    result
  end

  # Distributes objects vertically with even spacing between them
  defp distribute_vertically_even(sorted_objects) do
    first = List.first(sorted_objects)
    last = List.last(sorted_objects)

    # Calculate total available space
    first_y = get_position_y(first)
    last_y = get_position_y(last)
    last_height = get_object_height(last)

    total_height = (last_y + last_height) - first_y

    # Calculate total object heights
    total_object_height = sorted_objects
                          |> Enum.map(&get_object_height/1)
                          |> Enum.sum()

    # Calculate even spacing
    total_gap_space = total_height - total_object_height
    gap_count = length(sorted_objects) - 1
    spacing = if gap_count > 0, do: total_gap_space / gap_count, else: 0

    # Position objects with calculated spacing
    {result, _} = Enum.reduce(sorted_objects, {[], first_y}, fn obj, {acc, current_y} ->
      new_position = %{x: get_position_x(obj), y: round(current_y)}
      update = %{id: obj.id, position: new_position}
      next_y = current_y + get_object_height(obj) + spacing

      {acc ++ [update], next_y}
    end)

    result
  end

  # Distributes objects vertically with fixed spacing
  defp distribute_vertically_fixed(sorted_objects, spacing) do
    first = List.first(sorted_objects)
    start_y = get_position_y(first)

    {result, _} = Enum.reduce(sorted_objects, {[], start_y}, fn obj, {acc, current_y} ->
      new_position = %{x: get_position_x(obj), y: round(current_y)}
      update = %{id: obj.id, position: new_position}
      next_y = current_y + get_object_height(obj) + spacing

      {acc ++ [update], next_y}
    end)

    result
  end

  # Alignment helper functions

  defp align_left(objects) do
    min_x = objects |> Enum.map(&get_position_x/1) |> Enum.min() |> round()

    Enum.map(objects, fn obj ->
      %{id: obj.id, position: %{x: min_x, y: get_position_y(obj)}}
    end)
  end

  defp align_right(objects) do
    max_right = objects
                |> Enum.map(fn obj -> get_position_x(obj) + get_object_width(obj) end)
                |> Enum.max()
                |> round()

    Enum.map(objects, fn obj ->
      width = get_object_width(obj)
      new_x = max_right - width
      %{id: obj.id, position: %{x: round(new_x), y: get_position_y(obj)}}
    end)
  end

  defp align_center_horizontal(objects) do
    centers = Enum.map(objects, fn obj ->
      get_position_x(obj) + get_object_width(obj) / 2
    end)

    avg_center = Enum.sum(centers) / length(centers)

    Enum.map(objects, fn obj ->
      width = get_object_width(obj)
      new_x = avg_center - width / 2
      %{id: obj.id, position: %{x: round(new_x), y: get_position_y(obj)}}
    end)
  end

  defp align_top(objects) do
    min_y = objects |> Enum.map(&get_position_y/1) |> Enum.min() |> round()

    Enum.map(objects, fn obj ->
      %{id: obj.id, position: %{x: get_position_x(obj), y: min_y}}
    end)
  end

  defp align_bottom(objects) do
    max_bottom = objects
                 |> Enum.map(fn obj -> get_position_y(obj) + get_object_height(obj) end)
                 |> Enum.max()
                 |> round()

    Enum.map(objects, fn obj ->
      height = get_object_height(obj)
      new_y = max_bottom - height
      %{id: obj.id, position: %{x: get_position_x(obj), y: round(new_y)}}
    end)
  end

  defp align_middle_vertical(objects) do
    centers = Enum.map(objects, fn obj ->
      get_position_y(obj) + get_object_height(obj) / 2
    end)

    avg_center = Enum.sum(centers) / length(centers)

    Enum.map(objects, fn obj ->
      height = get_object_height(obj)
      new_y = avg_center - height / 2
      %{id: obj.id, position: %{x: get_position_x(obj), y: round(new_y)}}
    end)
  end

  # Utility functions to safely extract dimensions and positions

  defp get_position_x(obj) do
    x = cond do
      is_map(obj.position) and Map.has_key?(obj.position, :x) ->
        obj.position.x

      is_map(obj.position) and Map.has_key?(obj.position, "x") ->
        obj.position["x"]

      true ->
        0  # Default x position
    end

    # Ensure we always return a number
    case x do
      val when is_number(val) -> val
      _ -> 0
    end
  end

  defp get_position_y(obj) do
    y = cond do
      is_map(obj.position) and Map.has_key?(obj.position, :y) ->
        obj.position.y

      is_map(obj.position) and Map.has_key?(obj.position, "y") ->
        obj.position["y"]

      true ->
        0  # Default y position
    end

    # Ensure we always return a number
    case y do
      val when is_number(val) -> val
      _ -> 0
    end
  end

  defp get_object_width(obj) do
    width = cond do
      is_map(obj.data) and Map.has_key?(obj.data, :width) ->
        obj.data.width

      is_map(obj.data) and Map.has_key?(obj.data, "width") ->
        obj.data["width"]

      true ->
        50  # Default width
    end

    # Ensure we always return a number
    case width do
      w when is_number(w) -> w
      _ -> 50
    end
  end

  defp get_object_height(obj) do
    height = cond do
      is_map(obj.data) and Map.has_key?(obj.data, :height) ->
        obj.data.height

      is_map(obj.data) and Map.has_key?(obj.data, "height") ->
        obj.data["height"]

      true ->
        50  # Default height
    end

    # Ensure we always return a number
    case height do
      h when is_number(h) -> h
      _ -> 50
    end
  end

  @doc """
  Applies flexible programmatic pattern-based layout to objects.

  ## Parameters
    * `objects` - List of object maps with id, position, and data
    * `pattern` - Pattern type: "line", "diagonal", "wave", "arc", "custom"
    * `params` - Map of pattern-specific parameters (spacing, direction, start_x, start_y, etc.)

  ## Returns
    List of update maps with new positions

  ## Examples

      iex> objects = [%{id: "1", position: %{x: 0, y: 0}, data: %{width: 50, height: 50}}]
      iex> params = %{"direction" => "vertical", "spacing" => 50}
      iex> pattern_layout(objects, "line", params)
      [%{id: "1", position: %{x: 0, y: 0}}]
  """
  def pattern_layout([], _pattern, _params), do: []

  def pattern_layout(objects, pattern, params) when is_list(objects) do
    # Sort objects if specified
    sorted_objects = case Map.get(params, "sort_by", "none") do
      "x" -> Enum.sort_by(objects, &get_position_x/1)
      "y" -> Enum.sort_by(objects, &get_position_y/1)
      "size" -> Enum.sort_by(objects, fn obj ->
        get_object_width(obj) * get_object_height(obj)
      end)
      "id" -> Enum.sort_by(objects, & &1.id)
      _ -> objects
    end

    # Apply pattern-specific layout
    case pattern do
      "line" ->
        apply_line_pattern(sorted_objects, params)

      "diagonal" ->
        apply_diagonal_pattern(sorted_objects, params)

      "wave" ->
        apply_wave_pattern(sorted_objects, params)

      "arc" ->
        apply_arc_pattern(sorted_objects, params)

      "custom" ->
        # For custom patterns, just return objects as-is
        # (AI would need to specify exact positions via relationships)
        Enum.map(sorted_objects, fn obj ->
          %{id: obj.id, position: obj.position}
        end)

      _ ->
        Enum.map(sorted_objects, fn obj ->
          %{id: obj.id, position: obj.position}
        end)
    end
  end

  @doc """
  Applies relationship-based constraint positioning to objects.

  ## Parameters
    * `objects` - List of object maps with id, position, and data
    * `relationships` - List of constraint maps with subject_id, relation, reference_id, spacing
    * `apply_constraints` - Whether to apply full constraint solving (true) or sequential application (false)

  ## Returns
    List of update maps with new positions

  ## Examples

      iex> objects = [
      ...>   %{id: 1, position: %{x: 0, y: 0}, data: %{width: 50, height: 50}},
      ...>   %{id: 2, position: %{x: 100, y: 0}, data: %{width: 50, height: 50}}
      ...> ]
      iex> relationships = [%{"subject_id" => 2, "relation" => "below", "reference_id" => 1, "spacing" => 20}]
      iex> apply_relationships(objects, relationships, true)
      [
        %{id: 1, position: %{x: 0, y: 0}},
        %{id: 2, position: %{x: 0, y: 70}}
      ]
  """
  def apply_relationships([], _relationships, _apply_constraints), do: []

  def apply_relationships(objects, relationships, _apply_constraints) when is_list(objects) do
    # Build a map of object IDs to objects for quick lookup
    objects_map = Enum.into(objects, %{}, fn obj -> {obj.id, obj} end)

    # Start with current positions
    initial_positions = Enum.into(objects, %{}, fn obj ->
      {obj.id, obj.position}
    end)

    # Apply each relationship constraint sequentially
    final_positions = Enum.reduce(relationships, initial_positions, fn rel, positions ->
      apply_single_relationship(rel, positions, objects_map)
    end)

    # Convert back to list of updates
    Enum.map(objects, fn obj ->
      %{
        id: obj.id,
        position: Map.get(final_positions, obj.id, obj.position)
      }
    end)
  end

  # Private helper functions for pattern layouts

  defp apply_line_pattern(objects, params) do
    direction = Map.get(params, "direction", "horizontal")
    spacing = Map.get(params, "spacing", 50)
    start_x = Map.get(params, "start_x", get_position_x(List.first(objects)))
    start_y = Map.get(params, "start_y", get_position_y(List.first(objects)))

    case direction do
      "vertical" ->
        {result, _} = Enum.reduce(objects, {[], start_y}, fn obj, {acc, current_y} ->
          update = %{id: obj.id, position: %{x: round(start_x), y: round(current_y)}}
          next_y = current_y + get_object_height(obj) + spacing
          {acc ++ [update], next_y}
        end)
        result

      "horizontal" ->
        {result, _} = Enum.reduce(objects, {[], start_x}, fn obj, {acc, current_x} ->
          update = %{id: obj.id, position: %{x: round(current_x), y: round(start_y)}}
          next_x = current_x + get_object_width(obj) + spacing
          {acc ++ [update], next_x}
        end)
        result

      _ ->
        # Default to horizontal
        {result, _} = Enum.reduce(objects, {[], start_x}, fn obj, {acc, current_x} ->
          update = %{id: obj.id, position: %{x: round(current_x), y: round(start_y)}}
          next_x = current_x + get_object_width(obj) + spacing
          {acc ++ [update], next_x}
        end)
        result
    end
  end

  defp apply_diagonal_pattern(objects, params) do
    direction = Map.get(params, "direction", "diagonal-right")
    spacing = Map.get(params, "spacing", 50)
    start_x = Map.get(params, "start_x", get_position_x(List.first(objects)))
    start_y = Map.get(params, "start_y", get_position_y(List.first(objects)))

    {dx, dy} = case direction do
      "diagonal-right" -> {1, 1}
      "diagonal-left" -> {-1, 1}
      _ -> {1, 1}
    end

    objects
    |> Enum.with_index()
    |> Enum.map(fn {obj, index} ->
      offset = index * spacing
      new_x = start_x + (dx * offset)
      new_y = start_y + (dy * offset)

      %{id: obj.id, position: %{x: round(new_x), y: round(new_y)}}
    end)
  end

  defp apply_wave_pattern(objects, params) do
    spacing = Map.get(params, "spacing", 50)
    amplitude = Map.get(params, "amplitude", 100)
    frequency = Map.get(params, "frequency", 2)
    start_x = Map.get(params, "start_x", get_position_x(List.first(objects)))
    start_y = Map.get(params, "start_y", get_position_y(List.first(objects)))

    count = length(objects)

    objects
    |> Enum.with_index()
    |> Enum.map(fn {obj, index} ->
      x_offset = index * spacing
      # Wave function: y = amplitude * sin(frequency * x / total_width * 2π)
      progress = index / max(count - 1, 1)
      y_offset = amplitude * :math.sin(frequency * progress * 2 * :math.pi())

      new_x = start_x + x_offset
      new_y = start_y + y_offset

      %{id: obj.id, position: %{x: round(new_x), y: round(new_y)}}
    end)
  end

  defp apply_arc_pattern(objects, params) do
    amplitude = Map.get(params, "amplitude", 100)
    spacing = Map.get(params, "spacing", 50)
    start_x = Map.get(params, "start_x", get_position_x(List.first(objects)))
    start_y = Map.get(params, "start_y", get_position_y(List.first(objects)))

    count = length(objects)

    objects
    |> Enum.with_index()
    |> Enum.map(fn {obj, index} ->
      x_offset = index * spacing
      # Arc function: parabola y = -a * (x - w/2)^2 + h
      progress = index / max(count - 1, 1)
      normalized = (progress - 0.5) * 2  # -1 to 1
      y_offset = amplitude * (1 - normalized * normalized)

      new_x = start_x + x_offset
      new_y = start_y - y_offset

      %{id: obj.id, position: %{x: round(new_x), y: round(new_y)}}
    end)
  end

  defp apply_single_relationship(rel, positions, objects_map) do
    subject_id = rel["subject_id"]
    relation = rel["relation"]
    reference_id = rel["reference_id"]
    spacing = Map.get(rel, "spacing", 20)

    subject_obj = Map.get(objects_map, subject_id)
    reference_obj = Map.get(objects_map, reference_id)

    if is_nil(subject_obj) or is_nil(reference_obj) do
      positions
    else
      reference_pos = Map.get(positions, reference_id, reference_obj.position)

      new_position = case relation do
        "below" ->
          ref_y = get_position_value(reference_pos, :y)
          ref_height = get_object_height(reference_obj)
          %{
            x: get_position_value(reference_pos, :x),
            y: round(ref_y + ref_height + spacing)
          }

        "above" ->
          ref_y = get_position_value(reference_pos, :y)
          subject_height = get_object_height(subject_obj)
          %{
            x: get_position_value(reference_pos, :x),
            y: round(ref_y - subject_height - spacing)
          }

        "right_of" ->
          ref_x = get_position_value(reference_pos, :x)
          ref_width = get_object_width(reference_obj)
          %{
            x: round(ref_x + ref_width + spacing),
            y: get_position_value(reference_pos, :y)
          }

        "left_of" ->
          ref_x = get_position_value(reference_pos, :x)
          subject_width = get_object_width(subject_obj)
          %{
            x: round(ref_x - subject_width - spacing),
            y: get_position_value(reference_pos, :y)
          }

        "aligned_horizontally_with" ->
          %{
            x: get_position_value(Map.get(positions, subject_id, subject_obj.position), :x),
            y: get_position_value(reference_pos, :y)
          }

        "aligned_vertically_with" ->
          %{
            x: get_position_value(reference_pos, :x),
            y: get_position_value(Map.get(positions, subject_id, subject_obj.position), :y)
          }

        "centered_between" ->
          # For centered_between, we need reference_id_2
          reference_id_2 = Map.get(rel, "reference_id_2")
          if reference_id_2 do
            reference_obj_2 = Map.get(objects_map, reference_id_2)
            reference_pos_2 = Map.get(positions, reference_id_2, reference_obj_2.position)

            ref1_x = get_position_value(reference_pos, :x)
            ref2_x = get_position_value(reference_pos_2, :x)
            ref1_y = get_position_value(reference_pos, :y)
            ref2_y = get_position_value(reference_pos_2, :y)

            center_x = (ref1_x + ref2_x) / 2
            center_y = (ref1_y + ref2_y) / 2

            %{x: round(center_x), y: round(center_y)}
          else
            Map.get(positions, subject_id, subject_obj.position)
          end

        _ ->
          # Unknown relation, keep current position
          Map.get(positions, subject_id, subject_obj.position)
      end

      Map.put(positions, subject_id, new_position)
    end
  end

  defp get_position_value(position, key) do
    cond do
      is_map(position) and Map.has_key?(position, key) ->
        Map.get(position, key)

      is_map(position) and Map.has_key?(position, to_string(key)) ->
        Map.get(position, to_string(key))

      true ->
        0
    end
  end
end
</file>

<file path="lib/collab_canvas/ai/themes.ex">
defmodule CollabCanvas.AI.Themes do
  @moduledoc """
  Provides color themes for UI components.

  Supports multiple themes including light, dark, blue, and green color schemes.
  Each theme provides colors for backgrounds, text, buttons, and other UI elements.
  """

  @doc """
  Returns a color scheme map for the specified theme.

  ## Parameters
    * `theme` - Theme name ("light", "dark", "blue", or "green")

  ## Returns
    * Map with color values in hex format

  ## Examples

      iex> get_theme_colors("dark")
      %{bg: "#1f2937", text_primary: "#f9fafb", ...}

      iex> get_theme_colors("light")
      %{bg: "#ffffff", text_primary: "#111827", ...}
  """
  def get_theme_colors(theme) do
    case theme do
      "dark" ->
        %{
          bg: "#1f2937",
          border: "#374151",
          text_primary: "#f9fafb",
          text_secondary: "#d1d5db",
          input_bg: "#374151",
          input_border: "#4b5563",
          button_bg: "#3b82f6",
          button_border: "#2563eb",
          button_text: "#ffffff",
          navbar_bg: "#111827",
          card_bg: "#1f2937",
          card_header_bg: "#374151",
          card_footer_bg: "#374151",
          shadow: "#00000066",
          sidebar_bg: "#1f2937",
          sidebar_item_bg: "#374151",
          sidebar_item_border: "#4b5563"
        }

      "blue" ->
        %{
          bg: "#eff6ff",
          border: "#93c5fd",
          text_primary: "#1e3a8a",
          text_secondary: "#3b82f6",
          input_bg: "#ffffff",
          input_border: "#93c5fd",
          button_bg: "#3b82f6",
          button_border: "#2563eb",
          button_text: "#ffffff",
          navbar_bg: "#3b82f6",
          card_bg: "#ffffff",
          card_header_bg: "#dbeafe",
          card_footer_bg: "#f0f9ff",
          shadow: "#3b82f633",
          sidebar_bg: "#dbeafe",
          sidebar_item_bg: "#bfdbfe",
          sidebar_item_border: "#93c5fd"
        }

      "green" ->
        %{
          bg: "#f0fdf4",
          border: "#86efac",
          text_primary: "#14532d",
          text_secondary: "#16a34a",
          input_bg: "#ffffff",
          input_border: "#86efac",
          button_bg: "#22c55e",
          button_border: "#16a34a",
          button_text: "#ffffff",
          navbar_bg: "#22c55e",
          card_bg: "#ffffff",
          card_header_bg: "#dcfce7",
          card_footer_bg: "#f0fdf4",
          shadow: "#22c55e33",
          sidebar_bg: "#dcfce7",
          sidebar_item_bg: "#bbf7d0",
          sidebar_item_border: "#86efac"
        }

      _ -> # "light" or default
        %{
          bg: "#ffffff",
          border: "#e5e7eb",
          text_primary: "#111827",
          text_secondary: "#6b7280",
          input_bg: "#ffffff",
          input_border: "#d1d5db",
          button_bg: "#3b82f6",
          button_border: "#2563eb",
          button_text: "#ffffff",
          navbar_bg: "#f9fafb",
          card_bg: "#ffffff",
          card_header_bg: "#f9fafb",
          card_footer_bg: "#f9fafb",
          shadow: "#00000026",
          sidebar_bg: "#f9fafb",
          sidebar_item_bg: "#ffffff",
          sidebar_item_border: "#e5e7eb"
        }
    end
  end
end
</file>

<file path="lib/collab_canvas/ai/tools.ex">
defmodule CollabCanvas.AI.Tools do
  @moduledoc """
  Defines function calling tool definitions for the Claude API.

  This module provides tool schemas that enable Claude AI to interact with the
  CollabCanvas system by creating, modifying, and organizing visual elements on
  the canvas. Tools are defined using the Claude API's function calling format,
  which includes JSON Schema-based input validation.

  ## Available Tools

  The module provides the following tools for canvas manipulation:

  - `create_shape` - Creates basic shapes (rectangles and circles) with customizable
    styling including fill color, stroke color, and stroke width
  - `create_text` - Adds text elements to the canvas with configurable font properties,
    color, and alignment
  - `move_shape` - Repositions existing shapes to new coordinates
  - `resize_shape` - Adjusts the dimensions of existing shapes
  - `create_component` - Generates complex UI components (buttons, cards, navbars,
    login forms, sidebars) with theme support
  - `delete_object` - Removes objects from the canvas
  - `group_objects` - Combines multiple objects into a named group for organization
  - `resize_object` - Resizes objects with optional aspect ratio preservation
  - `rotate_object` - Rotates objects by a specified angle around a pivot point
  - `change_style` - Changes styling properties (fill, stroke, opacity, fonts, etc.)
  - `update_text` - Updates text content and formatting options
  - `move_object` - Moves objects using delta or absolute coordinates

  ## Tool Schema Format

  Each tool definition follows the Claude API function calling schema:

      %{
        name: "tool_name",
        description: "What the tool does",
        input_schema: %{
          type: "object",
          properties: %{
            param_name: %{
              type: "string" | "number" | "array" | "object",
              description: "Parameter description",
              enum: [...],        # Optional: allowed values
              default: value      # Optional: default value
            }
          },
          required: ["param1", "param2"]
        }
      }

  ## Integration with Agent Module

  The `CollabCanvas.AI.Agent` module uses these tool definitions in two ways:

  1. **Tool Registration** - The definitions are passed to Claude's API via the
     `tools` parameter in chat completion requests, allowing Claude to understand
     what actions it can perform.

  2. **Tool Execution** - When Claude decides to use a tool, the Agent module:
     - Receives the tool name and parameters from Claude's response
     - Validates the parameters using `validate_tool_call/2`
     - Executes the corresponding canvas operation
     - Returns results to Claude for continued conversation

  ## Validation

  The module includes validation functions that:

  - Check for required parameters
  - Apply default values for optional parameters
  - Ensure parameter types match the schema
  - Return `{:ok, params}` or `{:error, reason}` tuples

  ## Example Usage

      # Get all tool definitions for Claude API
      tools = CollabCanvas.AI.Tools.get_tool_definitions()

      # Validate a tool call before execution
      case CollabCanvas.AI.Tools.validate_tool_call("create_shape", params) do
        {:ok, validated_params} -> execute_tool(validated_params)
        {:error, reason} -> handle_error(reason)
      end
  """

  @doc """
  Returns the complete list of tool definitions for Claude API function calling.

  This function provides all available tools that Claude can use to interact with
  the canvas. Each tool definition includes a name, description, and JSON Schema
  for input validation.

  ## Return Value

  Returns a list of tool definition maps, where each map contains:

  - `:name` - String identifier for the tool (e.g., "create_shape")
  - `:description` - Human-readable explanation of what the tool does
  - `:input_schema` - JSON Schema object defining required and optional parameters

  ## Usage

  The returned tool definitions are typically passed to the Claude API during
  initialization of a chat session:

      tools = CollabCanvas.AI.Tools.get_tool_definitions()
      # Pass tools to Claude API in the `tools` parameter

  The Agent module automatically includes these tools in its API requests,
  enabling Claude to call them based on user prompts and conversation context.

  ## Tool Categories

  The tools are organized into several categories:

  - **Creation Tools**: `create_shape`, `create_text`, `create_component`
  - **Manipulation Tools**: `move_shape`, `resize_shape`
  - **Organization Tools**: `group_objects`, `delete_object`

  ## Examples

      iex> tools = CollabCanvas.AI.Tools.get_tool_definitions()
      iex> length(tools)
      12

      iex> tools = CollabCanvas.AI.Tools.get_tool_definitions()
      iex> Enum.map(tools, & &1.name)
      ["create_shape", "create_text", "move_shape", "resize_shape",
       "create_component", "delete_object", "group_objects", "resize_object",
       "rotate_object", "change_style", "update_text", "move_object"]
  """
  def get_tool_definitions do
    [
      %{
        name: "create_shape",
        description: "Create a shape (rectangle or circle) on the canvas",
        input_schema: %{
          type: "object",
          properties: %{
            type: %{
              type: "string",
              enum: ["rectangle", "circle"],
              description: "The type of shape to create"
            },
            x: %{
              type: "number",
              description: "X coordinate for the shape position"
            },
            y: %{
              type: "number",
              description: "Y coordinate for the shape position"
            },
            width: %{
              type: "number",
              description: "Width of the shape (for rectangles) or diameter (for circles)"
            },
            height: %{
              type: "number",
              description: "Height of the shape (only for rectangles, ignored for circles)"
            },
            fill: %{
              type: "string",
              description: "Fill color in hex format (e.g., #3b82f6)",
              default: "#3b82f6"
            },
            stroke: %{
              type: "string",
              description: "Stroke color in hex format",
              default: "#1e40af"
            },
            stroke_width: %{
              type: "number",
              description: "Width of the stroke",
              default: 2
            }
          },
          required: ["type", "x", "y", "width"]
        }
      },
      %{
        name: "create_text",
        description: "Add text to the canvas",
        input_schema: %{
          type: "object",
          properties: %{
            text: %{
              type: "string",
              description: "The text content to display"
            },
            x: %{
              type: "number",
              description: "X coordinate for text position"
            },
            y: %{
              type: "number",
              description: "Y coordinate for text position"
            },
            font_size: %{
              type: "number",
              description: "Font size in pixels",
              default: 16
            },
            font_family: %{
              type: "string",
              description: "Font family name",
              default: "Arial"
            },
            color: %{
              type: "string",
              description: "Text color in hex format",
              default: "#000000"
            },
            align: %{
              type: "string",
              enum: ["left", "center", "right"],
              description: "Text alignment",
              default: "left"
            }
          },
          required: ["text", "x", "y"]
        }
      },
      %{
        name: "move_shape",
        description: "Move an existing shape to a new position",
        input_schema: %{
          type: "object",
          properties: %{
            shape_id: %{
              type: "integer",
              description: "ID of the shape to move"
            },
            x: %{
              type: "number",
              description: "New X coordinate"
            },
            y: %{
              type: "number",
              description: "New Y coordinate"
            }
          },
          required: ["shape_id", "x", "y"]
        }
      },
      %{
        name: "resize_shape",
        description: "Resize an existing shape",
        input_schema: %{
          type: "object",
          properties: %{
            shape_id: %{
              type: "integer",
              description: "ID of the shape to resize"
            },
            width: %{
              type: "number",
              description: "New width"
            },
            height: %{
              type: "number",
              description: "New height (ignored for circles)"
            }
          },
          required: ["shape_id", "width"]
        }
      },
      %{
        name: "create_component",
        description: "Create a complex UI component (group of shapes and text)",
        input_schema: %{
          type: "object",
          properties: %{
            type: %{
              type: "string",
              enum: ["button", "card", "navbar", "login_form", "sidebar"],
              description: "Type of component to create"
            },
            x: %{
              type: "number",
              description: "X coordinate for component position"
            },
            y: %{
              type: "number",
              description: "Y coordinate for component position"
            },
            width: %{
              type: "number",
              description: "Component width",
              default: 200
            },
            height: %{
              type: "number",
              description: "Component height",
              default: 100
            },
            theme: %{
              type: "string",
              enum: ["light", "dark", "blue", "green"],
              description: "Color theme for the component",
              default: "light"
            },
            content: %{
              type: "object",
              description: "Component-specific content configuration",
              properties: %{
                title: %{type: "string", description: "Component title or label"},
                subtitle: %{type: "string", description: "Secondary text"},
                items: %{
                  type: "array",
                  description: "List of items (for navbars, lists, etc.)",
                  items: %{type: "string"}
                }
              }
            }
          },
          required: ["type", "x", "y"]
        }
      },
      %{
        name: "delete_object",
        description: "Delete an object from the canvas",
        input_schema: %{
          type: "object",
          properties: %{
            object_id: %{
              type: "integer",
              description: "ID of the object to delete"
            }
          },
          required: ["object_id"]
        }
      },
      %{
        name: "group_objects",
        description: "Group multiple objects together",
        input_schema: %{
          type: "object",
          properties: %{
            object_ids: %{
              type: "array",
              description: "List of object IDs to group",
              items: %{type: "integer"}
            },
            group_name: %{
              type: "string",
              description: "Name for the group"
            }
          },
          required: ["object_ids"]
        }
      },
      %{
        name: "resize_object",
        description: "Resize an object with optional aspect ratio preservation",
        input_schema: %{
          type: "object",
          properties: %{
            object_id: %{
              type: "integer",
              description: "ID of the object to resize"
            },
            width: %{
              type: "number",
              description: "New width for the object"
            },
            height: %{
              type: "number",
              description: "New height for the object"
            },
            maintain_aspect_ratio: %{
              type: "boolean",
              description: "Whether to maintain the object's aspect ratio when resizing",
              default: false
            }
          },
          required: ["object_id", "width"]
        }
      },
      %{
        name: "rotate_object",
        description: "Rotate an object by a specified angle",
        input_schema: %{
          type: "object",
          properties: %{
            object_id: %{
              type: "integer",
              description: "ID of the object to rotate"
            },
            angle: %{
              type: "number",
              description: "Rotation angle in degrees (0-360, positive = clockwise)"
            },
            pivot_point: %{
              type: "string",
              enum: ["center", "top-left", "top-right", "bottom-left", "bottom-right"],
              description: "Point around which to rotate the object",
              default: "center"
            }
          },
          required: ["object_id", "angle"]
        }
      },
      %{
        name: "change_style",
        description: "Change styling properties of an object",
        input_schema: %{
          type: "object",
          properties: %{
            object_id: %{
              type: "integer",
              description: "ID of the object to style"
            },
            property: %{
              type: "string",
              enum: ["fill", "stroke", "stroke_width", "opacity", "font_size", "font_family", "color"],
              description: "The style property to change"
            },
            value: %{
              type: "string",
              description: "The new value for the property (e.g., '#ff0000' for colors, '2' for widths)"
            }
          },
          required: ["object_id", "property", "value"]
        }
      },
      %{
        name: "update_text",
        description: "Update text content and formatting of a text object",
        input_schema: %{
          type: "object",
          properties: %{
            object_id: %{
              type: "integer",
              description: "ID of the text object to update"
            },
            new_text: %{
              type: "string",
              description: "New text content"
            },
            font_size: %{
              type: "number",
              description: "Font size in pixels"
            },
            font_family: %{
              type: "string",
              description: "Font family name"
            },
            color: %{
              type: "string",
              description: "Text color in hex format"
            },
            align: %{
              type: "string",
              enum: ["left", "center", "right"],
              description: "Text alignment"
            },
            bold: %{
              type: "boolean",
              description: "Whether text should be bold"
            },
            italic: %{
              type: "boolean",
              description: "Whether text should be italic"
            }
          },
          required: ["object_id"]
        }
      },
      %{
        name: "move_object",
        description: "Move an object to a new position using delta or absolute coordinates",
        input_schema: %{
          type: "object",
          properties: %{
            object_id: %{
              type: "integer",
              description: "ID of the object to move"
            },
            delta_x: %{
              type: "number",
              description: "Relative X movement (positive = right, negative = left)"
            },
            delta_y: %{
              type: "number",
              description: "Relative Y movement (positive = down, negative = up)"
            },
            x: %{
              type: "number",
              description: "Absolute X coordinate (used if delta_x not provided)"
            },
            y: %{
              type: "number",
              description: "Absolute Y coordinate (used if delta_y not provided)"
            }
          },
          required: ["object_id"]
        }
      },
      %{
        name: "arrange_objects",
        description: "Arranges selected objects in specified layout pattern (horizontal, vertical, grid, circular)",
        input_schema: %{
          type: "object",
          properties: %{
            object_ids: %{
              type: "array",
              items: %{type: "integer"},
              description: "IDs of objects to arrange"
            },
            layout_type: %{
              type: "string",
              enum: ["horizontal", "vertical", "grid", "circular", "stack"],
              description: "Type of layout to apply"
            },
            spacing: %{
              type: "number",
              description: "Spacing between objects in pixels (default: 20)",
              default: 20
            },
            alignment: %{
              type: "string",
              enum: ["left", "center", "right", "top", "middle", "bottom"],
              description: "Alignment for objects (used with stack layout or separately)"
            },
            columns: %{
              type: "number",
              description: "Number of columns for grid layout",
              default: 3
            },
            radius: %{
              type: "number",
              description: "Radius in pixels for circular layout",
              default: 200
            }
          },
          required: ["object_ids", "layout_type"]
        }
      },
      %{
        name: "show_object_labels",
        description: "Toggle visual labels on canvas objects. Use this when user asks to 'show object IDs', 'show labels', 'display object names', or 'hide labels'. Labels appear directly on the canvas above each object showing their human-readable names (Rectangle 1, Circle 2, etc.)",
        input_schema: %{
          type: "object",
          properties: %{
            show: %{
              type: "boolean",
              description: "True to show labels, false to hide them"
            }
          },
          required: ["show"]
        }
      },
      %{
        name: "arrange_objects_with_pattern",
        description: "Arrange objects using flexible programmatic patterns. POWERFUL AND FLEXIBLE - use this for ANY custom arrangement beyond basic grids: 'triangular', 'pyramid', 'zigzag', 'wave', 'arc', 'diagonal', 'scattered', 'circular arc', etc. Supports line, diagonal, wave, and arc patterns with customizable parameters. For complex shapes like triangles or pyramids, use 'line' or 'diagonal' patterns with appropriate start positions and spacing, or make multiple calls to build up the shape row by row.",
        input_schema: %{
          type: "object",
          properties: %{
            object_ids: %{
              type: "array",
              items: %{type: "integer"},
              description: "IDs of objects to arrange"
            },
            pattern: %{
              type: "string",
              enum: ["line", "diagonal", "wave", "arc", "custom"],
              description: "Pattern type: 'line' for straight line (vertical/horizontal), 'diagonal' for angled line, 'wave' for wavy pattern, 'arc' for curved arc, 'custom' for fully custom positioning"
            },
            direction: %{
              type: "string",
              enum: ["horizontal", "vertical", "diagonal-right", "diagonal-left", "up", "down"],
              description: "Direction of the pattern (used with line and diagonal patterns)"
            },
            spacing: %{
              type: "number",
              description: "Spacing between objects in pixels",
              default: 50
            },
            alignment: %{
              type: "string",
              enum: ["start", "center", "end", "baseline"],
              description: "How objects align within the pattern"
            },
            start_x: %{
              type: "number",
              description: "Starting X coordinate for the pattern"
            },
            start_y: %{
              type: "number",
              description: "Starting Y coordinate for the pattern"
            },
            amplitude: %{
              type: "number",
              description: "Amplitude for wave/arc patterns (height of waves)",
              default: 100
            },
            frequency: %{
              type: "number",
              description: "Frequency for wave patterns (number of waves)",
              default: 2
            },
            sort_by: %{
              type: "string",
              enum: ["none", "x", "y", "size", "id"],
              description: "How to sort objects before arranging",
              default: "none"
            }
          },
          required: ["object_ids", "pattern"]
        }
      },
      %{
        name: "define_object_relationships",
        description: "Define spatial relationships using declarative constraints - HIGHLY FLEXIBLE for building complex formations. Use this to create triangles, pyramids, ladders, or any structured arrangement by defining relationships: 'A below B', 'C aligned with D', 'E centered between F and G'. Build complex shapes by chaining relationships (e.g., triangle: place objects below and left_of/right_of each other). The system solves constraints to calculate positions. Perfect for hierarchical, symmetric, or geometric patterns.",
        input_schema: %{
          type: "object",
          properties: %{
            relationships: %{
              type: "array",
              description: "List of relationship constraints to apply",
              items: %{
                type: "object",
                properties: %{
                  subject_id: %{
                    type: "integer",
                    description: "ID of the object being positioned"
                  },
                  relation: %{
                    type: "string",
                    enum: ["above", "below", "left_of", "right_of", "aligned_horizontally_with", "aligned_vertically_with", "centered_between", "same_spacing_as"],
                    description: "The spatial relationship to enforce"
                  },
                  reference_id: %{
                    type: "integer",
                    description: "ID of the reference object (or first reference for centered_between)"
                  },
                  reference_id_2: %{
                    type: "integer",
                    description: "Second reference object ID (used only for centered_between and same_spacing_as)"
                  },
                  spacing: %{
                    type: "number",
                    description: "Distance to maintain between objects (in pixels)",
                    default: 20
                  }
                },
                required: ["subject_id", "relation", "reference_id"]
              }
            },
            apply_constraints: %{
              type: "boolean",
              description: "Whether to apply constraint solving (true) or simple sequential application (false)",
              default: true
            }
          },
          required: ["relationships"]
        }
      }
    ]
  end

  @doc """
  Validates a tool call against its schema.
  Returns {:ok, params} if valid, {:error, reason} if invalid.
  """
  def validate_tool_call(tool_name, params) do
    tool = Enum.find(get_tool_definitions(), &(&1.name == tool_name))

    case tool do
      nil ->
        {:error, "Unknown tool: #{tool_name}"}

      tool_def ->
        validate_params(params, tool_def.input_schema)
    end
  end

  defp validate_params(params, schema) do
    required = Map.get(schema, :required, [])
    properties = Map.get(schema, :properties, %{})

    # Check required fields
    missing = Enum.filter(required, fn field ->
      field = to_string(field)
      !Map.has_key?(params, field) && !Map.has_key?(params, String.to_atom(field))
    end)

    if length(missing) > 0 do
      {:error, "Missing required fields: #{Enum.join(missing, ", ")}"}
    else
      # Add defaults for optional fields
      params_with_defaults = Enum.reduce(properties, params, fn {key, prop}, acc ->
        key_str = to_string(key)
        key_atom = String.to_atom(key_str)

        if !Map.has_key?(acc, key_str) && !Map.has_key?(acc, key_atom) && Map.has_key?(prop, :default) do
          Map.put(acc, key_atom, prop.default)
        else
          acc
        end
      end)

      {:ok, params_with_defaults}
    end
  end
end
</file>

<file path="lib/collab_canvas/canvases/canvas_user_viewport.ex">
defmodule CollabCanvas.Canvases.CanvasUserViewport do
  @moduledoc """
  Schema for tracking a user's viewport position and zoom level on a specific canvas.
  This allows users to return to their last viewing position when they reload or revisit a canvas.
  """

  use Ecto.Schema
  import Ecto.Changeset

  alias CollabCanvas.Accounts.User
  alias CollabCanvas.Canvases.Canvas

  schema "canvas_user_viewports" do
    field :viewport_x, :float
    field :viewport_y, :float
    field :zoom, :float

    belongs_to :user, User
    belongs_to :canvas, Canvas

    timestamps(type: :utc_datetime)
  end

  @doc """
  Changeset for creating or updating a canvas user viewport.

  ## Fields
    * `:user_id` - ID of the user (required)
    * `:canvas_id` - ID of the canvas (required)
    * `:viewport_x` - X coordinate of viewport center (defaults to 0.0)
    * `:viewport_y` - Y coordinate of viewport center (defaults to 0.0)
    * `:zoom` - Zoom level (defaults to 1.0)
  """
  def changeset(viewport, attrs) do
    viewport
    |> cast(attrs, [:user_id, :canvas_id, :viewport_x, :viewport_y, :zoom])
    |> validate_required([:user_id, :canvas_id, :viewport_x, :viewport_y, :zoom])
    |> validate_number(:zoom, greater_than: 0)
    |> unique_constraint([:user_id, :canvas_id])
    |> foreign_key_constraint(:user_id)
    |> foreign_key_constraint(:canvas_id)
  end
end
</file>

<file path="lib/collab_canvas/canvases/canvas.ex">
defmodule CollabCanvas.Canvases.Canvas do
  @moduledoc """
  Canvas schema for the CollabCanvas application.
  Represents a collaborative canvas workspace owned by a user.
  """

  use Ecto.Schema
  import Ecto.Changeset

  alias CollabCanvas.Accounts.User
  alias CollabCanvas.Canvases.Object

  schema "canvases" do
    field :name, :string

    belongs_to :user, User
    has_many :objects, Object

    timestamps(type: :utc_datetime)
  end

  @doc """
  Changeset for creating or updating a canvas.

  ## Required fields
    * `:name` - Canvas name/title
    * `:user_id` - ID of the user who owns this canvas

  ## Validations
    * Name must be present and between 1-255 characters
    * User ID must be present
  """
  def changeset(canvas, attrs) do
    canvas
    |> cast(attrs, [:name, :user_id])
    |> validate_required([:name, :user_id])
    |> validate_length(:name, min: 1, max: 255)
    |> foreign_key_constraint(:user_id, name: "canvases_user_id_fkey")
  end
end
</file>

<file path="lib/collab_canvas/canvases/object.ex">
defmodule CollabCanvas.Canvases.Object do
  @moduledoc """
  Object schema for the CollabCanvas application.
  Represents a graphical object (rectangle, circle, text, etc.) on a canvas.
  """

  use Ecto.Schema
  import Ecto.Changeset

  alias CollabCanvas.Canvases.Canvas
  alias CollabCanvas.Components.Component

  @derive {Jason.Encoder,
           only: [
             :id,
             :type,
             :data,
             :position,
             :canvas_id,
             :locked_by,
             :component_id,
             :is_main_component,
             :instance_overrides,
             :inserted_at,
             :updated_at
           ]}
  schema "objects" do
    field(:type, :string)
    field(:data, :string)
    field(:position, :map)
    field(:locked_by, :string)
    field(:is_main_component, :boolean, default: false)
    field(:instance_overrides, :string)

    belongs_to(:canvas, Canvas)
    belongs_to(:component, Component)

    timestamps(type: :utc_datetime)
  end

  @doc """
  Changeset for creating or updating an object.

  ## Required fields
    * `:type` - Object type (e.g., "rectangle", "circle", "text")
    * `:canvas_id` - ID of the canvas this object belongs to

  ## Optional fields
    * `:data` - JSON string containing object-specific data (color, size, text content, etc.)
    * `:position` - Map containing x and y coordinates
    * `:locked_by` - User ID string indicating which user has locked this object for editing
    * `:component_id` - ID of the component this object belongs to (for component instances)
    * `:is_main_component` - Boolean indicating if this is a main component object
    * `:instance_overrides` - JSON string containing instance-specific overrides

  ## Validations
    * Type must be present and one of the allowed types
    * Canvas ID must be present
    * Position must be a valid map with x and y keys when present
  """
  def changeset(object, attrs) do
    object
    |> cast(attrs, [
      :type,
      :data,
      :position,
      :canvas_id,
      :locked_by,
      :component_id,
      :is_main_component,
      :instance_overrides
    ])
    |> validate_required([:type, :canvas_id])
    |> validate_inclusion(:type, ["rectangle", "circle", "ellipse", "text", "line", "path"])
    |> validate_position()
    |> foreign_key_constraint(:canvas_id, name: "objects_canvas_id_fkey")
    |> foreign_key_constraint(:component_id, name: "objects_component_id_fkey")
  end

  # Private helper to validate position map structure
  defp validate_position(changeset) do
    case get_change(changeset, :position) do
      nil ->
        changeset

      position when is_map(position) ->
        x = Map.get(position, "x") || Map.get(position, :x)
        y = Map.get(position, "y") || Map.get(position, :y)

        cond do
          not is_number(x) ->
            add_error(changeset, :position, "must contain numeric x coordinate")

          not is_number(y) ->
            add_error(changeset, :position, "must contain numeric y coordinate")

          true ->
            changeset
        end

      _ ->
        add_error(changeset, :position, "must be a map with x and y coordinates")
    end
  end
end
</file>

<file path="lib/collab_canvas/color_palettes/user_color_preference.ex">
defmodule CollabCanvas.ColorPalettes.UserColorPreference do
  @moduledoc """
  Schema for user color preferences.

  Tracks a user's color history, favorites, and default color for canvas objects.
  Each user can have:
  - Up to 10 recent colors (automatically managed LIFO queue)
  - Unlimited favorite colors (manually pinned)
  - One default color for new objects
  """

  use Ecto.Schema
  import Ecto.Changeset

  alias CollabCanvas.Accounts.User

  @max_recent_colors 10

  schema "user_color_preferences" do
    belongs_to :user, User
    field :recent_colors, :string, default: "[]"  # JSON array of hex colors
    field :favorite_colors, :string, default: "[]"  # JSON array of hex colors
    field :default_color, :string, default: "#000000"

    timestamps(type: :utc_datetime)
  end

  @doc """
  Changeset for user color preferences.

  Validates:
  - user_id is required
  - recent_colors is valid JSON array with max 10 hex color strings
  - favorite_colors is valid JSON array of hex color strings
  - default_color is a valid hex color string
  """
  def changeset(preference, attrs) do
    preference
    |> cast(attrs, [:user_id, :recent_colors, :favorite_colors, :default_color])
    |> validate_required([:user_id])
    |> validate_color_format(:default_color)
    |> validate_json_color_array(:recent_colors, @max_recent_colors)
    |> validate_json_color_array(:favorite_colors)
    |> unique_constraint(:user_id)
  end

  # Validates that a field contains a valid hex color (#RRGGBB or #RRGGBBAA)
  defp validate_color_format(changeset, field) do
    validate_change(changeset, field, fn ^field, value ->
      if valid_hex_color?(value) do
        []
      else
        [{field, "must be a valid hex color (#RRGGBB or #RRGGBBAA)"}]
      end
    end)
  end

  # Validates that a field contains a valid JSON array of hex colors
  defp validate_json_color_array(changeset, field, max_count \\ nil) do
    validate_change(changeset, field, fn ^field, value ->
      case Jason.decode(value) do
        {:ok, colors} when is_list(colors) ->
          cond do
            max_count && length(colors) > max_count ->
              [{field, "can contain at most #{max_count} colors"}]

            not Enum.all?(colors, &valid_hex_color?/1) ->
              [{field, "must contain only valid hex colors"}]

            true ->
              []
          end

        {:ok, _} ->
          [{field, "must be a JSON array"}]

        {:error, _} ->
          [{field, "must be valid JSON"}]
      end
    end)
  end

  # Checks if a string is a valid hex color
  defp valid_hex_color?(color) when is_binary(color) do
    Regex.match?(~r/^#[0-9A-Fa-f]{6}([0-9A-Fa-f]{2})?$/, color)
  end

  defp valid_hex_color?(_), do: false

  @doc """
  Decodes recent colors from JSON string to list.
  """
  def decode_recent_colors(preference) do
    case Jason.decode(preference.recent_colors) do
      {:ok, colors} -> colors
      {:error, _} -> []
    end
  end

  @doc """
  Decodes favorite colors from JSON string to list.
  """
  def decode_favorite_colors(preference) do
    case Jason.decode(preference.favorite_colors) do
      {:ok, colors} -> colors
      {:error, _} -> []
    end
  end

  @doc """
  Adds a color to recent colors (LIFO queue with max 10 items).
  Removes duplicates and moves existing color to front.
  """
  def add_to_recent(recent_colors_json, new_color) when is_binary(recent_colors_json) and is_binary(new_color) do
    recent_colors =
      case Jason.decode(recent_colors_json) do
        {:ok, colors} when is_list(colors) -> colors
        _ -> []
      end

    # Remove existing instance of this color and prepend it
    updated_colors =
      [new_color | Enum.reject(recent_colors, &(&1 == new_color))]
      |> Enum.take(@max_recent_colors)

    Jason.encode!(updated_colors)
  end
end
</file>

<file path="lib/collab_canvas/components/component.ex">
defmodule CollabCanvas.Components.Component do
  @moduledoc """
  Component schema for the CollabCanvas application.
  Represents a reusable component that can be instantiated multiple times on canvases.
  """

  use Ecto.Schema
  import Ecto.Changeset

  alias CollabCanvas.Canvases.Canvas
  alias CollabCanvas.Accounts.User

  @derive {Jason.Encoder,
           only: [
             :id,
             :name,
             :description,
             :category,
             :canvas_id,
             :created_by,
             :is_published,
             :template_data,
             :inserted_at,
             :updated_at
           ]}
  schema "components" do
    field(:name, :string)
    field(:description, :string)
    field(:category, :string)
    field(:is_published, :boolean, default: false)
    field(:template_data, :string)

    belongs_to(:canvas, Canvas)
    belongs_to(:creator, User, foreign_key: :created_by)

    timestamps(type: :utc_datetime)
  end

  @doc """
  Changeset for creating or updating a component.

  ## Required fields
    * `:name` - Component name
    * `:canvas_id` - ID of the canvas this component belongs to

  ## Optional fields
    * `:description` - Component description
    * `:category` - Component category (e.g., "button", "card", "form")
    * `:created_by` - User ID of the component creator
    * `:is_published` - Whether the component is published for reuse
    * `:template_data` - JSON string containing the component's template data

  ## Validations
    * Name must be present and at least 1 character
    * Canvas ID must be present
    * Category must be one of the allowed categories when present
  """
  def changeset(component, attrs) do
    component
    |> cast(attrs, [
      :name,
      :description,
      :category,
      :canvas_id,
      :created_by,
      :is_published,
      :template_data
    ])
    |> validate_required([:name, :canvas_id])
    |> validate_length(:name, min: 1, max: 255)
    |> validate_inclusion(:category, [
      "button",
      "card",
      "form",
      "navigation",
      "layout",
      "icon",
      "custom"
    ])
    |> foreign_key_constraint(:canvas_id, name: "components_canvas_id_fkey")
    |> foreign_key_constraint(:created_by, name: "components_created_by_fkey")
  end
end
</file>

<file path="lib/collab_canvas/styles/style.ex">
defmodule CollabCanvas.Styles.Style do
  @moduledoc """
  Style schema for the CollabCanvas application.

  Represents a reusable design style (color, text, effect) that can be applied
  to multiple objects on a canvas. Styles support design token export and
  real-time synchronization across collaborators.

  ## Style Types

  - `color` - Color definitions with RGB/RGBA values
  - `text` - Typography styles (font, size, weight, line-height)
  - `effect` - Visual effects (shadow, blur, etc.)

  ## Categories

  Categories help organize styles within their type:
  - Color: primary, secondary, accent, neutral, etc.
  - Text: heading, body, caption, etc.
  - Effect: shadow, blur, etc.
  """

  use Ecto.Schema
  import Ecto.Changeset

  alias CollabCanvas.Canvases.Canvas
  alias CollabCanvas.Accounts.User

  @valid_types ~w(color text effect)
  @valid_color_categories ~w(primary secondary accent neutral)
  @valid_text_categories ~w(heading body caption)
  @valid_effect_categories ~w(shadow blur)

  schema "styles" do
    field :name, :string
    field :type, :string
    field :category, :string
    field :definition, :string

    belongs_to :canvas, Canvas
    belongs_to :creator, User, foreign_key: :created_by

    timestamps(type: :utc_datetime)
  end

  @doc """
  Changeset for creating or updating a style.

  ## Required fields
    * `:name` - Style name (e.g., "Primary Blue", "Heading 1")
    * `:type` - Style type (color, text, effect)
    * `:definition` - JSON string containing style properties
    * `:canvas_id` - ID of the canvas this style belongs to

  ## Optional fields
    * `:category` - Style category for organization
    * `:created_by` - User ID who created the style

  ## Validations
    * Name must be present and between 1-255 characters
    * Type must be one of: color, text, effect
    * Definition must be valid JSON
    * Category must be valid for the given type
  """
  def changeset(style, attrs) do
    # Pre-process definition field to handle maps
    attrs = normalize_definition(attrs)

    style
    |> cast(attrs, [:name, :type, :category, :definition, :canvas_id, :created_by])
    |> validate_required([:name, :type, :definition, :canvas_id])
    |> validate_length(:name, min: 1, max: 255)
    |> validate_inclusion(:type, @valid_types)
    |> validate_json_definition()
    |> validate_category()
    |> foreign_key_constraint(:canvas_id, name: "styles_canvas_id_fkey")
    |> foreign_key_constraint(:created_by, name: "styles_created_by_fkey")
    |> unique_constraint([:name, :canvas_id], name: "styles_name_canvas_id_index")
  end

  # Normalize definition field: convert maps to JSON strings
  defp normalize_definition(attrs) when is_map(attrs) do
    cond do
      Map.has_key?(attrs, :definition) ->
        normalize_definition_key(attrs, :definition)

      Map.has_key?(attrs, "definition") ->
        normalize_definition_key(attrs, "definition")

      true ->
        attrs
    end
  end

  defp normalize_definition(attrs), do: attrs

  defp normalize_definition_key(attrs, key) do
    case Map.get(attrs, key) do
      definition when is_map(definition) ->
        case Jason.encode(definition) do
          {:ok, json} ->
            Map.put(attrs, key, json)

          {:error, _} ->
            # Leave as-is, will be caught by validation
            attrs
        end

      definition when is_binary(definition) ->
        # Already a string, keep it as-is (will be validated later)
        attrs

      _ ->
        attrs
    end
  end

  @doc """
  Validates that the definition field contains valid JSON.
  """
  defp validate_json_definition(changeset) do
    case get_change(changeset, :definition) do
      nil ->
        changeset

      definition when is_binary(definition) ->
        case Jason.decode(definition) do
          {:ok, _} ->
            changeset

          {:error, _} ->
            add_error(changeset, :definition, "must be valid JSON")
        end

      _ ->
        add_error(changeset, :definition, "must be a JSON string")
    end
  end

  @doc """
  Validates that the category is appropriate for the style type.
  """
  defp validate_category(changeset) do
    type = get_field(changeset, :type)
    category = get_change(changeset, :category)

    case {type, category} do
      {_, nil} ->
        # Category is optional
        changeset

      {"color", category} ->
        validate_inclusion(changeset, :category, @valid_color_categories)

      {"text", category} ->
        validate_inclusion(changeset, :category, @valid_text_categories)

      {"effect", category} ->
        validate_inclusion(changeset, :category, @valid_effect_categories)

      _ ->
        changeset
    end
  end

  @doc """
  Decodes the JSON definition into a map.
  Returns the parsed map or an empty map if parsing fails.
  """
  def decode_definition(%__MODULE__{definition: definition}) when is_binary(definition) do
    case Jason.decode(definition) do
      {:ok, parsed} -> parsed
      {:error, _} -> %{}
    end
  end

  def decode_definition(_), do: %{}
end
</file>

<file path="lib/collab_canvas/accounts.ex">
defmodule CollabCanvas.Accounts do
  @moduledoc """
  The Accounts context for managing user account operations in CollabCanvas.

  This module provides a comprehensive API for user account management, including:

  ## User Account Management
  - Creating, reading, updating, and deleting user accounts
  - Listing all users in the system
  - Tracking user metadata such as name, email, and avatar

  ## User Authentication and Retrieval
  - Retrieving users by ID or email address
  - Both soft retrieval (returns `nil` if not found) and strict retrieval (raises exception)
  - Updating last login timestamps for tracking user activity

  ## OAuth Provider Integration (Auth0)
  - Seamless integration with Auth0 OAuth authentication
  - Finding or creating users based on OAuth provider data
  - Support for multiple OAuth providers (Google, Auth0, etc.)
  - Mapping provider-specific fields (sub, picture) to user attributes
  - Automatic user creation on first login via OAuth
  - Provider-specific identifiers for reliable user matching

  ## Database Operations for Users
  - All operations are backed by PostgreSQL via Ecto
  - Uses changesets for data validation and casting
  - Supports transactional operations through Ecto.Repo
  - Handles both successful operations (`{:ok, user}`) and errors (`{:error, changeset}`)

  ## Usage Examples

  Basic user operations:

      # Create a new user
      {:ok, user} = Accounts.create_user(%{
        email: "user@example.com",
        name: "John Doe"
      })

      # Retrieve by ID or email
      user = Accounts.get_user(123)
      user = Accounts.get_user("user@example.com")

      # Update user information
      {:ok, updated_user} = Accounts.update_user(user, %{name: "Jane Doe"})

  OAuth authentication flow:

      # Find or create user from Auth0 data
      {:ok, user} = Accounts.find_or_create_user(%{
        email: "oauth_user@example.com",
        name: "OAuth User",
        picture: "https://example.com/avatar.jpg",
        provider: "google",
        sub: "google-oauth2|123456789"
      })
  """

  import Ecto.Query, warn: false
  alias CollabCanvas.Repo
  alias CollabCanvas.Accounts.User

  @doc """
  Returns the list of users.

  ## Examples

      iex> list_users()
      [%User{}, ...]

  """
  def list_users do
    Repo.all(User)
  end

  @doc """
  Gets a single user by ID or email.

  Returns `nil` if the User does not exist.

  ## Examples

      iex> get_user(123)
      %User{}

      iex> get_user("user@example.com")
      %User{}

      iex> get_user(456)
      nil

  """
  def get_user(id) when is_integer(id) do
    Repo.get(User, id)
  end

  def get_user(email) when is_binary(email) do
    Repo.get_by(User, email: email)
  end

  @doc """
  Gets a single user by ID or email, raises if not found.

  ## Examples

      iex> get_user!(123)
      %User{}

      iex> get_user!(456)
      ** (Ecto.NoResultsError)

  """
  def get_user!(id) when is_integer(id) do
    Repo.get!(User, id)
  end

  def get_user!(email) when is_binary(email) do
    Repo.get_by!(User, email: email)
  end

  @doc """
  Creates a user.

  ## Examples

      iex> create_user(%{email: "user@example.com", name: "John Doe"})
      {:ok, %User{}}

      iex> create_user(%{email: "invalid"})
      {:error, %Ecto.Changeset{}}

  """
  def create_user(attrs \\ %{}) do
    %User{}
    |> User.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Updates a user.

  ## Examples

      iex> update_user(user, %{name: "Jane Doe"})
      {:ok, %User{}}

      iex> update_user(user, %{email: nil})
      {:error, %Ecto.Changeset{}}

  """
  def update_user(%User{} = user, attrs) do
    user
    |> User.changeset(attrs)
    |> Repo.update()
  end

  @doc """
  Deletes a user.

  ## Examples

      iex> delete_user(user)
      {:ok, %User{}}

      iex> delete_user(user)
      {:error, %Ecto.Changeset{}}

  """
  def delete_user(%User{} = user) do
    Repo.delete(user)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking user changes.

  ## Examples

      iex> change_user(user)
      %Ecto.Changeset{data: %User{}}

  """
  def change_user(%User{} = user, attrs \\ %{}) do
    User.changeset(user, attrs)
  end

  @doc """
  Finds or creates a user based on Auth0 provider data.

  This function is used during OAuth authentication to either find an existing
  user or create a new one based on the provider information.

  ## Parameters

    * `auth_data` - Map containing user data from Auth0 with keys:
      * `:email` - User's email address (required)
      * `:name` - User's display name (optional)
      * `:avatar` or `:picture` - User's avatar URL (optional)
      * `:provider` - OAuth provider name (e.g., "auth0", "google")
      * `:provider_uid` or `:sub` - Unique identifier from the provider

  ## Examples

      iex> find_or_create_user(%{
      ...>   email: "user@example.com",
      ...>   name: "John Doe",
      ...>   picture: "https://example.com/avatar.jpg",
      ...>   provider: "google",
      ...>   sub: "google-oauth2|123456"
      ...> })
      {:ok, %User{}}

  """
  def find_or_create_user(auth_data) do
    # Normalize Auth0 data structure
    provider = Map.get(auth_data, :provider, "auth0")
    provider_uid = Map.get(auth_data, :provider_uid) || Map.get(auth_data, :sub)
    email = Map.get(auth_data, :email)
    name = Map.get(auth_data, :name)
    avatar = Map.get(auth_data, :avatar) || Map.get(auth_data, :picture)

    # Try to find existing user by provider_uid first (more reliable)
    user = if provider_uid do
      Repo.get_by(User, provider: provider, provider_uid: provider_uid)
    else
      nil
    end

    # Fall back to email lookup if provider_uid not found
    user = user || Repo.get_by(User, email: email)

    case user do
      nil ->
        # Create new user
        create_user(%{
          email: email,
          name: name,
          avatar: avatar,
          provider: provider,
          provider_uid: provider_uid,
          last_login: DateTime.utc_now()
        })

      existing_user ->
        # Update last login for existing user
        update_last_login(existing_user)
    end
  end

  @doc """
  Updates the last_login timestamp for a user to the current UTC time.

  This function is typically called during authentication to track when a user
  last accessed the system. It accepts either a User struct or a user ID.

  ## Parameters

    * `user` - A `%User{}` struct to update
    * `user_id` - An integer ID of the user to update

  ## Returns

    * `{:ok, %User{}}` - Successfully updated user with new last_login timestamp
    * `{:error, %Ecto.Changeset{}}` - Validation or database error
    * `{:error, :not_found}` - User with the given ID does not exist

  ## Examples

      # Update using User struct
      iex> update_last_login(user)
      {:ok, %User{last_login: ~U[2024-01-15 10:30:00Z]}}

      # Update using user ID
      iex> update_last_login(123)
      {:ok, %User{last_login: ~U[2024-01-15 10:30:00Z]}}

      # Non-existent user
      iex> update_last_login(999)
      {:error, :not_found}

  """
  def update_last_login(%User{} = user) do
    user
    |> User.login_changeset(%{last_login: DateTime.utc_now()})
    |> Repo.update()
  end

  def update_last_login(user_id) when is_integer(user_id) do
    case get_user(user_id) do
      nil -> {:error, :not_found}
      user -> update_last_login(user)
    end
  end
end
</file>

<file path="lib/collab_canvas/application.ex">
defmodule CollabCanvas.Application do
  @moduledoc """
  The CollabCanvas OTP Application.

  This module defines the root of the CollabCanvas application supervision tree and manages
  the application lifecycle. It implements the `Application` behavior and is responsible for
  starting all core services required for the collaborative canvas platform.

  ## Supervision Tree

  The application uses a `:one_for_one` supervision strategy, meaning if a child process
  crashes, only that specific process is restarted. The supervision tree includes the following
  child processes in order:

  1. **Telemetry** (`CollabCanvasWeb.Telemetry`) - Metrics and monitoring system for tracking
     application performance and behavior.

  2. **Repo** (`CollabCanvas.Repo`) - Ecto repository providing database access and query
     capabilities for persistent storage.

  3. **Migrator** (`Ecto.Migrator`) - Handles automatic database migrations on application
     startup. Skips migrations in development mode (see `skip_migrations?/0`).

  4. **DNS Cluster** (`DNSCluster`) - Manages node discovery and clustering in distributed
     deployments. Configured via `:dns_cluster_query` application environment.

  5. **PubSub** (`Phoenix.PubSub`) - Publisher-subscriber system enabling real-time message
     broadcasting across the application and distributed nodes.

  6. **Presence** (`CollabCanvasWeb.Presence`) - Phoenix Presence tracking system for monitoring
     online users, cursor positions, and collaborative state across connected clients.

  7. **Endpoint** (`CollabCanvasWeb.Endpoint`) - Phoenix HTTP/WebSocket endpoint serving web
     requests and managing real-time connections. Started last to ensure all dependencies are
     available before accepting traffic.

  ## Application Startup

  The application starts automatically when the Elixir runtime launches. The `start/2` callback
  initializes the supervision tree and returns `{:ok, pid}` on success. If any critical child
  process fails to start, the entire application startup fails.

  ## Configuration

  Key application environment variables:
  - `:ecto_repos` - List of Ecto repositories to manage
  - `:dns_cluster_query` - DNS query for node discovery in clustered deployments
  - `RELEASE_NAME` - Environment variable controlling migration behavior

  See the [OTP Application documentation](https://hexdocs.pm/elixir/Application.html) for more
  information on OTP Applications.
  """

  use Application

  @impl true
  @doc """
  Starts the CollabCanvas application and its supervision tree.

  This callback is invoked when the application is started. It creates a supervisor with all
  required child processes and returns the supervisor pid.

  ## Parameters

  - `type` - The application start type (`:normal`, `:takeover`, or `:failover`). Typically
    `:normal` for standard application startup.
  - `args` - Application start arguments. Not currently used by CollabCanvas.

  ## Returns

  - `{:ok, pid}` - Successfully started the supervision tree
  - `{:error, reason}` - Failed to start the application

  ## Examples

      # Called automatically by the Elixir runtime:
      {:ok, pid} = CollabCanvas.Application.start(:normal, [])

  """
  def start(_type, _args) do
    children = [
      CollabCanvasWeb.Telemetry,
      CollabCanvas.Repo,
      {Ecto.Migrator,
       repos: Application.fetch_env!(:collab_canvas, :ecto_repos), skip: skip_migrations?()},
      {DNSCluster, query: Application.get_env(:collab_canvas, :dns_cluster_query) || :ignore},
      {Phoenix.PubSub, name: CollabCanvas.PubSub},
      # Start the Presence system for tracking online users and cursors
      CollabCanvasWeb.Presence,
      # Start a worker by calling: CollabCanvas.Worker.start_link(arg)
      # {CollabCanvas.Worker, arg},
      # Start to serve requests, typically the last entry
      CollabCanvasWeb.Endpoint
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: CollabCanvas.Supervisor]
    Supervisor.start_link(children, opts)
  end

  # Tell Phoenix to update the endpoint configuration
  # whenever the application is updated.
  @impl true
  def config_change(changed, _new, removed) do
    CollabCanvasWeb.Endpoint.config_change(changed, removed)
    :ok
  end

  defp skip_migrations?() do
    # By default, sqlite migrations are run when using a release
    System.get_env("RELEASE_NAME") == nil
  end
end
</file>

<file path="lib/collab_canvas/canvases.ex">
defmodule CollabCanvas.Canvases do
  @moduledoc """
  The Canvases context.

  This module provides the business logic layer for managing canvases and objects
  in the CollabCanvas application. It serves as the primary interface between
  Phoenix controllers/LiveViews and the database layer.

  ## Canvas and Object Management

  A canvas represents a collaborative drawing workspace that belongs to a user.
  Each canvas can contain multiple objects (shapes like rectangles, circles, etc.)
  that can be manipulated by multiple users in real-time.

  ### Canvas Operations
  - Create canvases for users
  - List canvases (per-user or all canvases for collaboration)
  - Retrieve single canvases with optional preloading
  - Delete canvases (cascades to all objects)

  ### Object Operations
  - Create objects on canvases
  - Update object properties (position, data, etc.)
  - Delete individual objects or all objects on a canvas
  - List objects for a specific canvas

  ## Database Operations (CRUD)

  All functions in this context follow standard CRUD patterns:
  - **Create**: Returns `{:ok, struct}` or `{:error, changeset}`
  - **Read**: Returns struct or `nil` for single records, list for multiple
  - **Update**: Returns `{:ok, struct}` or `{:error, changeset}` or `{:error, :not_found}`
  - **Delete**: Returns `{:ok, struct}` or `{:error, :not_found}`

  ## Relationship Between Canvases and Objects

  Canvases and objects have a parent-child relationship:
  - A canvas has many objects (one-to-many)
  - An object belongs to exactly one canvas
  - When a canvas is deleted, all its objects are automatically deleted
    via `on_delete: :delete_all` in the schema definition

  Database integrity:
  - Canvas deletion cascades to objects
  - Objects cannot exist without a valid canvas (foreign key constraint)
  - User deletion cascades to canvases (and transitively to objects)

  ## Preloading Strategies

  This context provides flexible preloading for associations:

  ### Canvas Preloading
  - `get_canvas/1`: No preloading (lightweight)
  - `get_canvas_with_preloads/2`: Selective preloading
    - Default: preloads both `:user` and `:objects`
    - Custom: pass list of associations to preload (e.g., `[:objects]`)
  - `list_all_canvases/0`: Automatically preloads `:user`

  ### Performance Considerations
  - Use `get_canvas/1` when you only need canvas data
  - Use `get_canvas_with_preloads/2` when you need related data
  - Specify only needed associations to minimize database queries
  - Objects are ordered by insertion time, canvases by update time

  ## Usage Examples

      # Create a canvas and add objects
      {:ok, canvas} = create_canvas(user_id, "My Drawing")
      {:ok, rect} = create_object(canvas.id, "rectangle", %{
        position: %{x: 10, y: 20},
        data: %{width: 100, height: 50}
      })

      # Retrieve canvas with all objects
      canvas = get_canvas_with_preloads(canvas.id)
      # Returns: %Canvas{objects: [...], user: %User{}}

      # Update object position during drag
      {:ok, updated} = update_object(rect.id, %{
        position: %{x: 50, y: 60}
      })

      # Clean up
      delete_canvas(canvas.id)  # Also deletes all objects
  """

  import Ecto.Query, warn: false
  alias CollabCanvas.Repo

  alias CollabCanvas.Canvases.Canvas
  alias CollabCanvas.Canvases.Object
  alias CollabCanvas.Canvases.CanvasUserViewport

  @doc """
  Creates a new canvas for a user.

  ## Parameters
    * `user_id` - The ID of the user creating the canvas
    * `name` - The name of the canvas

  ## Returns
    * `{:ok, canvas}` on success
    * `{:error, changeset}` on validation failure

  ## Examples

      iex> create_canvas(1, "My Canvas")
      {:ok, %Canvas{}}

      iex> create_canvas(1, "")
      {:error, %Ecto.Changeset{}}

  """
  def create_canvas(user_id, name) do
    %Canvas{}
    |> Canvas.changeset(%{user_id: user_id, name: name})
    |> Repo.insert()
  end

  @doc """
  Gets a single canvas by ID.

  ## Parameters
    * `id` - The canvas ID

  ## Returns
    * The canvas struct if found
    * `nil` if not found

  ## Examples

      iex> get_canvas(123)
      %Canvas{}

      iex> get_canvas(456)
      nil

  """
  def get_canvas(id) do
    Repo.get(Canvas, id)
  end

  @doc """
  Gets a single canvas by ID and preloads associations.

  ## Parameters
    * `id` - The canvas ID
    * `preloads` - List of associations to preload (default: [:user, :objects])

  ## Returns
    * The canvas struct with preloaded associations if found
    * `nil` if not found

  ## Examples

      iex> get_canvas_with_preloads(123)
      %Canvas{user: %User{}, objects: [%Object{}]}

      iex> get_canvas_with_preloads(123, [:objects])
      %Canvas{objects: [%Object{}]}

  """
  def get_canvas_with_preloads(id, preloads \\ [:user, :objects]) do
    case get_canvas(id) do
      nil -> nil
      canvas -> Repo.preload(canvas, preloads)
    end
  end

  @doc """
  Lists all canvases for a specific user.

  ## Parameters
    * `user_id` - The user ID

  ## Returns
    * List of canvas structs

  ## Examples

      iex> list_user_canvases(1)
      [%Canvas{}, %Canvas{}]

      iex> list_user_canvases(999)
      []

  """
  def list_user_canvases(user_id) do
    Canvas
    |> where([c], c.user_id == ^user_id)
    |> order_by([c], desc: c.updated_at)
    |> Repo.all()
  end

  @doc """
  Lists all canvases (for collaborative access across all users).

  ## Returns
    * List of all canvas structs with user preloaded

  ## Examples

      iex> list_all_canvases()
      [%Canvas{}, %Canvas{}]

  """
  def list_all_canvases do
    Canvas
    |> order_by([c], desc: c.updated_at)
    |> preload(:user)
    |> Repo.all()
  end

  @doc """
  Creates a new object on a canvas.

  ## Parameters
    * `canvas_id` - The ID of the canvas
    * `type` - The object type (e.g., "rectangle", "circle")
    * `attrs` - Additional attributes (data, position)

  ## Returns
    * `{:ok, object}` on success
    * `{:error, changeset}` on validation failure

  ## Examples

      iex> create_object(1, "rectangle", %{position: %{x: 10, y: 20}})
      {:ok, %Object{}}

      iex> create_object(1, "invalid_type", %{})
      {:error, %Ecto.Changeset{}}

  """
  def create_object(canvas_id, type, attrs \\ %{}) do
    attrs =
      attrs
      |> Map.put(:canvas_id, canvas_id)
      |> Map.put(:type, type)

    %Object{}
    |> Object.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Updates an existing object.

  ## Parameters
    * `id` - The object ID
    * `attrs` - Map of attributes to update

  ## Returns
    * `{:ok, object}` on success
    * `{:error, changeset}` on validation failure
    * `{:error, :not_found}` if object doesn't exist

  ## Examples

      iex> update_object(1, %{position: %{x: 100, y: 200}})
      {:ok, %Object{}}

      iex> update_object(999, %{position: %{x: 100, y: 200}})
      {:error, :not_found}

  """
  def update_object(id, attrs) do
    case Repo.get(Object, id) do
      nil ->
        {:error, :not_found}

      object ->
        object
        |> Object.changeset(attrs)
        |> Repo.update()
    end
  end

  @doc """
  Deletes an object.

  ## Parameters
    * `id` - The object ID

  ## Returns
    * `{:ok, object}` on success
    * `{:error, :not_found}` if object doesn't exist

  ## Examples

      iex> delete_object(1)
      {:ok, %Object{}}

      iex> delete_object(999)
      {:error, :not_found}

  """
  def delete_object(id) do
    case Repo.get(Object, id) do
      nil ->
        {:error, :not_found}

      object ->
        Repo.delete(object)
    end
  end

  @doc """
  Lists all objects for a specific canvas.

  ## Parameters
    * `canvas_id` - The canvas ID

  ## Returns
    * List of object structs

  ## Examples

      iex> list_objects(1)
      [%Object{}, %Object{}]

      iex> list_objects(999)
      []

  """
  def list_objects(canvas_id) do
    Object
    |> where([o], o.canvas_id == ^canvas_id)
    |> order_by([o], asc: o.inserted_at)
    |> Repo.all()
  end

  @doc """
  Gets a single object by ID.

  ## Parameters
    * `id` - The object ID

  ## Returns
    * The object struct if found
    * `nil` if not found

  ## Examples

      iex> get_object(1)
      %Object{}

      iex> get_object(999)
      nil

  """
  def get_object(id) do
    Repo.get(Object, id)
  end

  @doc """
  Locks an object for editing by a specific user.

  ## Parameters
    * `id` - The object ID
    * `user_id` - The user ID locking the object

  ## Returns
    * `{:ok, object}` on success
    * `{:error, :not_found}` if object doesn't exist
    * `{:error, :already_locked}` if object is already locked by another user

  ## Examples

      iex> lock_object(1, "user_123")
      {:ok, %Object{}}

      iex> lock_object(1, "user_456")  # Already locked by user_123
      {:error, :already_locked}

  """
  def lock_object(id, user_id) do
    case Repo.get(Object, id) do
      nil ->
        {:error, :not_found}

      object ->
        cond do
          object.locked_by == user_id ->
            # Already locked by this user, return success
            {:ok, object}

          object.locked_by != nil and object.locked_by != user_id ->
            # Locked by another user
            {:error, :already_locked}

          true ->
            # Not locked or lock expired, acquire lock
            object
            |> Object.changeset(%{locked_by: user_id})
            |> Repo.update()
        end
    end
  end

  @doc """
  Unlocks an object, allowing other users to edit it.

  ## Parameters
    * `id` - The object ID
    * `user_id` - The user ID unlocking the object (optional, for validation)

  ## Returns
    * `{:ok, object}` on success
    * `{:error, :not_found}` if object doesn't exist
    * `{:error, :not_locked_by_user}` if object is locked by another user

  ## Examples

      iex> unlock_object(1, "user_123")
      {:ok, %Object{}}

      iex> unlock_object(1, "user_456")  # Locked by user_123
      {:error, :not_locked_by_user}

  """
  def unlock_object(id, user_id \\ nil) do
    case Repo.get(Object, id) do
      nil ->
        {:error, :not_found}

      object ->
        cond do
          user_id != nil and object.locked_by != user_id ->
            # Trying to unlock object locked by another user
            {:error, :not_locked_by_user}

          true ->
            # Unlock the object
            object
            |> Object.changeset(%{locked_by: nil})
            |> Repo.update()
        end
    end
  end

  @doc """
  Checks if an object is locked and by whom.

  ## Parameters
    * `id` - The object ID

  ## Returns
    * `{:locked, user_id}` if object is locked
    * `{:unlocked, object}` if object is not locked
    * `{:error, :not_found}` if object doesn't exist

  ## Examples

      iex> check_lock(1)
      {:locked, "user_123"}

      iex> check_lock(2)
      {:unlocked, %Object{}}

  """
  def check_lock(id) do
    case Repo.get(Object, id) do
      nil ->
        {:error, :not_found}

      object ->
        if object.locked_by do
          {:locked, object.locked_by}
        else
          {:unlocked, object}
        end
    end
  end

  @doc """
  Deletes all objects from a canvas.

  ## Parameters
    * `canvas_id` - The canvas ID

  ## Returns
    * `{count, nil}` where count is the number of deleted objects

  ## Examples

      iex> delete_canvas_objects(1)
      {5, nil}

  """
  def delete_canvas_objects(canvas_id) do
    Object
    |> where([o], o.canvas_id == ^canvas_id)
    |> Repo.delete_all()
  end

  @doc """
  Deletes a canvas and all its objects.

  ## Parameters
    * `id` - The canvas ID

  ## Returns
    * `{:ok, canvas}` on success
    * `{:error, :not_found}` if canvas doesn't exist

  ## Examples

      iex> delete_canvas(1)
      {:ok, %Canvas{}}

      iex> delete_canvas(999)
      {:error, :not_found}

  """
  def delete_canvas(id) do
    case Repo.get(Canvas, id) do
      nil ->
        {:error, :not_found}

      canvas ->
        # Objects will be deleted automatically due to on_delete: :delete_all
        Repo.delete(canvas)
    end
  end

  @doc """
  Gets a user's saved viewport position for a specific canvas.

  ## Parameters
    * `user_id` - The user ID
    * `canvas_id` - The canvas ID

  ## Returns
    * The viewport struct if found
    * `nil` if not found

  ## Examples

      iex> get_viewport(1, 2)
      %CanvasUserViewport{viewport_x: 100.0, viewport_y: 50.0, zoom: 1.5}

      iex> get_viewport(999, 2)
      nil

  """
  def get_viewport(user_id, canvas_id) do
    CanvasUserViewport
    |> where([v], v.user_id == ^user_id and v.canvas_id == ^canvas_id)
    |> Repo.one()
  end

  @doc """
  Saves or updates a user's viewport position for a specific canvas.

  ## Parameters
    * `user_id` - The user ID
    * `canvas_id` - The canvas ID
    * `attrs` - Map with viewport_x, viewport_y, and zoom

  ## Returns
    * `{:ok, viewport}` on success
    * `{:error, changeset}` on validation failure

  ## Examples

      iex> save_viewport(1, 2, %{viewport_x: 100.0, viewport_y: 50.0, zoom: 1.5})
      {:ok, %CanvasUserViewport{}}

  """
  def save_viewport(user_id, canvas_id, attrs) do
    attrs = Map.merge(attrs, %{user_id: user_id, canvas_id: canvas_id})

    case get_viewport(user_id, canvas_id) do
      nil ->
        %CanvasUserViewport{}
        |> CanvasUserViewport.changeset(attrs)
        |> Repo.insert()

      viewport ->
        viewport
        |> CanvasUserViewport.changeset(attrs)
        |> Repo.update()
    end
  end
end
</file>

<file path="lib/collab_canvas/color_palettes.ex">
defmodule CollabCanvas.ColorPalettes do
  @moduledoc """
  The ColorPalettes context.

  Manages user color preferences including recent colors, favorite colors, and default colors.
  """

  import Ecto.Query, warn: false
  alias CollabCanvas.Repo
  alias CollabCanvas.ColorPalettes.UserColorPreference

  @doc """
  Gets user color preferences for a specific user.
  Creates default preferences if none exist.

  ## Parameters
    * `user_id` - The ID of the user

  ## Returns
    * `%UserColorPreference{}` - The user's color preferences

  ## Examples

      iex> get_or_create_preferences(1)
      %UserColorPreference{user_id: 1, recent_colors: "[]", ...}

  """
  def get_or_create_preferences(user_id) do
    case Repo.get_by(UserColorPreference, user_id: user_id) do
      nil ->
        # Create default preferences
        {:ok, preferences} = create_preferences(%{user_id: user_id})
        preferences

      preferences ->
        preferences
    end
  end

  @doc """
  Gets user color preferences by user ID.

  ## Parameters
    * `user_id` - The ID of the user

  ## Returns
    * `%UserColorPreference{}` if found
    * `nil` if not found

  ## Examples

      iex> get_preferences(1)
      %UserColorPreference{}

      iex> get_preferences(999)
      nil

  """
  def get_preferences(user_id) do
    Repo.get_by(UserColorPreference, user_id: user_id)
  end

  @doc """
  Creates user color preferences.

  ## Parameters
    * `attrs` - Map of attributes including :user_id

  ## Returns
    * `{:ok, %UserColorPreference{}}` on success
    * `{:error, %Ecto.Changeset{}}` on validation failure

  ## Examples

      iex> create_preferences(%{user_id: 1})
      {:ok, %UserColorPreference{}}

      iex> create_preferences(%{})
      {:error, %Ecto.Changeset{}}

  """
  def create_preferences(attrs \\ %{}) do
    %UserColorPreference{}
    |> UserColorPreference.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Updates user color preferences.

  ## Parameters
    * `preference` - The preference struct to update
    * `attrs` - Map of attributes to update

  ## Returns
    * `{:ok, %UserColorPreference{}}` on success
    * `{:error, %Ecto.Changeset{}}` on validation failure

  ## Examples

      iex> update_preferences(preference, %{default_color: "#FF0000"})
      {:ok, %UserColorPreference{}}

  """
  def update_preferences(%UserColorPreference{} = preference, attrs) do
    preference
    |> UserColorPreference.changeset(attrs)
    |> Repo.update()
  end

  @doc """
  Adds a color to the user's recent colors list.
  Automatically manages the LIFO queue (max 10 colors).

  ## Parameters
    * `user_id` - The ID of the user
    * `color` - Hex color string (e.g., "#FF0000")

  ## Returns
    * `{:ok, %UserColorPreference{}}` on success
    * `{:error, reason}` on failure

  ## Examples

      iex> add_recent_color(1, "#FF0000")
      {:ok, %UserColorPreference{}}

  """
  def add_recent_color(user_id, color) when is_binary(color) do
    preferences = get_or_create_preferences(user_id)
    updated_recent_colors = UserColorPreference.add_to_recent(preferences.recent_colors, color)

    update_preferences(preferences, %{recent_colors: updated_recent_colors})
  end

  @doc """
  Adds a color to the user's favorite colors list.

  ## Parameters
    * `user_id` - The ID of the user
    * `color` - Hex color string (e.g., "#FF0000")

  ## Returns
    * `{:ok, %UserColorPreference{}}` on success
    * `{:error, reason}` on failure

  ## Examples

      iex> add_favorite_color(1, "#FF0000")
      {:ok, %UserColorPreference{}}

  """
  def add_favorite_color(user_id, color) when is_binary(color) do
    preferences = get_or_create_preferences(user_id)

    favorite_colors =
      case Jason.decode(preferences.favorite_colors) do
        {:ok, colors} when is_list(colors) -> colors
        _ -> []
      end

    # Don't add duplicates
    if color in favorite_colors do
      {:ok, preferences}
    else
      updated_favorites = Jason.encode!([color | favorite_colors])
      update_preferences(preferences, %{favorite_colors: updated_favorites})
    end
  end

  @doc """
  Removes a color from the user's favorite colors list.

  ## Parameters
    * `user_id` - The ID of the user
    * `color` - Hex color string to remove

  ## Returns
    * `{:ok, %UserColorPreference{}}` on success
    * `{:error, reason}` on failure

  ## Examples

      iex> remove_favorite_color(1, "#FF0000")
      {:ok, %UserColorPreference{}}

  """
  def remove_favorite_color(user_id, color) when is_binary(color) do
    preferences = get_or_create_preferences(user_id)

    favorite_colors =
      case Jason.decode(preferences.favorite_colors) do
        {:ok, colors} when is_list(colors) -> colors
        _ -> []
      end

    updated_favorites =
      favorite_colors
      |> Enum.reject(&(&1 == color))
      |> Jason.encode!()

    update_preferences(preferences, %{favorite_colors: updated_favorites})
  end

  @doc """
  Sets the user's default color for new objects.

  ## Parameters
    * `user_id` - The ID of the user
    * `color` - Hex color string

  ## Returns
    * `{:ok, %UserColorPreference{}}` on success
    * `{:error, reason}` on failure

  ## Examples

      iex> set_default_color(1, "#0000FF")
      {:ok, %UserColorPreference{}}

  """
  def set_default_color(user_id, color) when is_binary(color) do
    preferences = get_or_create_preferences(user_id)
    update_preferences(preferences, %{default_color: color})
  end

  @doc """
  Gets the user's recent colors as a list.

  ## Parameters
    * `user_id` - The ID of the user

  ## Returns
    * List of hex color strings

  ## Examples

      iex> get_recent_colors(1)
      ["#FF0000", "#00FF00", "#0000FF"]

  """
  def get_recent_colors(user_id) do
    preferences = get_or_create_preferences(user_id)
    UserColorPreference.decode_recent_colors(preferences)
  end

  @doc """
  Gets the user's favorite colors as a list.

  ## Parameters
    * `user_id` - The ID of the user

  ## Returns
    * List of hex color strings

  ## Examples

      iex> get_favorite_colors(1)
      ["#FF0000", "#00FF00"]

  """
  def get_favorite_colors(user_id) do
    preferences = get_or_create_preferences(user_id)
    UserColorPreference.decode_favorite_colors(preferences)
  end

  @doc """
  Gets the user's default color.

  ## Parameters
    * `user_id` - The ID of the user

  ## Returns
    * Hex color string

  ## Examples

      iex> get_default_color(1)
      "#000000"

  """
  def get_default_color(user_id) do
    preferences = get_or_create_preferences(user_id)
    preferences.default_color
  end
end
</file>

<file path="lib/collab_canvas/components.ex">
defmodule CollabCanvas.Components do
  @moduledoc """
  The Components context.

  This module provides the business logic layer for managing reusable components
  in the CollabCanvas application. It serves as the primary interface between
  Phoenix controllers/LiveViews and the database layer for component operations.

  ## Reusable Component System

  A component represents a reusable design element that can be instantiated
  multiple times across canvases. When a component is created, it stores a
  template of objects. When instantiated, it creates copies of those objects
  that remain linked to the main component.

  ### Component Operations
  - Create components from existing objects
  - Instantiate components to create linked copies
  - Update components and propagate changes to all instances
  - Manage component versioning and nested components

  ### Instance Management
  - Component instances are regular objects with `component_id` set
  - Main component objects have `is_main_component: true`
  - Instance overrides are stored in `instance_overrides` field
  - Updates to main component propagate to all instances

  ## Database Operations (CRUD)

  All functions in this context follow standard CRUD patterns:
  - **Create**: Returns `{:ok, struct}` or `{:error, changeset}`
  - **Read**: Returns struct or `nil` for single records, list for multiple
  - **Update**: Returns `{:ok, struct}` or `{:error, changeset}` or `{:error, :not_found}`
  - **Delete**: Returns `{:ok, struct}` or `{:error, :not_found}`

  ## Real-time Updates

  Component changes are broadcast via Phoenix.PubSub to enable real-time
  collaboration. Clients can subscribe to:
  - `component:updated` - When a component is updated
  - `component:instantiated` - When a component is instantiated
  - `component:deleted` - When a component is deleted

  ## Usage Examples

      # Create a component from existing objects
      {:ok, component} = create_component([obj1.id, obj2.id], "Button", "button",
        canvas_id: canvas.id,
        created_by: user.id,
        description: "Primary button component"
      )

      # Instantiate the component at a specific position
      {:ok, instances} = instantiate_component(component.id, %{x: 100, y: 200},
        canvas_id: target_canvas.id
      )

      # Update the component (propagates to all instances)
      {:ok, updated} = update_component(component.id, %{
        description: "Updated button style"
      })
  """

  import Ecto.Query, warn: false
  alias CollabCanvas.Repo

  alias CollabCanvas.Components.Component
  alias CollabCanvas.Canvases.Object
  alias CollabCanvas.Canvases

  require Logger

  @doc """
  Creates a new component from a list of objects.

  This function takes existing objects, marks them as the main component objects,
  and creates a component record that stores their configuration as a template.

  ## Parameters
    * `object_ids` - List of object IDs to include in the component
    * `name` - The name of the component
    * `category` - The category of the component (e.g., "button", "card")
    * `opts` - Additional options (keyword list):
      - `:canvas_id` - Canvas ID where the component is defined (required)
      - `:created_by` - User ID of the component creator
      - `:description` - Component description
      - `:is_published` - Whether to publish the component (default: false)

  ## Returns
    * `{:ok, component}` on success
    * `{:error, changeset}` on validation failure
    * `{:error, :objects_not_found}` if any object IDs are invalid

  ## Examples

      iex> create_component([1, 2], "Button", "button",
      ...>   canvas_id: 5, created_by: 10)
      {:ok, %Component{}}

      iex> create_component([], "Empty", "custom", canvas_id: 5)
      {:error, %Ecto.Changeset{}}
  """
  def create_component(object_ids, name, category, opts \\ []) do
    canvas_id = Keyword.fetch!(opts, :canvas_id)
    created_by = Keyword.get(opts, :created_by)
    description = Keyword.get(opts, :description)
    is_published = Keyword.get(opts, :is_published, false)

    # Validate that all objects exist and belong to the same canvas
    objects = Repo.all(from o in Object, where: o.id in ^object_ids)

    if length(objects) != length(object_ids) do
      {:error, :objects_not_found}
    else
      # Check all objects belong to the same canvas
      if Enum.all?(objects, &(&1.canvas_id == canvas_id)) do
        # Start a transaction to create component and update objects
        Ecto.Multi.new()
        |> Ecto.Multi.insert(:component, fn _ ->
          %Component{}
          |> Component.changeset(%{
            name: name,
            category: category,
            canvas_id: canvas_id,
            created_by: created_by,
            description: description,
            is_published: is_published,
            template_data: encode_template_data(objects)
          })
        end)
        |> Ecto.Multi.run(:mark_objects, fn _repo, %{component: component} ->
          # Mark all objects as main component objects
          updates =
            Enum.map(objects, fn obj ->
              case Canvases.update_object(obj.id, %{
                     component_id: component.id,
                     is_main_component: true
                   }) do
                {:ok, _updated} -> :ok
                error -> error
              end
            end)

          if Enum.all?(updates, &(&1 == :ok)) do
            {:ok, component}
          else
            {:error, :failed_to_mark_objects}
          end
        end)
        |> Repo.transaction()
        |> case do
          {:ok, %{component: component}} ->
            # Broadcast component creation
            broadcast_component_change(:created, component)
            {:ok, component}

          {:error, _step, changeset, _changes} ->
            {:error, changeset}
        end
      else
        {:error, :objects_must_belong_to_same_canvas}
      end
    end
  end

  @doc """
  Instantiates a component at a specific position.

  Creates copies of all objects in the component template, linked to the
  original component. The new instances will have the same relative positions
  and properties as the template objects, offset by the given position.

  ## Parameters
    * `component_id` - The component ID to instantiate
    * `position` - Map with `:x` and `:y` coordinates for the instance position
    * `opts` - Additional options (keyword list):
      - `:canvas_id` - Canvas ID where to instantiate (required)
      - `:overrides` - Map of property overrides for instances (optional)

  ## Returns
    * `{:ok, [objects]}` - List of created object instances on success
    * `{:error, :not_found}` if component doesn't exist
    * `{:error, reason}` on failure

  ## Examples

      iex> instantiate_component(1, %{x: 100, y: 200}, canvas_id: 5)
      {:ok, [%Object{}, %Object{}]}

      iex> instantiate_component(999, %{x: 0, y: 0}, canvas_id: 5)
      {:error, :not_found}
  """
  def instantiate_component(component_id, position, opts \\ []) do
    canvas_id = Keyword.fetch!(opts, :canvas_id)
    overrides = Keyword.get(opts, :overrides, %{})

    case get_component(component_id) do
      nil ->
        {:error, :not_found}

      component ->
        # Decode template data
        template_objects = decode_template_data(component.template_data)

        # Calculate offset based on the first object's position
        base_position = calculate_base_position(template_objects)
        offset_x = position.x - base_position.x
        offset_y = position.y - base_position.y

        # Create instances
        instances =
          Enum.map(template_objects, fn template_obj ->
            new_position = %{
              x: template_obj.position.x + offset_x,
              y: template_obj.position.y + offset_y
            }

            attrs = %{
              type: template_obj.type,
              data: template_obj.data,
              position: new_position,
              component_id: component_id,
              is_main_component: false,
              instance_overrides: Jason.encode!(overrides)
            }

            Canvases.create_object(canvas_id, template_obj.type, attrs)
          end)

        # Check if all instances were created successfully
        if Enum.all?(instances, &match?({:ok, _}, &1)) do
          created_objects = Enum.map(instances, fn {:ok, obj} -> obj end)

          # Broadcast instantiation
          broadcast_component_change(:instantiated, component, %{
            instances: created_objects,
            canvas_id: canvas_id
          })

          {:ok, created_objects}
        else
          # Find the first error
          error = Enum.find(instances, &match?({:error, _}, &1))
          error
        end
    end
  end

  @doc """
  Updates a component and optionally propagates changes to all instances.

  When a component is updated, the changes can be propagated to all its
  instances (objects with `component_id` set to this component and
  `is_main_component: false`).

  ## Parameters
    * `component_id` - The component ID to update
    * `changes` - Map of changes to apply
    * `opts` - Additional options (keyword list):
      - `:propagate` - Whether to propagate changes to instances (default: true)
      - `:skip_fields` - List of fields to skip during propagation

  ## Returns
    * `{:ok, component}` on success
    * `{:error, :not_found}` if component doesn't exist
    * `{:error, changeset}` on validation failure

  ## Examples

      iex> update_component(1, %{description: "Updated"})
      {:ok, %Component{}}

      iex> update_component(999, %{description: "Updated"})
      {:error, :not_found}
  """
  def update_component(component_id, changes, opts \\ []) do
    propagate = Keyword.get(opts, :propagate, true)
    skip_fields = Keyword.get(opts, :skip_fields, [])

    case get_component(component_id) do
      nil ->
        {:error, :not_found}

      component ->
        changeset = Component.changeset(component, changes)

        case Repo.update(changeset) do
          {:ok, updated_component} ->
            # Propagate changes to instances if requested
            if propagate do
              propagate_to_instances(component_id, changes, skip_fields)
            end

            # Broadcast update
            broadcast_component_change(:updated, updated_component)

            {:ok, updated_component}

          {:error, changeset} ->
            {:error, changeset}
        end
    end
  end

  @doc """
  Gets a single component by ID.

  ## Parameters
    * `id` - The component ID

  ## Returns
    * The component struct if found
    * `nil` if not found

  ## Examples

      iex> get_component(123)
      %Component{}

      iex> get_component(456)
      nil
  """
  def get_component(id) do
    Repo.get(Component, id)
  end

  @doc """
  Gets a component with its main objects preloaded.

  ## Parameters
    * `id` - The component ID

  ## Returns
    * The component with objects if found
    * `nil` if not found

  ## Examples

      iex> get_component_with_objects(123)
      %Component{main_objects: [%Object{}, %Object{}]}
  """
  def get_component_with_objects(id) do
    case get_component(id) do
      nil ->
        nil

      component ->
        main_objects =
          Object
          |> where([o], o.component_id == ^id and o.is_main_component == true)
          |> Repo.all()

        Map.put(component, :main_objects, main_objects)
    end
  end

  @doc """
  Lists all instances of a component.

  ## Parameters
    * `component_id` - The component ID

  ## Returns
    * List of object structs that are instances of this component

  ## Examples

      iex> list_component_instances(1)
      [%Object{}, %Object{}]
  """
  def list_component_instances(component_id) do
    Object
    |> where([o], o.component_id == ^component_id and o.is_main_component == false)
    |> Repo.all()
  end

  @doc """
  Lists all published components.

  ## Returns
    * List of published component structs

  ## Examples

      iex> list_published_components()
      [%Component{}, %Component{}]
  """
  def list_published_components do
    Component
    |> where([c], c.is_published == true)
    |> order_by([c], desc: c.updated_at)
    |> Repo.all()
  end

  @doc """
  Lists all components for a specific canvas.

  ## Parameters
    * `canvas_id` - The canvas ID

  ## Returns
    * List of component structs

  ## Examples

      iex> list_canvas_components(1)
      [%Component{}, %Component{}]
  """
  def list_canvas_components(canvas_id) do
    Component
    |> where([c], c.canvas_id == ^canvas_id)
    |> order_by([c], desc: c.updated_at)
    |> Repo.all()
  end

  @doc """
  Deletes a component and optionally its instances.

  ## Parameters
    * `id` - The component ID
    * `opts` - Options (keyword list):
      - `:delete_instances` - Whether to delete all instances (default: false)
      - `:unlink_instances` - Whether to unlink instances instead (default: true)

  ## Returns
    * `{:ok, component}` on success
    * `{:error, :not_found}` if component doesn't exist

  ## Examples

      iex> delete_component(1)
      {:ok, %Component{}}

      iex> delete_component(1, delete_instances: true)
      {:ok, %Component{}}
  """
  def delete_component(id, opts \\ []) do
    delete_instances = Keyword.get(opts, :delete_instances, false)
    unlink_instances = Keyword.get(opts, :unlink_instances, true)

    case get_component(id) do
      nil ->
        {:error, :not_found}

      component ->
        # Handle instances
        if delete_instances do
          # Delete all instances
          Object
          |> where([o], o.component_id == ^id and o.is_main_component == false)
          |> Repo.delete_all()
        else
          if unlink_instances do
            # Unlink instances (set component_id to nil)
            Object
            |> where([o], o.component_id == ^id and o.is_main_component == false)
            |> Repo.update_all(set: [component_id: nil])
          end
        end

        # Delete or unlink main component objects
        Object
        |> where([o], o.component_id == ^id and o.is_main_component == true)
        |> Repo.update_all(set: [component_id: nil, is_main_component: false])

        # Delete the component
        case Repo.delete(component) do
          {:ok, deleted} ->
            broadcast_component_change(:deleted, deleted)
            {:ok, deleted}

          error ->
            error
        end
    end
  end

  # Private functions

  defp encode_template_data(objects) do
    template =
      Enum.map(objects, fn obj ->
        %{
          id: obj.id,
          type: obj.type,
          data: obj.data,
          position: obj.position
        }
      end)

    Jason.encode!(template)
  end

  defp decode_template_data(nil), do: []

  defp decode_template_data(template_data) when is_binary(template_data) do
    case Jason.decode(template_data) do
      {:ok, data} ->
        Enum.map(data, fn obj ->
          %{
            id: obj["id"],
            type: obj["type"],
            data: obj["data"],
            position: %{
              x: obj["position"]["x"] || 0,
              y: obj["position"]["y"] || 0
            }
          }
        end)

      {:error, _} ->
        []
    end
  end

  defp calculate_base_position([]), do: %{x: 0, y: 0}

  defp calculate_base_position(template_objects) do
    # Use the first object's position as the base
    first = List.first(template_objects)
    first.position
  end

  defp propagate_to_instances(component_id, changes, skip_fields) do
    # Get all instances
    instances = list_component_instances(component_id)

    # Get main component objects for template update
    main_objects =
      Object
      |> where([o], o.component_id == ^component_id and o.is_main_component == true)
      |> Repo.all()

    # Update template data if it exists
    if Enum.any?(main_objects) do
      template_data = encode_template_data(main_objects)

      # Apply template changes to instances
      # Filter out changes that should be skipped
      instance_changes =
        changes
        |> Map.drop(skip_fields)
        |> Map.drop([:name, :description, :category, :is_published])

      # Update each instance that doesn't have overrides for these fields
      Enum.each(instances, fn instance ->
        # Check instance overrides
        overrides =
          case instance.instance_overrides do
            nil -> %{}
            override_str -> Jason.decode!(override_str)
          end

        # Only apply changes for fields not in overrides
        applicable_changes =
          instance_changes
          |> Enum.filter(fn {key, _value} ->
            !Map.has_key?(overrides, Atom.to_string(key))
          end)
          |> Map.new()

        if map_size(applicable_changes) > 0 do
          Canvases.update_object(instance.id, applicable_changes)
        end
      end)
    end

    :ok
  end

  defp broadcast_component_change(event, component, metadata \\ %{}) do
    Phoenix.PubSub.broadcast(
      CollabCanvas.PubSub,
      "component:#{event}",
      {event, component, metadata}
    )
  end
end
</file>

<file path="lib/collab_canvas/mailer.ex">
defmodule CollabCanvas.Mailer do
  use Swoosh.Mailer, otp_app: :collab_canvas
end
</file>

<file path="lib/collab_canvas/release.ex">
defmodule CollabCanvas.Release do
  @moduledoc """
  Used for executing DB release tasks when run in production without Mix
  installed.
  """
  @app :collab_canvas

  def migrate do
    load_app()

    for repo <- repos() do
      {:ok, _, _} =
        Ecto.Migrator.with_repo(
          repo,
          &Ecto.Migrator.run(&1, :up, all: true),
          pool_size: 1,
          queue_target: 5000,
          queue_interval: 5000
        )
    end
  end

  def rollback(repo, version) do
    load_app()

    {:ok, _, _} =
      Ecto.Migrator.with_repo(
        repo,
        &Ecto.Migrator.run(&1, :down, to: version),
        pool_size: 1,
        queue_target: 5000,
        queue_interval: 5000
      )
  end

  defp repos do
    Application.fetch_env!(@app, :ecto_repos)
  end

  defp load_app do
    Application.load(@app)
    Application.ensure_all_started(:ssl)
  end
end
</file>

<file path="lib/collab_canvas/repo.ex">
defmodule CollabCanvas.Repo do
  @moduledoc """
  Ecto repository for database access in CollabCanvas.

  This module serves as the primary interface for all database operations in the
  CollabCanvas application. It uses Ecto as the database wrapper and query generator,
  configured to use SQLite3 via the Exqlite adapter.

  ## Database Configuration

  The repository is configured with:
  - **Adapter**: `Ecto.Adapters.SQLite3` (via Exqlite package)
  - **OTP App**: `:collab_canvas`
  - **Database File**: `collab_canvas_dev.db` (development), `collab_canvas_test.db` (test)
  - **Location**: Configurable via `DATABASE_PATH` environment variable
  - **Pool Size**: 5 connections in development

  ### SQLite-Specific Considerations

  SQLite is an embedded, serverless database engine that:
  - Stores the entire database in a single file
  - Is well-suited for development and small-to-medium deployments
  - Has limited concurrency compared to PostgreSQL/MySQL
  - Automatically handles transactions and ACID compliance
  - Supports foreign key constraints (used for cascading deletes)

  ## Core Database Operations

  The Repo module provides standard Ecto repository functions for CRUD operations:

  ### Queries
  - `all/2` - Fetch all records matching a query
  - `get/3` - Fetch a single record by primary key
  - `get_by/3` - Fetch a single record by arbitrary field
  - `one/2` - Fetch exactly one record (raises if 0 or multiple)

  ### Modifications
  - `insert/2` - Insert a new record from a changeset
  - `update/2` - Update an existing record using a changeset
  - `delete/2` - Delete a record
  - `delete_all/2` - Delete all records matching a query

  ### Associations
  - `preload/3` - Eagerly load associations for structs

  ### Transactions
  - `transaction/2` - Execute multiple operations atomically
  - `rollback/1` - Manually rollback a transaction

  ## Usage Patterns in Context Modules

  The Repo is primarily accessed through context modules (e.g., `CollabCanvas.Canvases`,
  `CollabCanvas.Accounts`) that provide business logic layer over raw database operations.

  ### Standard CRUD Pattern

      # In a context module
      alias CollabCanvas.Repo
      import Ecto.Query

      def create_canvas(user_id, name) do
        %Canvas{}
        |> Canvas.changeset(%{user_id: user_id, name: name})
        |> Repo.insert()
      end

      def get_canvas(id) do
        Repo.get(Canvas, id)
      end

      def list_user_canvases(user_id) do
        Canvas
        |> where([c], c.user_id == ^user_id)
        |> order_by([c], desc: c.updated_at)
        |> Repo.all()
      end

      def update_object(id, attrs) do
        case Repo.get(Object, id) do
          nil -> {:error, :not_found}
          object ->
            object
            |> Object.changeset(attrs)
            |> Repo.update()
        end
      end

  ### Preloading Associations

      # Eager load relationships to avoid N+1 queries
      canvas = Repo.get(Canvas, id)
      canvas_with_objects = Repo.preload(canvas, :objects)

      # Preload in queries
      Canvas
      |> preload(:user)
      |> Repo.all()

  ### Transactions for Atomic Operations

      Repo.transaction(fn ->
        {:ok, canvas} = create_canvas(user_id, "New Canvas")
        {:ok, object} = create_object(canvas.id, "rectangle", %{})
        {canvas, object}
      end)

  ## Database Schema Management

  The repository manages several core schemas:
  - **Users**: Application users (via Auth0)
  - **Canvases**: Drawing workspaces belonging to users
  - **Objects**: Shapes and elements on canvases

  Database migrations are stored in `priv/repo/migrations/` and applied using:

      mix ecto.migrate

  ## Environment-Specific Configuration

  Configuration is environment-aware:
  - **Development**: Local SQLite file with verbose logging
  - **Test**: Separate test database with sandbox mode
  - **Production**: Configured via runtime environment variables

  See `config/dev.exs`, `config/test.exs`, and `config/runtime.exs` for details.

  ## Testing Considerations

  In tests, Ecto's SQL Sandbox provides transaction-based isolation:
  - Each test runs in a transaction that's rolled back
  - Tests can run concurrently without interfering
  - Database state is clean for each test

  ## Performance Notes

  - Use `preload/3` to avoid N+1 query problems
  - Leverage Ecto queries for complex filtering (avoid loading then filtering in Elixir)
  - SQLite supports indexes on frequently queried columns
  - Use `Repo.delete_all/2` for bulk deletions instead of iterating
  - Connection pooling is handled automatically by Ecto

  For more information, see:
  - [Ecto documentation](https://hexdocs.pm/ecto)
  - [Ecto.Repo documentation](https://hexdocs.pm/ecto/Ecto.Repo.html)
  - [Exqlite adapter](https://hexdocs.pm/exqlite)
  """

  use Ecto.Repo,
    otp_app: :collab_canvas,
    adapter: Ecto.Adapters.SQLite3
end
</file>

<file path="lib/collab_canvas/styles.ex">
defmodule CollabCanvas.Styles do
  @moduledoc """
  The Styles context.

  This module provides the business logic layer for managing styles in the
  CollabCanvas application. It handles colors, text styles, and effects that
  can be applied to canvas objects and exported as design tokens.

  ## Features

  - **CRUD Operations**: Create, read, update, and delete styles
  - **Real-time Sync**: PubSub broadcasts for style changes across collaborators
  - **Style Application**: Apply styles to canvas objects
  - **Design Token Export**: Export styles in various design token formats
  - **Performance**: Style application optimized to meet 50ms target

  ## Style Types

  - **Color**: RGB/RGBA color definitions
  - **Text**: Typography styles (font family, size, weight, line-height)
  - **Effect**: Visual effects (shadows, blurs, etc.)

  ## Real-time Collaboration

  All style operations broadcast changes via Phoenix.PubSub to ensure
  real-time synchronization across all collaborators on a canvas.

  ## Usage Examples

      # Create a color style
      {:ok, style} = create_style(canvas_id, %{
        name: "Primary Blue",
        type: "color",
        category: "primary",
        definition: %{r: 37, g: 99, b: 235, a: 1.0}
      })

      # Apply style to an object
      {:ok, object} = apply_style(object_id, style_id)

      # Export design tokens
      {:ok, tokens} = export_design_tokens(canvas_id, :css)

      # Update style and propagate changes
      {:ok, updated} = update_style(style_id, %{
        definition: %{r: 40, g: 100, b: 240, a: 1.0}
      })
  """

  import Ecto.Query, warn: false
  alias CollabCanvas.Repo
  alias CollabCanvas.Styles.Style
  alias CollabCanvas.Canvases
  alias Phoenix.PubSub

  @pubsub CollabCanvas.PubSub
  @performance_target_ms 50

  # ============================================================================
  # CRUD Operations
  # ============================================================================

  @doc """
  Creates a new style on a canvas.

  ## Parameters
    * `canvas_id` - The ID of the canvas
    * `attrs` - Map of style attributes

  ## Required Attributes
    * `name` - Style name
    * `type` - Style type (color, text, effect)
    * `definition` - Style properties (map or JSON string)

  ## Optional Attributes
    * `category` - Style category
    * `created_by` - User ID who created the style

  ## Returns
    * `{:ok, style}` on success
    * `{:error, changeset}` on validation failure

  ## Examples

      iex> create_style(1, %{
      ...>   name: "Primary Blue",
      ...>   type: "color",
      ...>   definition: %{r: 37, g: 99, b: 235, a: 1.0}
      ...> })
      {:ok, %Style{}}

      iex> create_style(1, %{name: "Invalid"})
      {:error, %Ecto.Changeset{}}

  ## Broadcasts
    * `"styles:canvas_id"` - `{:style_created, style}`
  """
  def create_style(canvas_id, attrs) do
    attrs = Map.put(attrs, :canvas_id, canvas_id)

    result =
      %Style{}
      |> Style.changeset(attrs)
      |> Repo.insert()

    case result do
      {:ok, style} ->
        broadcast_style_change(canvas_id, {:style_created, style})
        {:ok, style}

      error ->
        error
    end
  end

  @doc """
  Gets a single style by ID.

  ## Parameters
    * `id` - The style ID

  ## Returns
    * The style struct if found
    * `nil` if not found

  ## Examples

      iex> get_style(123)
      %Style{}

      iex> get_style(456)
      nil
  """
  def get_style(id) do
    Repo.get(Style, id)
  end

  @doc """
  Gets a style with preloaded associations.

  ## Parameters
    * `id` - The style ID
    * `preloads` - List of associations to preload (default: [:canvas, :creator])

  ## Returns
    * The style struct with preloaded associations if found
    * `nil` if not found

  ## Examples

      iex> get_style_with_preloads(123)
      %Style{canvas: %Canvas{}, creator: %User{}}
  """
  def get_style_with_preloads(id, preloads \\ [:canvas, :creator]) do
    case get_style(id) do
      nil -> nil
      style -> Repo.preload(style, preloads)
    end
  end

  @doc """
  Lists all styles for a specific canvas.

  ## Parameters
    * `canvas_id` - The canvas ID

  ## Options
    * `:type` - Filter by style type (e.g., "color", "text")
    * `:category` - Filter by category

  ## Returns
    * List of style structs

  ## Examples

      iex> list_styles(1)
      [%Style{}, %Style{}]

      iex> list_styles(1, type: "color")
      [%Style{type: "color"}, %Style{type: "color"}]
  """
  def list_styles(canvas_id, opts \\ []) do
    query =
      Style
      |> where([s], s.canvas_id == ^canvas_id)
      |> order_by([s], asc: s.name)

    query =
      if type = opts[:type] do
        where(query, [s], s.type == ^type)
      else
        query
      end

    query =
      if category = opts[:category] do
        where(query, [s], s.category == ^category)
      else
        query
      end

    Repo.all(query)
  end

  @doc """
  Updates an existing style.

  When a style is updated, all objects using that style are notified
  via PubSub for automatic re-rendering with the new style properties.

  ## Parameters
    * `id` - The style ID
    * `attrs` - Map of attributes to update

  ## Returns
    * `{:ok, style}` on success
    * `{:error, changeset}` on validation failure
    * `{:error, :not_found}` if style doesn't exist

  ## Examples

      iex> update_style(1, %{name: "Primary Blue Updated"})
      {:ok, %Style{}}

      iex> update_style(999, %{name: "Test"})
      {:error, :not_found}

  ## Broadcasts
    * `"styles:canvas_id"` - `{:style_updated, style}`

  ## Performance
    * Target: < 50ms including database update and PubSub broadcast
  """
  def update_style(id, attrs) do
    start_time = System.monotonic_time(:millisecond)

    result =
      case Repo.get(Style, id) do
        nil ->
          {:error, :not_found}

        style ->
          changeset = Style.changeset(style, attrs)

          case Repo.update(changeset) do
            {:ok, updated_style} ->
              # Broadcast style change for real-time sync
              broadcast_style_change(updated_style.canvas_id, {:style_updated, updated_style})

              # Log performance if it exceeds target
              elapsed = System.monotonic_time(:millisecond) - start_time

              if elapsed > @performance_target_ms do
                require Logger

                Logger.warning(
                  "Style update exceeded #{@performance_target_ms}ms target: #{elapsed}ms"
                )
              end

              {:ok, updated_style}

            error ->
              error
          end
      end

    result
  end

  @doc """
  Deletes a style.

  ## Parameters
    * `id` - The style ID

  ## Returns
    * `{:ok, style}` on success
    * `{:error, :not_found}` if style doesn't exist

  ## Examples

      iex> delete_style(1)
      {:ok, %Style{}}

      iex> delete_style(999)
      {:error, :not_found}

  ## Broadcasts
    * `"styles:canvas_id"` - `{:style_deleted, style_id}`
  """
  def delete_style(id) do
    case Repo.get(Style, id) do
      nil ->
        {:error, :not_found}

      style ->
        canvas_id = style.canvas_id

        case Repo.delete(style) do
          {:ok, deleted_style} ->
            broadcast_style_change(canvas_id, {:style_deleted, deleted_style.id})
            {:ok, deleted_style}

          error ->
            error
        end
    end
  end

  # ============================================================================
  # Style Application
  # ============================================================================

  @doc """
  Applies a style to a canvas object.

  This function updates the object's properties to match the style definition.
  The actual property mapping depends on the object type and style type.

  ## Parameters
    * `object_id` - The ID of the object to style
    * `style_id` - The ID of the style to apply

  ## Returns
    * `{:ok, object}` on success
    * `{:error, :not_found}` if object or style doesn't exist
    * `{:error, :incompatible_type}` if style cannot be applied to object

  ## Examples

      iex> apply_style(object_id, style_id)
      {:ok, %Object{}}

  ## Performance
    * Target: < 50ms including database operations
  """
  def apply_style(object_id, style_id) do
    start_time = System.monotonic_time(:millisecond)

    with {:ok, object} <- fetch_object(object_id),
         {:ok, style} <- fetch_style(style_id),
         {:ok, style_props} <- parse_style_definition(style),
         {:ok, updated_attrs} <- build_style_attrs(object, style_props, style.type) do
      # Update object with style attributes
      result = Canvases.update_object(object_id, updated_attrs)

      # Log performance
      elapsed = System.monotonic_time(:millisecond) - start_time

      if elapsed > @performance_target_ms do
        require Logger

        Logger.warning(
          "Style application exceeded #{@performance_target_ms}ms target: #{elapsed}ms"
        )
      end

      result
    end
  end

  # Helper to fetch object
  defp fetch_object(object_id) do
    case Canvases.get_object(object_id) do
      nil -> {:error, :not_found}
      object -> {:ok, object}
    end
  end

  # Helper to fetch style
  defp fetch_style(style_id) do
    case get_style(style_id) do
      nil -> {:error, :not_found}
      style -> {:ok, style}
    end
  end

  # Helper to parse style definition
  defp parse_style_definition(%Style{} = style) do
    {:ok, Style.decode_definition(style)}
  end

  # Helper to build style attributes for object
  defp build_style_attrs(object, style_props, style_type) do
    # Parse current object data (it's stored as JSON string)
    current_data =
      case object.data do
        nil ->
          %{}

        data_string when is_binary(data_string) ->
          case Jason.decode(data_string) do
            {:ok, parsed} -> parsed
            {:error, _} -> %{}
          end

        data when is_map(data) ->
          data
      end

    # Merge style properties based on type
    updated_data =
      case style_type do
        "color" ->
          Map.merge(current_data, %{"fill" => style_props})

        "text" ->
          Map.merge(current_data, %{"textStyle" => style_props})

        "effect" ->
          effects = Map.get(current_data, "effects", [])
          Map.put(current_data, "effects", effects ++ [style_props])

        _ ->
          current_data
      end

    # Convert back to JSON string for storage
    case Jason.encode(updated_data) do
      {:ok, json_data} ->
        {:ok, %{data: json_data}}

      {:error, _} ->
        {:error, :encoding_failed}
    end
  end

  # ============================================================================
  # Design Token Export
  # ============================================================================

  @doc """
  Exports styles as design tokens in the specified format.

  ## Parameters
    * `canvas_id` - The canvas ID
    * `format` - Export format (`:css`, `:scss`, `:json`, `:js`)

  ## Returns
    * `{:ok, token_string}` on success
    * `{:error, reason}` on failure

  ## Formats

  - `:css` - CSS custom properties
  - `:scss` - SCSS variables
  - `:json` - JSON design tokens
  - `:js` - JavaScript/TypeScript constants

  ## Examples

      iex> export_design_tokens(1, :css)
      {:ok, ":root {\\n  --primary-blue: rgb(37, 99, 235);\\n}"}

      iex> export_design_tokens(1, :json)
      {:ok, "{\\"colors\\": {\\"primary-blue\\": \\"#2563eb\\"}}"}
  """
  def export_design_tokens(canvas_id, format) when format in [:css, :scss, :json, :js] do
    styles = list_styles(canvas_id)

    case format do
      :css -> export_to_css(styles)
      :scss -> export_to_scss(styles)
      :json -> export_to_json(styles)
      :js -> export_to_js(styles)
    end
  end

  def export_design_tokens(_canvas_id, format) do
    {:error, "Unsupported format: #{format}"}
  end

  # Export to CSS custom properties
  defp export_to_css(styles) do
    tokens =
      styles
      |> Enum.map(&style_to_css_token/1)
      |> Enum.reject(&is_nil/1)
      |> Enum.join("\n")

    css = ":root {\n#{tokens}\n}"
    {:ok, css}
  end

  defp style_to_css_token(%Style{type: "color", name: name} = style) do
    props = Style.decode_definition(style)
    color_value = format_css_color(props)
    var_name = String.downcase(name) |> String.replace(" ", "-")
    "  --#{var_name}: #{color_value};"
  end

  defp style_to_css_token(%Style{type: "text", name: name} = style) do
    props = Style.decode_definition(style)
    var_name = String.downcase(name) |> String.replace(" ", "-")

    [
      "  --#{var_name}-font-family: #{props["fontFamily"] || "inherit"};",
      "  --#{var_name}-font-size: #{props["fontSize"] || 16}px;",
      "  --#{var_name}-font-weight: #{props["fontWeight"] || 400};",
      "  --#{var_name}-line-height: #{props["lineHeight"] || 1.5};"
    ]
    |> Enum.join("\n")
  end

  defp style_to_css_token(_), do: nil

  # Export to SCSS variables
  defp export_to_scss(styles) do
    tokens =
      styles
      |> Enum.map(&style_to_scss_token/1)
      |> Enum.reject(&is_nil/1)
      |> Enum.join("\n")

    {:ok, tokens}
  end

  defp style_to_scss_token(%Style{type: "color", name: name} = style) do
    props = Style.decode_definition(style)
    color_value = format_css_color(props)
    var_name = String.downcase(name) |> String.replace(" ", "-")
    "$#{var_name}: #{color_value};"
  end

  defp style_to_scss_token(%Style{type: "text", name: name} = style) do
    props = Style.decode_definition(style)
    var_name = String.downcase(name) |> String.replace(" ", "-")

    [
      "$#{var_name}-font-family: #{props["fontFamily"] || "inherit"};",
      "$#{var_name}-font-size: #{props["fontSize"] || 16}px;",
      "$#{var_name}-font-weight: #{props["fontWeight"] || 400};",
      "$#{var_name}-line-height: #{props["lineHeight"] || 1.5};"
    ]
    |> Enum.join("\n")
  end

  defp style_to_scss_token(_), do: nil

  # Export to JSON design tokens
  defp export_to_json(styles) do
    tokens =
      styles
      |> Enum.group_by(& &1.type)
      |> Map.new(fn {type, type_styles} ->
        style_map =
          type_styles
          |> Map.new(fn style ->
            name = String.downcase(style.name) |> String.replace(" ", "-")
            {name, Style.decode_definition(style)}
          end)

        {type <> "s", style_map}
      end)

    case Jason.encode(tokens, pretty: true) do
      {:ok, json} -> {:ok, json}
      {:error, reason} -> {:error, "JSON encoding failed: #{inspect(reason)}"}
    end
  end

  # Export to JavaScript/TypeScript constants
  defp export_to_js(styles) do
    tokens =
      styles
      |> Enum.map(&style_to_js_token/1)
      |> Enum.reject(&is_nil/1)
      |> Enum.join("\n")

    js = "export const tokens = {\n#{tokens}\n};"
    {:ok, js}
  end

  defp style_to_js_token(%Style{type: "color", name: name} = style) do
    props = Style.decode_definition(style)
    color_value = format_css_color(props)
    var_name = String.downcase(name) |> String.replace(" ", "-") |> String.replace("-", "_")
    "  #{var_name}: '#{color_value}',"
  end

  defp style_to_js_token(%Style{type: "text", name: name} = style) do
    props = Style.decode_definition(style)
    var_name = String.downcase(name) |> String.replace(" ", "-") |> String.replace("-", "_")

    props_json = Jason.encode!(props)
    "  #{var_name}: #{props_json},"
  end

  defp style_to_js_token(_), do: nil

  # Format color as CSS rgb/rgba
  defp format_css_color(%{"r" => r, "g" => g, "b" => b, "a" => a}) when a < 1.0 do
    "rgba(#{r}, #{g}, #{b}, #{a})"
  end

  defp format_css_color(%{"r" => r, "g" => g, "b" => b}) do
    "rgb(#{r}, #{g}, #{b})"
  end

  defp format_css_color(_), do: "transparent"

  # ============================================================================
  # PubSub Integration
  # ============================================================================

  @doc """
  Subscribes to style changes for a canvas.

  ## Parameters
    * `canvas_id` - The canvas ID

  ## Examples

      iex> subscribe_to_styles(123)
      :ok
  """
  def subscribe_to_styles(canvas_id) do
    PubSub.subscribe(@pubsub, "styles:#{canvas_id}")
  end

  @doc """
  Unsubscribes from style changes for a canvas.

  ## Parameters
    * `canvas_id` - The canvas ID

  ## Examples

      iex> unsubscribe_from_styles(123)
      :ok
  """
  def unsubscribe_from_styles(canvas_id) do
    PubSub.unsubscribe(@pubsub, "styles:#{canvas_id}")
  end

  @doc """
  Broadcasts a style change event to all subscribers.

  ## Parameters
    * `canvas_id` - The canvas ID
    * `message` - The message to broadcast

  ## Message Formats
    * `{:style_created, style}`
    * `{:style_updated, style}`
    * `{:style_deleted, style_id}`

  ## Examples

      iex> broadcast_style_change(123, {:style_updated, style})
      :ok
  """
  def broadcast_style_change(canvas_id, message) do
    PubSub.broadcast(@pubsub, "styles:#{canvas_id}", message)
  end
end
</file>

<file path="lib/collab_canvas_web/components/layouts/root.html.heex">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="csrf-token" content={get_csrf_token()} />
    <.live_title default="CollabCanvas" suffix=" · Phoenix Framework">
      {assigns[:page_title]}
    </.live_title>
    <link phx-track-static rel="stylesheet" href={~p"/assets/css/app.css"} />
    <script defer phx-track-static type="module" src={~p"/assets/js/app.js"}>
    </script>
    <script>
      (() => {
        const setTheme = (theme) => {
          if (theme === "system") {
            localStorage.removeItem("phx:theme");
            document.documentElement.removeAttribute("data-theme");
          } else {
            localStorage.setItem("phx:theme", theme);
            document.documentElement.setAttribute("data-theme", theme);
          }
        };
        if (!document.documentElement.hasAttribute("data-theme")) {
          setTheme(localStorage.getItem("phx:theme") || "system");
        }
        window.addEventListener("storage", (e) => e.key === "phx:theme" && setTheme(e.newValue || "system"));
        
        window.addEventListener("phx:set-theme", (e) => setTheme(e.target.dataset.phxTheme));
      })();
    </script>
  </head>
  <body>
    {@inner_content}
  </body>
</html>
</file>

<file path="lib/collab_canvas_web/components/color_picker.ex">
defmodule CollabCanvasWeb.Components.ColorPicker do
  @moduledoc """
  LiveComponent for color picking with HSL sliders, hex input, and color history.

  Features:
  - HSL sliders for intuitive color selection
  - Hex color input
  - Recent colors (last 10 used)
  - Favorite colors (pinned)
  - Default color setting
  """

  use CollabCanvasWeb, :live_component
  alias CollabCanvas.ColorPalettes

  @impl true
  def mount(socket) do
    {:ok,
     socket
     |> assign(:hue, 0)
     |> assign(:saturation, 100)
     |> assign(:lightness, 50)
     |> assign(:hex_color, "#FF0000")
     |> assign(:recent_colors, [])
     |> assign(:favorite_colors, [])
     |> assign(:default_color, "#000000")}
  end

  @impl true
  def update(%{user_id: user_id} = assigns, socket) do
    # Load user's color preferences
    preferences = ColorPalettes.get_or_create_preferences(user_id)
    recent_colors = ColorPalettes.get_recent_colors(user_id)
    favorite_colors = ColorPalettes.get_favorite_colors(user_id)

    # Parse current color from hex to HSL if provided
    {h, s, l} = assigns[:current_color] && hex_to_hsl(assigns[:current_color]) || {0, 100, 50}

    {:ok,
     socket
     |> assign(assigns)
     |> assign(:hue, h)
     |> assign(:saturation, s)
     |> assign(:lightness, l)
     |> assign(:hex_color, assigns[:current_color] || preferences.default_color)
     |> assign(:recent_colors, recent_colors)
     |> assign(:favorite_colors, favorite_colors)
     |> assign(:default_color, preferences.default_color)}
  end

  @impl true
  def handle_event("hue_changed", %{"value" => hue_str}, socket) do
    hue = String.to_integer(hue_str)
    hex_color = hsl_to_hex(hue, socket.assigns.saturation, socket.assigns.lightness)

    # Auto-save as default color
    ColorPalettes.set_default_color(socket.assigns.user_id, hex_color)
    send(self(), {:color_changed, hex_color, socket.assigns.user_id})

    {:noreply, socket |> assign(:hue, hue) |> assign(:hex_color, hex_color) |> assign(:default_color, hex_color)}
  end

  @impl true
  def handle_event("saturation_changed", %{"value" => sat_str}, socket) do
    saturation = String.to_integer(sat_str)
    hex_color = hsl_to_hex(socket.assigns.hue, saturation, socket.assigns.lightness)

    # Auto-save as default color
    ColorPalettes.set_default_color(socket.assigns.user_id, hex_color)
    send(self(), {:color_changed, hex_color, socket.assigns.user_id})

    {:noreply, socket |> assign(:saturation, saturation) |> assign(:hex_color, hex_color) |> assign(:default_color, hex_color)}
  end

  @impl true
  def handle_event("lightness_changed", %{"value" => light_str}, socket) do
    lightness = String.to_integer(light_str)
    hex_color = hsl_to_hex(socket.assigns.hue, socket.assigns.saturation, lightness)

    # Auto-save as default color
    ColorPalettes.set_default_color(socket.assigns.user_id, hex_color)
    send(self(), {:color_changed, hex_color, socket.assigns.user_id})

    {:noreply, socket |> assign(:lightness, lightness) |> assign(:hex_color, hex_color) |> assign(:default_color, hex_color)}
  end

  @impl true
  def handle_event("hex_input", %{"color" => hex_color}, socket) do
    # Validate and normalize hex color
    normalized = normalize_hex(hex_color)

    case valid_hex?(normalized) do
      true ->
        {h, s, l} = hex_to_hsl(normalized)
        # Auto-save as default color
        ColorPalettes.set_default_color(socket.assigns.user_id, normalized)
        send(self(), {:color_changed, normalized, socket.assigns.user_id})

        {:noreply,
         socket
         |> assign(:hex_color, normalized)
         |> assign(:hue, h)
         |> assign(:saturation, s)
         |> assign(:lightness, l)
         |> assign(:default_color, normalized)}

      false ->
        {:noreply, socket}
    end
  end

  @impl true
  def handle_event("select_color", %{"color" => color}, socket) do
    {h, s, l} = hex_to_hsl(color)
    # Auto-save as default color
    ColorPalettes.set_default_color(socket.assigns.user_id, color)
    send(self(), {:color_changed, color, socket.assigns.user_id})

    {:noreply,
     socket
     |> assign(:hex_color, color)
     |> assign(:hue, h)
     |> assign(:saturation, s)
     |> assign(:lightness, l)
     |> assign(:default_color, color)}
  end

  @impl true
  def handle_event("add_to_favorites", _params, socket) do
    {:ok, _} = ColorPalettes.add_favorite_color(socket.assigns.user_id, socket.assigns.hex_color)
    favorite_colors = ColorPalettes.get_favorite_colors(socket.assigns.user_id)

    {:noreply, assign(socket, :favorite_colors, favorite_colors)}
  end

  @impl true
  def handle_event("remove_from_favorites", %{"color" => color}, socket) do
    {:ok, _} = ColorPalettes.remove_favorite_color(socket.assigns.user_id, color)
    favorite_colors = ColorPalettes.get_favorite_colors(socket.assigns.user_id)

    {:noreply, assign(socket, :favorite_colors, favorite_colors)}
  end

  @impl true
  def handle_event("set_as_default", _params, socket) do
    {:ok, _} = ColorPalettes.set_default_color(socket.assigns.user_id, socket.assigns.hex_color)

    {:noreply, assign(socket, :default_color, socket.assigns.hex_color)}
  end

  @impl true
  def handle_event("picker_square_changed", %{"saturation" => sat_str, "lightness" => light_str}, socket) do
    saturation = String.to_float(sat_str) |> round()
    lightness = String.to_float(light_str) |> round()

    hex_color = hsl_to_hex(socket.assigns.hue, saturation, lightness)

    # Auto-save as default color
    ColorPalettes.set_default_color(socket.assigns.user_id, hex_color)
    send(self(), {:color_changed, hex_color, socket.assigns.user_id})

    {:noreply, socket |> assign(:saturation, saturation) |> assign(:lightness, lightness) |> assign(:hex_color, hex_color) |> assign(:default_color, hex_color)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="color-picker bg-white rounded-lg shadow-lg p-4 w-80" phx-hook="ColorPicker" id="color-picker-hook">
      <div class="mb-4">
        <div class="text-sm font-medium text-gray-700 mb-2">Current Color</div>
        <div class="flex items-center gap-3">
          <div
            class="w-16 h-16 rounded border-2 border-gray-300"
            style={"background-color: #{@hex_color}"}
          >
          </div>
          <form phx-change="hex_input" phx-target={@myself} class="flex-1">
            <input
              type="text"
              name="color"
              value={@hex_color}
              phx-debounce="300"
              class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-sm"
              placeholder="#RRGGBB"
            />
          </form>
        </div>
      </div>

      <!-- 2D Color Picker -->
      <div class="mb-4">
        <!-- Saturation/Lightness Square -->
        <div
          id="color-picker-square"
          data-hue={@hue}
          data-saturation={@saturation}
          data-lightness={@lightness}
          class="relative w-full h-48 rounded cursor-crosshair mb-3 border-2 border-gray-300"
          style={"background: linear-gradient(to bottom, transparent, black), linear-gradient(to right, white, #{hsl_to_hex(@hue, 100, 50)})"}
        >
          <!-- Color picker indicator (white circle with border) -->
          <div
            id="color-picker-indicator"
            class="absolute w-4 h-4 border-2 border-white rounded-full pointer-events-none shadow-lg"
            style={"left: #{@saturation}%; top: #{100 - @lightness}%; transform: translate(-50%, -50%)"}
          >
          </div>
        </div>

        <!-- Hue Slider -->
        <div>
          <label class="text-xs font-medium text-gray-600 mb-1 block">Hue: {@hue}°</label>
          <form phx-change="hue_changed" phx-target={@myself}>
            <input
              type="range"
              name="value"
              min="0"
              max="360"
              value={@hue}
              class="w-full h-3 rounded-lg appearance-none cursor-pointer"
              style="background: linear-gradient(to right, #FF0000 0%, #FFFF00 17%, #00FF00 33%, #00FFFF 50%, #0000FF 67%, #FF00FF 83%, #FF0000 100%)"
            />
          </form>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="mb-4">
        <button
          phx-click="add_to_favorites"
          phx-target={@myself}
          class="w-full px-3 py-2 text-xs font-medium text-white bg-blue-500 hover:bg-blue-600 rounded transition"
        >
          ★ Add to Favorites
        </button>
      </div>

      <!-- Recent Colors -->
      <%= if length(@recent_colors) > 0 do %>
        <div class="mb-4">
          <div class="text-xs font-medium text-gray-600 mb-2">Recent Colors</div>
          <div class="flex flex-wrap gap-2">
            <%= for color <- @recent_colors do %>
              <button
                phx-click="select_color"
                phx-value-color={color}
                phx-target={@myself}
                class="w-8 h-8 rounded border-2 border-gray-300 hover:border-blue-500 transition cursor-pointer"
                style={"background-color: #{color}"}
                title={color}
              >
              </button>
            <% end %>
          </div>
        </div>
      <% end %>

      <!-- Favorite Colors -->
      <%= if length(@favorite_colors) > 0 do %>
        <div class="mb-2">
          <div class="text-xs font-medium text-gray-600 mb-2">Favorite Colors</div>
          <div class="flex flex-wrap gap-2">
            <%= for color <- @favorite_colors do %>
              <div class="relative group">
                <button
                  phx-click="select_color"
                  phx-value-color={color}
                  phx-target={@myself}
                  class="w-8 h-8 rounded border-2 border-gray-300 hover:border-blue-500 transition cursor-pointer"
                  style={"background-color: #{color}"}
                  title={color}
                >
                </button>
                <button
                  phx-click="remove_from_favorites"
                  phx-value-color={color}
                  phx-target={@myself}
                  class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-xs opacity-0 group-hover:opacity-100 transition"
                >
                  ×
                </button>
              </div>
            <% end %>
          </div>
        </div>
      <% end %>
    </div>
    """
  end

  # Color conversion helpers

  defp hex_to_hsl("#" <> hex) do
    hex_to_hsl(hex)
  end

  defp hex_to_hsl(hex) when byte_size(hex) == 6 do
    {r, _} = hex |> String.slice(0, 2) |> Integer.parse(16)
    {g, _} = hex |> String.slice(2, 2) |> Integer.parse(16)
    {b, _} = hex |> String.slice(4, 2) |> Integer.parse(16)

    rgb_to_hsl(r / 255, g / 255, b / 255)
  end

  defp hex_to_hsl(_), do: {0, 100, 50}

  defp rgb_to_hsl(r, g, b) do
    max_val = Enum.max([r, g, b])
    min_val = Enum.min([r, g, b])
    delta = max_val - min_val

    l = (max_val + min_val) / 2

    s =
      cond do
        delta == 0 -> 0
        l < 0.5 -> delta / (max_val + min_val)
        true -> delta / (2.0 - max_val - min_val)
      end

    h =
      cond do
        delta == 0 ->
          0

        max_val == r ->
          60 * rem(trunc((g - b) / delta * 6), 6)

        max_val == g ->
          60 * ((b - r) / delta + 2)

        true ->
          60 * ((r - g) / delta + 4)
      end

    h = if h < 0, do: h + 360, else: h

    {round(h), round(s * 100), round(l * 100)}
  end

  defp hsl_to_hex(h, s, l) do
    hsl_to_rgb(h, s / 100, l / 100)
    |> rgb_to_hex()
  end

  defp hsl_to_rgb(h, s, l) do
    c = (1 - abs(2 * l - 1)) * s
    h_prime = h / 60
    x = c * (1 - abs(rem(trunc(h_prime), 2) - 1))
    m = l - c / 2

    {r1, g1, b1} =
      cond do
        h_prime < 1 -> {c, x, 0}
        h_prime < 2 -> {x, c, 0}
        h_prime < 3 -> {0, c, x}
        h_prime < 4 -> {0, x, c}
        h_prime < 5 -> {x, 0, c}
        true -> {c, 0, x}
      end

    r = round((r1 + m) * 255)
    g = round((g1 + m) * 255)
    b = round((b1 + m) * 255)

    {r, g, b}
  end

  defp rgb_to_hex({r, g, b}) do
    "#" <>
      (r |> Integer.to_string(16) |> String.pad_leading(2, "0")) <>
      (g |> Integer.to_string(16) |> String.pad_leading(2, "0")) <>
      (b |> Integer.to_string(16) |> String.pad_leading(2, "0"))
    |> String.upcase()
  end

  defp normalize_hex("#" <> hex), do: "#" <> String.upcase(hex)
  defp normalize_hex(hex), do: "#" <> String.upcase(hex)

  defp valid_hex?("#" <> hex) when byte_size(hex) == 6 do
    String.match?(hex, ~r/^[0-9A-F]{6}$/i)
  end

  defp valid_hex?(_), do: false
end
</file>

<file path="lib/collab_canvas_web/components/core_components.ex">
defmodule CollabCanvasWeb.CoreComponents do
  @moduledoc """
  Provides core UI components.

  At first glance, this module may seem daunting, but its goal is to provide
  core building blocks for your application, such as tables, forms, and
  inputs. The components consist mostly of markup and are well-documented
  with doc strings and declarative assigns. You may customize and style
  them in any way you want, based on your application growth and needs.

  The foundation for styling is Tailwind CSS, a utility-first CSS framework,
  augmented with daisyUI, a Tailwind CSS plugin that provides UI components
  and themes. Here are useful references:

    * [daisyUI](https://daisyui.com/docs/intro/) - a good place to get
      started and see the available components.

    * [Tailwind CSS](https://tailwindcss.com) - the foundational framework
      we build on. You will use it for layout, sizing, flexbox, grid, and
      spacing.

    * [Heroicons](https://heroicons.com) - see `icon/1` for usage.

    * [Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html) -
      the component system used by Phoenix. Some components, such as `<.link>`
      and `<.form>`, are defined there.

  """
  use Phoenix.Component
  use Gettext, backend: CollabCanvasWeb.Gettext

  alias Phoenix.LiveView.JS

  @doc """
  Renders flash notices.

  ## Examples

      <.flash kind={:info} flash={@flash} />
      <.flash kind={:info} phx-mounted={show("#flash")}>Welcome Back!</.flash>
  """
  attr :id, :string, doc: "the optional id of flash container"
  attr :flash, :map, default: %{}, doc: "the map of flash messages to display"
  attr :title, :string, default: nil
  attr :kind, :atom, values: [:info, :error, :warning], doc: "used for styling and flash lookup"
  attr :rest, :global, doc: "the arbitrary HTML attributes to add to the flash container"

  slot :inner_block, doc: "the optional inner block that renders the flash message"

  def flash(assigns) do
    assigns = assign_new(assigns, :id, fn -> "flash-#{assigns.kind}" end)

    ~H"""
    <div
      :if={msg = render_slot(@inner_block) || Phoenix.Flash.get(@flash, @kind)}
      id={@id}
      phx-click={JS.push("lv:clear-flash", value: %{key: @kind}) |> hide("##{@id}")}
      role="alert"
      class="toast toast-top toast-end z-50"
      {@rest}
    >
      <div class={[
        "alert w-80 sm:w-96 max-w-80 sm:max-w-96 text-wrap",
        @kind == :info && "alert-info",
        @kind == :error && "alert-error",
        @kind == :warning && "alert-warning"
      ]}>
        <.icon :if={@kind == :info} name="hero-information-circle" class="size-5 shrink-0" />
        <.icon :if={@kind == :error} name="hero-exclamation-circle" class="size-5 shrink-0" />
        <.icon :if={@kind == :warning} name="hero-exclamation-triangle" class="size-5 shrink-0" />
        <div>
          <p :if={@title} class="font-semibold">{@title}</p>
          <p>{msg}</p>
        </div>
        <div class="flex-1" />
        <button type="button" class="group self-start cursor-pointer" aria-label={gettext("close")}>
          <.icon name="hero-x-mark" class="size-5 opacity-40 group-hover:opacity-70" />
        </button>
      </div>
    </div>
    """
  end

  @doc """
  Renders a button with navigation support.

  ## Examples

      <.button>Send!</.button>
      <.button phx-click="go" variant="primary">Send!</.button>
      <.button navigate={~p"/"}>Home</.button>
  """
  attr :rest, :global, include: ~w(href navigate patch method download name value disabled)
  attr :class, :string
  attr :variant, :string, values: ~w(primary)
  slot :inner_block, required: true

  def button(%{rest: rest} = assigns) do
    variants = %{"primary" => "btn-primary", nil => "btn-primary btn-soft"}

    assigns =
      assign_new(assigns, :class, fn ->
        ["btn", Map.fetch!(variants, assigns[:variant])]
      end)

    if rest[:href] || rest[:navigate] || rest[:patch] do
      ~H"""
      <.link class={@class} {@rest}>
        {render_slot(@inner_block)}
      </.link>
      """
    else
      ~H"""
      <button class={@class} {@rest}>
        {render_slot(@inner_block)}
      </button>
      """
    end
  end

  @doc """
  Renders an input with label and error messages.

  A `Phoenix.HTML.FormField` may be passed as argument,
  which is used to retrieve the input name, id, and values.
  Otherwise all attributes may be passed explicitly.

  ## Types

  This function accepts all HTML input types, considering that:

    * You may also set `type="select"` to render a `<select>` tag

    * `type="checkbox"` is used exclusively to render boolean values

    * For live file uploads, see `Phoenix.Component.live_file_input/1`

  See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
  for more information. Unsupported types, such as hidden and radio,
  are best written directly in your templates.

  ## Examples

      <.input field={@form[:email]} type="email" />
      <.input name="my-input" errors={["oh no!"]} />
  """
  attr :id, :any, default: nil
  attr :name, :any
  attr :label, :string, default: nil
  attr :value, :any

  attr :type, :string,
    default: "text",
    values: ~w(checkbox color date datetime-local email file month number password
               search select tel text textarea time url week)

  attr :field, Phoenix.HTML.FormField,
    doc: "a form field struct retrieved from the form, for example: @form[:email]"

  attr :errors, :list, default: []
  attr :checked, :boolean, doc: "the checked flag for checkbox inputs"
  attr :prompt, :string, default: nil, doc: "the prompt for select inputs"
  attr :options, :list, doc: "the options to pass to Phoenix.HTML.Form.options_for_select/2"
  attr :multiple, :boolean, default: false, doc: "the multiple flag for select inputs"
  attr :class, :string, default: nil, doc: "the input class to use over defaults"
  attr :error_class, :string, default: nil, doc: "the input error class to use over defaults"

  attr :rest, :global,
    include: ~w(accept autocomplete capture cols disabled form list max maxlength min minlength
                multiple pattern placeholder readonly required rows size step)

  def input(%{field: %Phoenix.HTML.FormField{} = field} = assigns) do
    errors = if Phoenix.Component.used_input?(field), do: field.errors, else: []

    assigns
    |> assign(field: nil, id: assigns.id || field.id)
    |> assign(:errors, Enum.map(errors, &translate_error(&1)))
    |> assign_new(:name, fn -> if assigns.multiple, do: field.name <> "[]", else: field.name end)
    |> assign_new(:value, fn -> field.value end)
    |> input()
  end

  def input(%{type: "checkbox"} = assigns) do
    assigns =
      assign_new(assigns, :checked, fn ->
        Phoenix.HTML.Form.normalize_value("checkbox", assigns[:value])
      end)

    ~H"""
    <div class="fieldset mb-2">
      <label>
        <input type="hidden" name={@name} value="false" disabled={@rest[:disabled]} />
        <span class="label">
          <input
            type="checkbox"
            id={@id}
            name={@name}
            value="true"
            checked={@checked}
            class={@class || "checkbox checkbox-sm"}
            {@rest}
          />{@label}
        </span>
      </label>
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  def input(%{type: "select"} = assigns) do
    ~H"""
    <div class="fieldset mb-2">
      <label>
        <span :if={@label} class="label mb-1">{@label}</span>
        <select
          id={@id}
          name={@name}
          class={[@class || "w-full select", @errors != [] && (@error_class || "select-error")]}
          multiple={@multiple}
          {@rest}
        >
          <option :if={@prompt} value="">{@prompt}</option>
          {Phoenix.HTML.Form.options_for_select(@options, @value)}
        </select>
      </label>
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  def input(%{type: "textarea"} = assigns) do
    ~H"""
    <div class="fieldset mb-2">
      <label>
        <span :if={@label} class="label mb-1">{@label}</span>
        <textarea
          id={@id}
          name={@name}
          class={[
            @class || "w-full textarea",
            @errors != [] && (@error_class || "textarea-error")
          ]}
          {@rest}
        >{Phoenix.HTML.Form.normalize_value("textarea", @value)}</textarea>
      </label>
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  # All other inputs text, datetime-local, url, password, etc. are handled here...
  def input(assigns) do
    ~H"""
    <div class="fieldset mb-2">
      <label>
        <span :if={@label} class="label mb-1">{@label}</span>
        <input
          type={@type}
          name={@name}
          id={@id}
          value={Phoenix.HTML.Form.normalize_value(@type, @value)}
          class={[
            @class || "w-full input",
            @errors != [] && (@error_class || "input-error")
          ]}
          {@rest}
        />
      </label>
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  # Helper used by inputs to generate form errors
  defp error(assigns) do
    ~H"""
    <p class="mt-1.5 flex gap-2 items-center text-sm text-error">
      <.icon name="hero-exclamation-circle" class="size-5" />
      {render_slot(@inner_block)}
    </p>
    """
  end

  @doc """
  Renders a header with title.
  """
  slot :inner_block, required: true
  slot :subtitle
  slot :actions

  def header(assigns) do
    ~H"""
    <header class={[@actions != [] && "flex items-center justify-between gap-6", "pb-4"]}>
      <div>
        <h1 class="text-lg font-semibold leading-8">
          {render_slot(@inner_block)}
        </h1>
        <p :if={@subtitle != []} class="text-sm text-base-content/70">
          {render_slot(@subtitle)}
        </p>
      </div>
      <div class="flex-none">{render_slot(@actions)}</div>
    </header>
    """
  end

  @doc """
  Renders a table with generic styling.

  ## Examples

      <.table id="users" rows={@users}>
        <:col :let={user} label="id">{user.id}</:col>
        <:col :let={user} label="username">{user.username}</:col>
      </.table>
  """
  attr :id, :string, required: true
  attr :rows, :list, required: true
  attr :row_id, :any, default: nil, doc: "the function for generating the row id"
  attr :row_click, :any, default: nil, doc: "the function for handling phx-click on each row"

  attr :row_item, :any,
    default: &Function.identity/1,
    doc: "the function for mapping each row before calling the :col and :action slots"

  slot :col, required: true do
    attr :label, :string
  end

  slot :action, doc: "the slot for showing user actions in the last table column"

  def table(assigns) do
    assigns =
      with %{rows: %Phoenix.LiveView.LiveStream{}} <- assigns do
        assign(assigns, row_id: assigns.row_id || fn {id, _item} -> id end)
      end

    ~H"""
    <table class="table table-zebra">
      <thead>
        <tr>
          <th :for={col <- @col}>{col[:label]}</th>
          <th :if={@action != []}>
            <span class="sr-only">{gettext("Actions")}</span>
          </th>
        </tr>
      </thead>
      <tbody id={@id} phx-update={is_struct(@rows, Phoenix.LiveView.LiveStream) && "stream"}>
        <tr :for={row <- @rows} id={@row_id && @row_id.(row)}>
          <td
            :for={col <- @col}
            phx-click={@row_click && @row_click.(row)}
            class={@row_click && "hover:cursor-pointer"}
          >
            {render_slot(col, @row_item.(row))}
          </td>
          <td :if={@action != []} class="w-0 font-semibold">
            <div class="flex gap-4">
              <%= for action <- @action do %>
                {render_slot(action, @row_item.(row))}
              <% end %>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
    """
  end

  @doc """
  Renders a data list.

  ## Examples

      <.list>
        <:item title="Title">{@post.title}</:item>
        <:item title="Views">{@post.views}</:item>
      </.list>
  """
  slot :item, required: true do
    attr :title, :string, required: true
  end

  def list(assigns) do
    ~H"""
    <ul class="list">
      <li :for={item <- @item} class="list-row">
        <div class="list-col-grow">
          <div class="font-bold">{item.title}</div>
          <div>{render_slot(item)}</div>
        </div>
      </li>
    </ul>
    """
  end

  @doc """
  Renders a [Heroicon](https://heroicons.com).

  Heroicons come in three styles – outline, solid, and mini.
  By default, the outline style is used, but solid and mini may
  be applied by using the `-solid` and `-mini` suffix.

  You can customize the size and colors of the icons by setting
  width, height, and background color classes.

  Icons are extracted from the `deps/heroicons` directory and bundled within
  your compiled app.css by the plugin in `assets/vendor/heroicons.js`.

  ## Examples

      <.icon name="hero-x-mark" />
      <.icon name="hero-arrow-path" class="ml-1 size-3 motion-safe:animate-spin" />
  """
  attr :name, :string, required: true
  attr :class, :string, default: "size-4"

  def icon(%{name: "hero-" <> _} = assigns) do
    ~H"""
    <span class={[@name, @class]} />
    """
  end

  ## JS Commands

  def show(js \\ %JS{}, selector) do
    JS.show(js,
      to: selector,
      time: 300,
      transition:
        {"transition-all ease-out duration-300",
         "opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95",
         "opacity-100 translate-y-0 sm:scale-100"}
    )
  end

  def hide(js \\ %JS{}, selector) do
    JS.hide(js,
      to: selector,
      time: 200,
      transition:
        {"transition-all ease-in duration-200", "opacity-100 translate-y-0 sm:scale-100",
         "opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"}
    )
  end

  @doc """
  Translates an error message using gettext.
  """
  def translate_error({msg, opts}) do
    # When using gettext, we typically pass the strings we want
    # to translate as a static argument:
    #
    #     # Translate the number of files with plural rules
    #     dngettext("errors", "1 file", "%{count} files", count)
    #
    # However the error messages in our forms and APIs are generated
    # dynamically, so we need to translate them by calling Gettext
    # with our gettext backend as first argument. Translations are
    # available in the errors.po file (as we use the "errors" domain).
    if count = opts[:count] do
      Gettext.dngettext(CollabCanvasWeb.Gettext, "errors", msg, msg, count, opts)
    else
      Gettext.dgettext(CollabCanvasWeb.Gettext, "errors", msg, opts)
    end
  end

  @doc """
  Translates the errors for a field from a keyword list of errors.
  """
  def translate_errors(errors, field) when is_list(errors) do
    for {^field, {msg, opts}} <- errors, do: translate_error({msg, opts})
  end
end
</file>

<file path="lib/collab_canvas_web/components/layouts.ex">
defmodule CollabCanvasWeb.Layouts do
  @moduledoc """
  This module holds layouts and related functionality
  used by your application.
  """
  use CollabCanvasWeb, :html

  # Embed all files in layouts/* within this module.
  # The default root.html.heex file contains the HTML
  # skeleton of your application, namely HTML headers
  # and other static content.
  embed_templates "layouts/*"

  @doc """
  Renders your app layout.

  This function is typically invoked from every template,
  and it often contains your application menu, sidebar,
  or similar.

  ## Examples

      <Layouts.app flash={@flash}>
        <h1>Content</h1>
      </Layouts.app>

  """
  attr :flash, :map, required: true, doc: "the map of flash messages"

  attr :current_scope, :map,
    default: nil,
    doc: "the current [scope](https://hexdocs.pm/phoenix/scopes.html)"

  slot :inner_block, required: true

  def app(assigns) do
    ~H"""
    <header class="navbar px-4 sm:px-6 lg:px-8">
      <div class="flex-1">
        <a href="/" class="flex-1 flex w-fit items-center gap-2">
          <img src={~p"/images/logo.svg"} width="36" />
          <span class="text-sm font-semibold">v{Application.spec(:phoenix, :vsn)}</span>
        </a>
      </div>
      <div class="flex-none">
        <ul class="flex flex-column px-1 space-x-4 items-center">
          <li>
            <a href="https://phoenixframework.org/" class="btn btn-ghost">Website</a>
          </li>
          <li>
            <a href="https://github.com/phoenixframework/phoenix" class="btn btn-ghost">GitHub</a>
          </li>
          <li>
            <.theme_toggle />
          </li>
          <li>
            <a href="https://hexdocs.pm/phoenix/overview.html" class="btn btn-primary">
              Get Started <span aria-hidden="true">&rarr;</span>
            </a>
          </li>
        </ul>
      </div>
    </header>

    <main class="px-4 py-20 sm:px-6 lg:px-8">
      <div class="mx-auto max-w-2xl space-y-4">
        {render_slot(@inner_block)}
      </div>
    </main>

    <.flash_group flash={@flash} />
    """
  end

  @doc """
  Shows the flash group with standard titles and content.

  ## Examples

      <.flash_group flash={@flash} />
  """
  attr :flash, :map, required: true, doc: "the map of flash messages"
  attr :id, :string, default: "flash-group", doc: "the optional id of flash container"

  def flash_group(assigns) do
    ~H"""
    <div id={@id} aria-live="polite">
      <.flash kind={:info} flash={@flash} />
      <.flash kind={:error} flash={@flash} />

      <.flash
        id="client-error"
        kind={:error}
        title={gettext("We can't find the internet")}
        phx-disconnected={show(".phx-client-error #client-error") |> JS.remove_attribute("hidden")}
        phx-connected={hide("#client-error") |> JS.set_attribute({"hidden", ""})}
        hidden
      >
        {gettext("Attempting to reconnect")}
        <.icon name="hero-arrow-path" class="ml-1 size-3 motion-safe:animate-spin" />
      </.flash>

      <.flash
        id="server-error"
        kind={:error}
        title={gettext("Something went wrong!")}
        phx-disconnected={show(".phx-server-error #server-error") |> JS.remove_attribute("hidden")}
        phx-connected={hide("#server-error") |> JS.set_attribute({"hidden", ""})}
        hidden
      >
        {gettext("Attempting to reconnect")}
        <.icon name="hero-arrow-path" class="ml-1 size-3 motion-safe:animate-spin" />
      </.flash>
    </div>
    """
  end

  @doc """
  Provides dark vs light theme toggle based on themes defined in app.css.

  See <head> in root.html.heex which applies the theme before page load.
  """
  def theme_toggle(assigns) do
    ~H"""
    <div class="card relative flex flex-row items-center border-2 border-base-300 bg-base-300 rounded-full">
      <div class="absolute w-1/3 h-full rounded-full border-1 border-base-200 bg-base-100 brightness-200 left-0 [[data-theme=light]_&]:left-1/3 [[data-theme=dark]_&]:left-2/3 transition-[left]" />

      <button
        class="flex p-2 cursor-pointer w-1/3"
        phx-click={JS.dispatch("phx:set-theme")}
        data-phx-theme="system"
      >
        <.icon name="hero-computer-desktop-micro" class="size-4 opacity-75 hover:opacity-100" />
      </button>

      <button
        class="flex p-2 cursor-pointer w-1/3"
        phx-click={JS.dispatch("phx:set-theme")}
        data-phx-theme="light"
      >
        <.icon name="hero-sun-micro" class="size-4 opacity-75 hover:opacity-100" />
      </button>

      <button
        class="flex p-2 cursor-pointer w-1/3"
        phx-click={JS.dispatch("phx:set-theme")}
        data-phx-theme="dark"
      >
        <.icon name="hero-moon-micro" class="size-4 opacity-75 hover:opacity-100" />
      </button>
    </div>
    """
  end
end
</file>

<file path="lib/collab_canvas_web/controllers/page_html/home.html.heex">
<Layouts.flash_group flash={@flash} />

<div class="min-h-screen bg-gradient-to-br from-indigo-100 via-white to-purple-100">
  <div class="container mx-auto px-4 py-8">
    <!-- Header -->
    <header class="flex justify-between items-center mb-12">
      <h1 class="text-4xl font-bold text-gray-900">CollabCanvas</h1>

      <%= if assigns[:current_user] do %>
        <div class="flex items-center gap-4">
          <span class="text-gray-700">
            Welcome, <strong><%= @current_user.name || @current_user.email %></strong>
          </span>
          <%= if @current_user.avatar do %>
            <img src={@current_user.avatar} alt="Avatar" class="w-10 h-10 rounded-full" />
          <% end %>
          <a
            href="/auth/logout"
            class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition"
          >
            Logout
          </a>
          <a
            href="/dashboard"
            class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition"
          >
            Go to Dashboard
          </a>
        </div>
      <% else %>
        <a
          href="/auth/auth0"
          class="px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold"
        >
          Login with Auth0
        </a>
      <% end %>
    </header>

    <!-- Hero Section -->
    <div class="text-center py-16">
      <h2 class="text-5xl font-bold text-gray-900 mb-6">
        Real-time Collaborative Canvas
      </h2>
      <p class="text-xl text-gray-600 mb-8 max-w-2xl mx-auto">
        Create, collaborate, and bring your ideas to life with AI-powered design tools.
        Work together in real-time with your team.
      </p>

      <%= if !assigns[:current_user] do %>
        <a
          href="/auth/auth0"
          class="inline-block px-8 py-4 bg-indigo-600 text-white text-lg rounded-lg hover:bg-indigo-700 transition font-semibold shadow-lg"
        >
          Get Started
        </a>
      <% end %>
    </div>

    <!-- Features Section -->
    <div class="grid md:grid-cols-3 gap-8 mt-16">
      <div class="bg-white p-8 rounded-xl shadow-md">
        <div class="text-4xl mb-4">🎨</div>
        <h3 class="text-2xl font-bold mb-3">Real-time Collaboration</h3>
        <p class="text-gray-600">
          See your team's cursors and changes in real-time. Work together seamlessly
          on the same canvas.
        </p>
      </div>

      <div class="bg-white p-8 rounded-xl shadow-md">
        <div class="text-4xl mb-4">🤖</div>
        <h3 class="text-2xl font-bold mb-3">AI-Powered Design</h3>
        <p class="text-gray-600">
          Use natural language to create shapes, layouts, and complex designs.
          Let AI be your design assistant.
        </p>
      </div>

      <div class="bg-white p-8 rounded-xl shadow-md">
        <div class="text-4xl mb-4">⚡</div>
        <h3 class="text-2xl font-bold mb-3">High Performance</h3>
        <p class="text-gray-600">
          Built with Phoenix LiveView and PixiJS for smooth, responsive
          real-time rendering and interaction.
        </p>
      </div>
    </div>

    <!-- Quick Start Section -->
    <%= if assigns[:current_user] do %>
      <div class="mt-16 bg-white p-8 rounded-xl shadow-lg">
        <h3 class="text-3xl font-bold mb-4">Quick Start</h3>
        <p class="text-gray-600 mb-6">
          Head to your dashboard to create a new canvas or open an existing one.
        </p>
        <a
          href="/dashboard"
          class="inline-block px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold"
        >
          Open Dashboard →
        </a>
      </div>
    <% end %>
  </div>
</div>
</file>

<file path="lib/collab_canvas_web/controllers/auth_controller.ex">
defmodule CollabCanvasWeb.AuthController do
  @moduledoc """
  Handles authentication and authorization using Auth0 via Ueberauth.

  This controller manages the complete OAuth 2.0 authentication flow with Auth0:

  ## Authentication Flow

  1. User clicks login and is redirected to `/auth/auth0` (handled by `request/2`)
  2. Ueberauth redirects the user to Auth0's login page
  3. User authenticates with Auth0 (email/password, social login, etc.)
  4. Auth0 redirects back to `/auth/auth0/callback` with authorization code
  5. Ueberauth exchanges the code for user information
  6. `callback/2` processes the auth response:
     - On success: Creates or retrieves user from database
     - Stores user information in session
     - Redirects to home page
     - On failure: Shows error message and redirects to home page

  ## User Management

  The controller interacts with the `CollabCanvas.Accounts` context to:
  - Find existing users by provider and provider_uid
  - Create new user records for first-time logins
  - Store user profile information (email, name, avatar)

  ## Session Management

  User sessions are managed via Phoenix sessions:
  - `user_id`: Primary key of the authenticated user
  - `user_email`: User's email address for quick access
  - `user_name`: User's display name for quick access
  - Sessions are renewed on successful authentication for security
  - Sessions are completely dropped on logout

  ## Configuration

  Requires Ueberauth and Ueberauth Auth0 strategy to be configured in `config.exs`:
  - Auth0 domain
  - Auth0 client ID
  - Auth0 client secret
  - Callback URL
  """
  use CollabCanvasWeb, :controller
  plug Ueberauth

  alias CollabCanvas.Accounts

  @doc """
  Initiates the OAuth 2.0 authentication flow with Auth0.

  This function is called when a user visits `/auth/auth0`. The Ueberauth plug
  intercepts this request and automatically redirects the user to Auth0's
  authorization page where they can log in.

  ## Parameters

    - `conn` - The Phoenix connection struct
    - `_params` - Request parameters (unused, handled by Ueberauth)

  ## Returns

  The connection struct. The actual redirect is handled by the Ueberauth plug.

  ## Example Route

      get "/auth/:provider", AuthController, :request
  """
  def request(conn, _params) do
    # Ueberauth handles the redirect
    conn
  end

  @doc """
  Handles the OAuth callback from Auth0 after authentication attempt.

  This function has two clauses to handle success and failure cases:

  ## Failure Case

  When authentication fails (wrong credentials, user cancels, etc.), Ueberauth
  assigns `ueberauth_failure` to the connection. This clause catches that and
  displays an error message to the user.

  ## Success Case

  When authentication succeeds, Ueberauth assigns `ueberauth_auth` to the connection
  containing the user's profile information from Auth0. This clause:

  1. Extracts user information (email, name, avatar, provider details)
  2. Calls `Accounts.find_or_create_user/1` to get or create the user record
  3. On success: Stores user info in session and redirects to home page
  4. On error: Shows error message and redirects to home page

  ## Parameters

    - `conn` - The Phoenix connection struct with Ueberauth assigns
    - `_params` - Request parameters (unused)

  ## Returns

  A connection struct with flash message and redirect.

  ## Example Route

      get "/auth/:provider/callback", AuthController, :callback

  ## Session Data Stored

    - `user_id` - Database ID of the authenticated user
    - `user_email` - User's email address
    - `user_name` - User's display name
  """
  def callback(%{assigns: %{ueberauth_failure: _fails}} = conn, _params) do
    conn
    |> put_flash(:error, "Failed to authenticate.")
    |> redirect(to: "/")
  end

  def callback(%{assigns: %{ueberauth_auth: auth}} = conn, _params) do
    # Extract user information from Auth0
    user_params = %{
      email: auth.info.email,
      name: auth.info.name,
      avatar: auth.info.image,
      provider: "auth0",
      provider_uid: auth.uid
    }

    case Accounts.find_or_create_user(user_params) do
      {:ok, user} ->
        conn
        |> put_flash(:info, "Successfully authenticated!")
        |> put_session(:user_id, user.id)
        |> put_session(:user_email, user.email)
        |> put_session(:user_name, user.name)
        |> configure_session(renew: true)
        |> redirect(to: "/")

      {:error, _reason} ->
        conn
        |> put_flash(:error, "Failed to create user account.")
        |> redirect(to: "/")
    end
  end

  @doc """
  Logs out the currently authenticated user.

  This function terminates the user's session by completely dropping all session
  data. This includes user_id, user_email, and user_name. The user is then
  redirected to the home page with a confirmation message.

  Note: This only clears the application session. If using Auth0's Single Sign-On
  (SSO), the user may still be logged into Auth0 and could be automatically
  re-authenticated if they visit the login page again. For complete logout,
  consider redirecting to Auth0's logout endpoint.

  ## Parameters

    - `conn` - The Phoenix connection struct
    - `_params` - Request parameters (unused)

  ## Returns

  A connection struct with the session dropped, a flash message, and redirect to home.

  ## Example Route

      get "/auth/logout", AuthController, :logout
      delete "/auth/logout", AuthController, :logout
  """
  def logout(conn, _params) do
    conn
    |> configure_session(drop: true)
    |> put_flash(:info, "You have been logged out.")
    |> redirect(to: "/")
  end
end
</file>

<file path="lib/collab_canvas_web/controllers/error_html.ex">
defmodule CollabCanvasWeb.ErrorHTML do
  @moduledoc """
  This module is invoked by your endpoint in case of errors on HTML requests.

  See config/config.exs.
  """
  use CollabCanvasWeb, :html

  # If you want to customize your error pages,
  # uncomment the embed_templates/1 call below
  # and add pages to the error directory:
  #
  #   * lib/collab_canvas_web/controllers/error_html/404.html.heex
  #   * lib/collab_canvas_web/controllers/error_html/500.html.heex
  #
  # embed_templates "error_html/*"

  # The default is to render a plain text page based on
  # the template name. For example, "404.html" becomes
  # "Not Found".
  def render(template, _assigns) do
    Phoenix.Controller.status_message_from_template(template)
  end
end
</file>

<file path="lib/collab_canvas_web/controllers/error_json.ex">
defmodule CollabCanvasWeb.ErrorJSON do
  @moduledoc """
  This module is invoked by your endpoint in case of errors on JSON requests.

  See config/config.exs.
  """

  # If you want to customize a particular status code,
  # you may add your own clauses, such as:
  #
  # def render("500.json", _assigns) do
  #   %{errors: %{detail: "Internal Server Error"}}
  # end

  # By default, Phoenix returns the status message from
  # the template name. For example, "404.json" becomes
  # "Not Found".
  def render(template, _assigns) do
    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}
  end
end
</file>

<file path="lib/collab_canvas_web/controllers/health_controller.ex">
defmodule CollabCanvasWeb.HealthController do
  use CollabCanvasWeb, :controller

  def index(conn, _params) do
    # Check database connectivity
    case Ecto.Adapters.SQL.query(CollabCanvas.Repo, "SELECT 1", []) do
      {:ok, _} ->
        conn
        |> put_status(:ok)
        |> json(%{status: "ok", database: "connected"})

      {:error, _} ->
        conn
        |> put_status(:service_unavailable)
        |> json(%{status: "error", database: "disconnected"})
    end
  end
end
</file>

<file path="lib/collab_canvas_web/controllers/page_controller.ex">
defmodule CollabCanvasWeb.PageController do
  use CollabCanvasWeb, :controller

  plug CollabCanvasWeb.Plugs.Auth, :load_current_user when action in [:home]

  def home(conn, _params) do
    render(conn, :home)
  end
end
</file>

<file path="lib/collab_canvas_web/controllers/page_html.ex">
defmodule CollabCanvasWeb.PageHTML do
  @moduledoc """
  This module contains pages rendered by PageController.

  See the `page_html` directory for all templates available.
  """
  use CollabCanvasWeb, :html

  embed_templates "page_html/*"
end
</file>

<file path="lib/collab_canvas_web/live/canvas_live.ex">
defmodule CollabCanvasWeb.CanvasLive do
  @moduledoc """
  LiveView for real-time collaborative canvas editing.

  This module provides a complete collaborative drawing canvas with real-time
  synchronization across multiple users. It combines Phoenix LiveView for
  server-side rendering with Phoenix PubSub for real-time updates, and
  Phoenix Presence for user tracking.

  ## Features

  ### Real-time Collaboration
  - Multiple users can edit the same canvas simultaneously
  - Changes are broadcast instantly to all connected clients via PubSub
  - Local state updates are optimized for immediate UI feedback
  - Prevents duplicate updates when the originating client receives broadcasts

  ### Canvas State Management
  - Maintains synchronized state of canvas objects (rectangles, circles, text)
  - Handles object creation, updates, and deletion with database persistence
  - Tracks object positions and properties (color, size, text content, etc.)
  - Objects are stored in the database and cached in LiveView assigns

  ### PubSub Architecture
  - Each canvas has a dedicated PubSub topic: "canvas:<canvas_id>"
  - Broadcasts three types of events: object_created, object_updated, object_deleted
  - All connected clients subscribe to their canvas topic on mount
  - Events are pushed to JavaScript via push_event for client-side rendering

  ### User Presence Tracking
  - Tracks all users currently viewing the canvas
  - Each user gets a unique color for visual identification
  - Real-time cursor position tracking shows where other users are pointing
  - Presence metadata includes: online_at, cursor position, color, name, email
  - Automatic cleanup when users disconnect

  ### AI-Powered Object Generation
  - Natural language commands to create objects: "Create a blue rectangle"
  - Async implementation using Task.async to prevent blocking the UI
  - 30-second timeout protection with graceful error handling
  - AI-generated objects are validated and broadcast to all clients
  - Uses Claude API (Anthropic) for command interpretation
  - Prevents duplicate AI requests while one is in progress

  ### Tool System
  - Multiple drawing tools: select, rectangle, circle, text, delete
  - Tool state is synchronized between server and client
  - Keyboard shortcuts for quick tool switching (S, R, C, T, D)
  - Tool selection is pushed to JavaScript hooks for client-side handling

  ## State Management

  The socket assigns include:
  - `:canvas` - The canvas struct with metadata
  - `:canvas_id` - Canvas identifier for PubSub topic
  - `:objects` - List of all canvas objects (synchronized)
  - `:user_id` - Unique identifier for the current user
  - `:topic` - PubSub topic string for this canvas
  - `:presences` - Map of all connected users and their metadata
  - `:selected_tool` - Currently active drawing tool
  - `:ai_command` - Current AI command text
  - `:ai_loading` - Boolean indicating AI processing state
  - `:ai_task_ref` - Reference to async AI task for monitoring

  ## Event Flow

  1. User performs action (e.g., creates object)
  2. Client sends event to LiveView via handle_event/3
  3. LiveView persists change to database
  4. LiveView broadcasts change to PubSub topic
  5. All connected clients (including originator) receive broadcast via handle_info/2
  6. Each client updates local state and pushes to JavaScript
  7. JavaScript hook updates the PixiJS canvas rendering

  ## Error Handling

  - Database operations return {:ok, result} or {:error, reason}
  - Errors are displayed to users via flash messages
  - AI tasks have timeout protection and crash recovery
  - Presence tracking is automatically cleaned up on disconnect
  """

  use CollabCanvasWeb, :live_view

  alias CollabCanvas.Canvases
  alias CollabCanvas.ColorPalettes
  alias CollabCanvas.AI.Agent
  alias CollabCanvasWeb.Presence
  alias CollabCanvasWeb.Plugs.Auth

  require Logger

  @doc """
  Mounts the LiveView and initializes the collaborative canvas session.

  ## Responsibilities

  1. Authenticates the user from session data
  2. Loads canvas data with associated objects from database
  3. Subscribes to canvas-specific PubSub topic for real-time updates
  4. Tracks user presence with cursor metadata
  5. Initializes socket assigns for canvas state

  ## Parameters

  - `params` - Map containing the canvas ID in the "id" key
  - `session` - Session data containing authentication information
  - `socket` - The LiveView socket

  ## Returns

  - `{:ok, socket}` - Successfully mounted with initialized state
  - `{:ok, socket}` - Redirects to home if canvas not found or user not authenticated

  ## Side Effects

  - Subscribes to PubSub topic "canvas:\#{canvas_id}"
  - Tracks user presence in Phoenix Presence
  - Assigns random color to user for cursor display
  """
  @impl true
  def mount(%{"id" => canvas_id}, session, socket) do
    # Load authenticated user
    socket = Auth.assign_current_user(socket, session)

    # Convert canvas_id to integer
    canvas_id = String.to_integer(canvas_id)

    # Load canvas data
    canvas = Canvases.get_canvas_with_preloads(canvas_id, [:objects])

    if canvas && socket.assigns.current_user do
      # Subscribe to canvas-specific PubSub topic for real-time updates
      topic = "canvas:#{canvas_id}"
      Phoenix.PubSub.subscribe(CollabCanvas.PubSub, topic)

      # Use authenticated user information
      user = socket.assigns.current_user
      user_id = "user_#{user.id}"

      # Track user presence (cursor will be set when user first moves mouse)
      # Handle both success and already_tracked cases (can happen on page reload)
      case Presence.track(self(), topic, user_id, %{
          online_at: System.system_time(:second),
          cursor: nil,
          color: generate_user_color(),
          name: user.name || user.email,
          email: user.email
        }) do
        {:ok, _} -> :ok
        {:error, {:already_tracked, _, _, _}} -> :ok
      end

      # Load user's saved viewport position for this canvas
      viewport = Canvases.get_viewport(user.id, canvas_id)

      # Initialize socket state
      socket =
        socket
        |> assign(:canvas, canvas)
        |> assign(:canvas_id, canvas_id)
        |> assign(:objects, canvas.objects)
        |> assign(:user_id, user_id)
        |> assign(:topic, topic)
        |> assign(:presences, %{})
        |> assign(:selected_tool, "select")
        |> assign(:ai_command, "")
        |> assign(:ai_loading, false)
        |> assign(:ai_task_ref, nil)
        |> assign(:show_labels, false)
        |> assign(:current_color, ColorPalettes.get_default_color(user.id))
        |> assign(:show_color_picker, false)

      # If viewport position exists, push it to the client to restore position
      socket =
        if viewport do
          push_event(socket, "restore_viewport", %{
            x: viewport.viewport_x,
            y: viewport.viewport_y,
            zoom: viewport.zoom
          })
        else
          socket
        end

      {:ok, socket}
    else
      # Canvas not found or user not authenticated
      {:ok,
       socket
       |> put_flash(:error, "Canvas not found or you must be logged in")
       |> redirect(to: "/")}
    end
  end

  @doc false
  # Helper function to generate a random color for user cursors
  # Returns one of 8 predefined colors for visual distinction between users
  defp generate_user_color do
    colors = [
      "#3b82f6",
      "#ef4444",
      "#10b981",
      "#f59e0b",
      "#8b5cf6",
      "#ec4899",
      "#06b6d4",
      "#84cc16"
    ]

    Enum.random(colors)
  end

  @doc """
  Handles object creation events from the client.

  Creates a new canvas object (rectangle, circle, text, etc.) and broadcasts
  the change to all connected clients. The object is persisted to the database
  and immediately pushed to the JavaScript client for optimistic UI updates.

  ## Parameters

  - `params` - Map containing:
    - "type" - Object type (e.g., "rectangle", "circle", "text")
    - "position" - Map with x, y coordinates (optional, defaults to {100, 100})
    - "data" - Object-specific data (color, size, text, etc.) as JSON or map

  ## Broadcast

  Sends `{:object_created, object}` to PubSub topic for all clients to receive.

  ## Returns

  `{:noreply, socket}` with updated objects list or error flash message.
  """
  @impl true
  def handle_event("create_object", %{"type" => type} = params, socket) do
    canvas_id = socket.assigns.canvas_id

    # Extract object attributes and convert data to JSON string if it's a map
    data =
      case params["data"] do
        data when is_map(data) and data != %{} -> Jason.encode!(data)
        data when is_binary(data) -> data
        _ -> nil
      end

    attrs = %{
      position: params["position"] || %{x: 100, y: 100},
      data: data
    }

    case Canvases.create_object(canvas_id, type, attrs) do
      {:ok, object} ->
        # Broadcast to all connected clients (including other browser tabs)
        Phoenix.PubSub.broadcast(
          CollabCanvas.PubSub,
          socket.assigns.topic,
          {:object_created, object}
        )

        # Update local state and push to JavaScript immediately
        {:noreply,
         socket
         |> assign(:objects, [object | socket.assigns.objects])
         |> push_event("object_created", %{object: object})}

      {:error, _changeset} ->
        {:noreply, put_flash(socket, :error, "Failed to create object")}
    end
  end

  @doc """
  Handles object selection events from the client.

  Locks an object for editing when a user selects it, preventing other users
  from modifying it simultaneously.

  ## Parameters

  - `params` - Map containing:
    - "object_id" or "id" - ID of object to lock

  ## Broadcast

  Sends `{:object_locked, object}` to PubSub topic for all clients to receive.

  ## Returns

  `{:noreply, socket}` with locked object or error flash message.
  """
  @impl true
  def handle_event("lock_object", params, socket) do
    # Extract object_id from params (could be "id" or "object_id")
    object_id = params["object_id"] || params["id"]

    # Convert string ID to integer if needed
    object_id = if is_binary(object_id), do: String.to_integer(object_id), else: object_id

    user_id = socket.assigns.user_id

    case Canvases.lock_object(object_id, user_id) do
      {:ok, locked_object} ->
        # Broadcast to all connected clients
        Phoenix.PubSub.broadcast(
          CollabCanvas.PubSub,
          socket.assigns.topic,
          {:object_locked, locked_object}
        )

        # Update local state
        objects =
          Enum.map(socket.assigns.objects, fn obj ->
            if obj.id == locked_object.id, do: locked_object, else: obj
          end)

        {:noreply,
         socket
         |> assign(:objects, objects)
         |> push_event("object_locked", %{object: locked_object})}

      {:error, :already_locked} ->
        {:noreply, put_flash(socket, :error, "Object is currently being edited by another user")}

      {:error, :not_found} ->
        {:noreply, put_flash(socket, :error, "Object not found")}
    end
  end

  @doc """
  Handles object deselection events from the client.

  Unlocks an object when a user deselects it, allowing other users to edit it.

  ## Parameters

  - `params` - Map containing:
    - "object_id" or "id" - ID of object to unlock

  ## Broadcast

  Sends `{:object_unlocked, object}` to PubSub topic for all clients to receive.

  ## Returns

  `{:noreply, socket}` with unlocked object.
  """
  @impl true
  def handle_event("unlock_object", params, socket) do
    # Extract object_id from params (could be "id" or "object_id")
    object_id = params["object_id"] || params["id"]

    # Convert string ID to integer if needed
    object_id = if is_binary(object_id), do: String.to_integer(object_id), else: object_id

    user_id = socket.assigns.user_id

    case Canvases.unlock_object(object_id, user_id) do
      {:ok, unlocked_object} ->
        # Broadcast to all connected clients
        Phoenix.PubSub.broadcast(
          CollabCanvas.PubSub,
          socket.assigns.topic,
          {:object_unlocked, unlocked_object}
        )

        # Update local state
        objects =
          Enum.map(socket.assigns.objects, fn obj ->
            if obj.id == unlocked_object.id, do: unlocked_object, else: obj
          end)

        {:noreply,
         socket
         |> assign(:objects, objects)
         |> push_event("object_unlocked", %{object: unlocked_object})}

      {:error, :not_locked_by_user} ->
        # Object was locked by someone else, but we still want to unlock it
        # This handles cases where the locking user disconnected
        case Canvases.unlock_object(object_id) do
          {:ok, unlocked_object} ->
            Phoenix.PubSub.broadcast(
              CollabCanvas.PubSub,
              socket.assigns.topic,
              {:object_unlocked, unlocked_object}
            )

            objects =
              Enum.map(socket.assigns.objects, fn obj ->
                if obj.id == unlocked_object.id, do: unlocked_object, else: obj
              end)

            {:noreply,
             socket
             |> assign(:objects, objects)
             |> push_event("object_unlocked", %{object: unlocked_object})}

          _ ->
            {:noreply, socket}
        end

      _ ->
        {:noreply, socket}
    end
  end

  @doc """
  Handles object update events from the client.

  Updates an existing canvas object's position or data properties and broadcasts
  the change to all connected clients. Common for drag operations and property
  changes.

  ## Parameters

  - `params` - Map containing:
    - "object_id" or "id" - ID of object to update
    - "position" - New position map with x, y coordinates (optional)
    - "data" - Updated object data as JSON or map (optional)

  ## Broadcast

  Sends `{:object_updated, object}` to PubSub topic for all clients to receive.

  ## Returns

  `{:noreply, socket}` with updated objects list or error flash message.
  """
  @impl true
  def handle_event("update_object", params, socket) do
    # Extract object_id from params (could be "id" or "object_id")
    object_id = params["object_id"] || params["id"]

    # Convert string ID to integer if needed
    object_id = if is_binary(object_id), do: String.to_integer(object_id), else: object_id

    user_id = socket.assigns.user_id

    # Check if object is locked by another user
    case Canvases.check_lock(object_id) do
      {:locked, locked_by} when locked_by != user_id ->
        {:noreply, put_flash(socket, :error, "Object is currently being edited by another user")}

      {:error, :not_found} ->
        {:noreply, put_flash(socket, :error, "Object not found")}

      _ ->
        # Object is unlocked or locked by current user, proceed with update
        # Extract update attributes and convert data to JSON string if it's a map
        data =
          case params["data"] do
            data when is_map(data) and data != %{} -> Jason.encode!(data)
            data when is_binary(data) -> data
            nil -> nil
          end

        attrs =
          %{
            position: params["position"],
            data: data
          }
          |> Enum.reject(fn {_k, v} -> is_nil(v) end)
          |> Map.new()

        case Canvases.update_object(object_id, attrs) do
          {:ok, updated_object} ->
            # Broadcast to all connected clients
            Phoenix.PubSub.broadcast(
              CollabCanvas.PubSub,
              socket.assigns.topic,
              {:object_updated, updated_object}
            )

            # Update local state and push to JavaScript immediately
            objects =
              Enum.map(socket.assigns.objects, fn obj ->
                if obj.id == updated_object.id, do: updated_object, else: obj
              end)

            {:noreply,
             socket
             |> assign(:objects, objects)
             |> push_event("object_updated", %{object: updated_object})}

          {:error, :not_found} ->
            {:noreply, put_flash(socket, :error, "Object not found")}

          {:error, _changeset} ->
            {:noreply, put_flash(socket, :error, "Failed to update object")}
        end
    end
  end

  @doc """
  Handles batch object update events from the client (for multi-object dragging).

  Updates multiple canvas objects in a single database transaction and broadcasts
  the changes to all connected clients. This is more efficient than individual
  updates when dragging multiple selected objects.

  ## Parameters

  - `params` - Map containing:
    - "updates" - List of update maps, each containing:
      - "object_id" or "id" - ID of object to update
      - "position" - New position map with x, y coordinates

  ## Broadcast

  Sends `{:objects_updated_batch, updated_objects}` to PubSub topic for all clients to receive.

  ## Transaction

  All updates are performed in a single database transaction for atomicity.
  If any update fails, all updates are rolled back.

  ## Returns

  `{:noreply, socket}` with updated objects list or error flash message.
  """
  @impl true
  def handle_event("update_objects_batch", %{"updates" => updates}, socket) when is_list(updates) do
    user_id = socket.assigns.user_id

    # Execute all updates in a transaction
    result = CollabCanvas.Repo.transaction(fn ->
      Enum.map(updates, fn update_params ->
        # Extract object_id from params
        object_id = update_params["object_id"] || update_params["id"]
        object_id = if is_binary(object_id), do: String.to_integer(object_id), else: object_id

        # Check if object is locked by another user
        case Canvases.check_lock(object_id) do
          {:locked, locked_by} when locked_by != user_id ->
            CollabCanvas.Repo.rollback({:error, :locked_by_another_user, object_id})

          {:error, :not_found} ->
            CollabCanvas.Repo.rollback({:error, :not_found, object_id})

          _ ->
            # Object is unlocked or locked by current user, proceed with update
            attrs = %{position: update_params["position"]}

            case Canvases.update_object(object_id, attrs) do
              {:ok, updated_object} -> updated_object
              {:error, :not_found} -> CollabCanvas.Repo.rollback({:error, :not_found, object_id})
              {:error, _changeset} -> CollabCanvas.Repo.rollback({:error, :update_failed, object_id})
            end
        end
      end)
    end)

    case result do
      {:ok, updated_objects} ->
        # Broadcast to all connected clients
        Phoenix.PubSub.broadcast(
          CollabCanvas.PubSub,
          socket.assigns.topic,
          {:objects_updated_batch, updated_objects}
        )

        # Update local state
        updated_ids = MapSet.new(updated_objects, & &1.id)
        objects =
          Enum.map(socket.assigns.objects, fn obj ->
            if MapSet.member?(updated_ids, obj.id) do
              Enum.find(updated_objects, obj, fn updated -> updated.id == obj.id end)
            else
              obj
            end
          end)

        # Push batch update to JavaScript
        {:noreply,
         socket
         |> assign(:objects, objects)
         |> push_event("objects_updated_batch", %{objects: updated_objects})}

      {:error, {error_type, object_id}} ->
        message = case error_type do
          :locked_by_another_user -> "Object #{object_id} is locked by another user"
          :not_found -> "Object #{object_id} not found"
          :update_failed -> "Failed to update object #{object_id}"
          _ -> "Batch update failed"
        end
        {:noreply, put_flash(socket, :error, message)}

      {:error, _reason} ->
        {:noreply, put_flash(socket, :error, "Batch update failed")}
    end
  end

  @doc """
  Handles object deletion events from the client.

  Deletes a canvas object from the database and broadcasts the deletion to all
  connected clients for immediate removal from their canvases.

  ## Parameters

  - `params` - Map containing:
    - "object_id" or "id" - ID of object to delete

  ## Broadcast

  Sends `{:object_deleted, object_id}` to PubSub topic for all clients to receive.

  ## Returns

  `{:noreply, socket}` with updated objects list or error flash message.
  """
  @impl true
  def handle_event("delete_object", params, socket) do
    # Extract object_id from params (could be "id" or "object_id")
    object_id = params["object_id"] || params["id"]

    # Convert string ID to integer if needed
    object_id = if is_binary(object_id), do: String.to_integer(object_id), else: object_id

    user_id = socket.assigns.user_id

    # Check if object is locked by another user
    case Canvases.check_lock(object_id) do
      {:locked, locked_by} when locked_by != user_id ->
        {:noreply, put_flash(socket, :error, "Object is currently being edited by another user")}

      {:error, :not_found} ->
        {:noreply, put_flash(socket, :error, "Object not found")}

      _ ->
        # Object is unlocked or locked by current user, proceed with deletion
        case Canvases.delete_object(object_id) do
          {:ok, _deleted_object} ->
            # Broadcast to all connected clients
            Phoenix.PubSub.broadcast(
              CollabCanvas.PubSub,
              socket.assigns.topic,
              {:object_deleted, object_id}
            )

            # Update local state and push to JavaScript immediately
            objects = Enum.reject(socket.assigns.objects, fn obj -> obj.id == object_id end)

            {:noreply,
             socket
             |> assign(:objects, objects)
             |> push_event("object_deleted", %{object_id: object_id})}

          {:error, :not_found} ->
            {:noreply, put_flash(socket, :error, "Object not found")}
        end
    end
  end

  @doc """
  Handles AI command input changes from the client.

  Updates the AI command text in socket assigns as the user types in the
  AI assistant textarea. This maintains form state across renders.

  ## Parameters

  - `params` - Map containing "value" key with current command text

  ## Returns

  `{:noreply, socket}` with updated ai_command assign.
  """
  @impl true
  def handle_event("ai_command_change", %{"value" => command}, socket) do
    {:noreply, assign(socket, :ai_command, command)}
  end

  @doc """
  Handles AI command execution requests from the client (async, non-blocking).

  Spawns an async task to process the natural language command using Claude API.
  The task runs in the background and results are handled by handle_info/2 callbacks.
  Includes duplicate request prevention and 30-second timeout protection.

  ## Parameters

  - `params` - Map containing:
    - "command" - Natural language instruction
    - "selected_ids" - Optional list of selected object IDs for context

  ## Async Processing

  1. Spawns Task.async to call Agent.execute_command/3
  2. Sets 30-second timeout with Process.send_after/3
  3. Task completion handled by handle_info({ref, result}, socket)
  4. Task crash handled by handle_info({:DOWN, ref, ...}, socket)
  5. Timeout handled by handle_info({:ai_timeout, ref}, socket)

  ## Returns

  `{:noreply, socket}` with ai_loading=true and ai_task_ref set, or warning
  flash if a command is already in progress.

  ## Example Commands

  - "Create a blue rectangle"
  - "Add a green circle"
  - "Arrange selected objects horizontally"
  - "Align these objects to the top"
  """
  @impl true
  def handle_event("execute_ai_command", params, socket) do
    command = params["command"]
    selected_ids = Map.get(params, "selected_ids", [])

    # Prevent duplicate AI commands while one is in progress
    if socket.assigns.ai_loading do
      {:noreply, put_flash(socket, :warning, "AI command already in progress, please wait...")}
    else
      canvas_id = socket.assigns.canvas_id

      # Start async task with timeout (Task.async automatically links to current process)
      current_color = socket.assigns.current_color
      task =
        Task.async(fn ->
          Agent.execute_command(command, canvas_id, selected_ids, current_color: current_color)
        end)

      # Set loading state and store task reference for timeout monitoring
      Process.send_after(self(), {:ai_timeout, task.ref}, 30_000)

      {:noreply,
       socket
       |> assign(:ai_loading, true)
       |> assign(:ai_task_ref, task.ref)
       |> clear_flash()}
    end
  end

  @doc """
  Handles tool selection events from the client.

  Updates the currently selected drawing tool and pushes the selection to
  JavaScript hooks for client-side behavior changes (cursor style, click handlers).

  ## Parameters

  - `params` - Map containing "tool" key with tool name

  ## Available Tools

  - "select" - Selection and move tool (keyboard: S)
  - "rectangle" - Rectangle drawing tool (keyboard: R)
  - "circle" - Circle drawing tool (keyboard: C)
  - "text" - Text insertion tool (keyboard: T)
  - "delete" - Object deletion tool (keyboard: D)

  ## Returns

  `{:noreply, socket}` with updated selected_tool assign and push_event to client.
  """
  @impl true
  def handle_event("select_tool", %{"tool" => tool}, socket) do
    # Push tool selection to JavaScript hook
    {:noreply,
     socket
     |> assign(:selected_tool, tool)
     |> push_event("tool_selected", %{tool: tool})}
  end

  @doc """
  Handles cursor position update events from the client.

  Updates the user's cursor position in Phoenix Presence, which is then
  broadcast to all other connected clients for real-time cursor tracking.

  ## Parameters

  - `params` - Map containing "position" with x, y coordinates in canvas space

  ## Side Effects

  Updates Presence metadata for current user with new cursor position.
  Other clients receive presence_diff broadcast and update cursor display.

  ## Returns

  `{:noreply, socket}` - State unchanged as cursor position is in Presence only.
  """
  @impl true
  def handle_event("cursor_move", %{"position" => %{"x" => x, "y" => y}}, socket) do
    user_id = socket.assigns.user_id
    topic = socket.assigns.topic

    # Update presence with new cursor position
    Presence.update(self(), topic, user_id, fn meta ->
      Map.put(meta, :cursor, %{x: x, y: y})
    end)

    {:noreply, socket}
  end

  @doc """
  Handles viewport position save events from the client.

  Saves the user's current viewport position and zoom level for this canvas,
  so they can return to the same position when they reload or revisit.

  ## Parameters

  - `params` - Map containing:
    - "x" - Viewport X coordinate
    - "y" - Viewport Y coordinate
    - "zoom" - Zoom level

  ## Returns

  `{:noreply, socket}` - State unchanged, viewport saved to database
  """
  @impl true
  def handle_event("save_viewport", %{"x" => x, "y" => y, "zoom" => zoom}, socket) do
    user = socket.assigns.current_user
    canvas_id = socket.assigns.canvas_id

    # Save viewport position asynchronously (don't block on response)
    Task.start(fn ->
      Canvases.save_viewport(user.id, canvas_id, %{
        viewport_x: x,
        viewport_y: y,
        zoom: zoom
      })
    end)

    {:noreply, socket}
  end

  @doc """
  Handles component instantiation via drag-and-drop from the components panel.

  Creates instances of the component at the specified position on the current canvas.
  Broadcasts the instantiation to all connected clients.

  ## Parameters

  - `params` - Map containing:
    - "component_id" - ID of component to instantiate
    - "position" - Map with x, y coordinates for placement

  ## Returns

  `{:noreply, socket}` with updated objects list or error flash message
  """
  @impl true
  def handle_event("instantiate_component", params, socket) do
    component_id = params["component_id"]
    component_id = if is_binary(component_id), do: String.to_integer(component_id), else: component_id

    position = params["position"]
    position = %{x: position["x"], y: position["y"]}

    canvas_id = socket.assigns.canvas_id

    case CollabCanvas.Components.instantiate_component(component_id, position, canvas_id: canvas_id) do
      {:ok, instances} ->
        # Broadcast to all connected clients
        Enum.each(instances, fn instance ->
          Phoenix.PubSub.broadcast(
            CollabCanvas.PubSub,
            socket.assigns.topic,
            {:object_created, instance}
          )
        end)

        # Update local state
        updated_objects = instances ++ socket.assigns.objects

        {:noreply,
         socket
         |> assign(:objects, updated_objects)
         |> put_flash(:info, "Component instantiated (#{length(instances)} objects created)")}

      {:error, :not_found} ->
        {:noreply, put_flash(socket, :error, "Component not found")}

      {:error, reason} ->
        Logger.error("Failed to instantiate component: #{inspect(reason)}")
        {:noreply, put_flash(socket, :error, "Failed to instantiate component")}
    end
  end

  @doc """
  Handles toggle_labels events from the UI toggle switch.

  Toggles the display of object labels on the canvas and updates the state.

  ## Parameters

  - No parameters needed, toggles the current state

  ## Returns

  `{:noreply, socket}` with updated show_labels state and push_event to client.
  """
  @impl true
  def handle_event("toggle_labels", _params, socket) do
    new_state = !socket.assigns.show_labels
    object_labels = generate_object_labels(socket.assigns.objects)

    {:noreply,
     socket
     |> assign(:show_labels, new_state)
     |> push_event("toggle_object_labels", %{show: new_state, labels: object_labels})}
  end

  @doc """
  Handles toggle_color_picker events from the left sidebar button.

  Toggles the visibility of the color picker popup.

  ## Returns

  `{:noreply, socket}` with updated show_color_picker state.
  """
  @impl true
  def handle_event("toggle_color_picker", _params, socket) do
    {:noreply, assign(socket, :show_color_picker, !socket.assigns.show_color_picker)}
  end

  @doc """
  Handles color picker color change messages from the ColorPicker component.

  Updates the current color in socket assigns, updates the component, and saves to recent colors.

  ## Parameters

  - `color` - Hex color string selected by the user
  - `user_id` - ID of the user who changed the color

  ## Returns

  `{:noreply, socket}` with updated current_color assign and component update pushed.
  """
  @impl true
  def handle_info({:color_changed, color, user_id}, socket) do
    # Extract numeric user ID from the "user_#{id}" format
    current_user = socket.assigns.current_user

    # Only update if this color change is for the current user
    if "user_#{current_user.id}" == user_id do
      # Save to recent colors (async, non-blocking)
      Task.start(fn ->
        ColorPalettes.add_recent_color(current_user.id, color)
      end)

      # Update the LiveComponent with the new color
      send_update(CollabCanvasWeb.Components.ColorPicker,
        id: "color-picker",
        current_color: color
      )

      # Push event to JavaScript to update current color in CanvasManager
      {:noreply,
       socket
       |> assign(:current_color, color)
       |> push_event("color_changed", %{color: color})}
    else
      {:noreply, socket}
    end
  end

  @doc """
  Handles object_created broadcasts from PubSub (from other clients or AI).

  Adds newly created objects to local state and pushes to JavaScript for
  rendering. Includes deduplication logic to prevent showing the same object
  twice when the originating client receives its own broadcast.

  ## Parameters

  - `object` - The newly created canvas object struct

  ## Returns

  `{:noreply, socket}` with updated objects list and push_event to client,
  or unchanged socket if object already exists (deduplication).
  """
  @impl true
  def handle_info({:object_created, object}, socket) do
    # Only update if this object isn't already in our list (avoid duplicates)
    exists? = Enum.any?(socket.assigns.objects, fn obj -> obj.id == object.id end)

    if exists? do
      {:noreply, socket}
    else
      {:noreply,
       socket
       |> assign(:objects, [object | socket.assigns.objects])
       |> push_event("object_created", %{object: object})}
    end
  end

  @doc """
  Handles object_updated broadcasts from PubSub (from other clients).

  Updates the object in local state with the new properties and pushes to
  JavaScript for re-rendering. Common during drag operations or property changes.

  ## Parameters

  - `updated_object` - The updated canvas object struct with new properties

  ## Returns

  `{:noreply, socket}` with updated objects list and push_event to client.
  """
  @impl true
  def handle_info({:object_updated, updated_object}, socket) do
    objects =
      Enum.map(socket.assigns.objects, fn obj ->
        if obj.id == updated_object.id, do: updated_object, else: obj
      end)

    {:noreply,
     socket
     |> assign(:objects, objects)
     |> push_event("object_updated", %{object: updated_object})}
  end

  @doc """
  Handles batch object updates broadcast from PubSub (from other clients).

  Updates multiple objects in local state with new properties and pushes to
  JavaScript for re-rendering. Used during multi-object dragging operations.

  ## Parameters

  - `updated_objects` - List of updated canvas object structs

  ## Returns

  `{:noreply, socket}` with updated objects list and push_event to client.
  """
  @impl true
  def handle_info({:objects_updated_batch, updated_objects}, socket) do
    # Create a map of updated objects for efficient lookup
    updated_map = Map.new(updated_objects, fn obj -> {obj.id, obj} end)

    # Update local state
    objects =
      Enum.map(socket.assigns.objects, fn obj ->
        Map.get(updated_map, obj.id, obj)
      end)

    {:noreply,
     socket
     |> assign(:objects, objects)
     |> push_event("objects_updated_batch", %{objects: updated_objects})}
  end

  @doc """
  Handles object_deleted broadcasts from PubSub (from other clients).

  Removes the deleted object from local state and pushes to JavaScript for
  removal from the canvas rendering.

  ## Parameters

  - `object_id` - ID of the deleted canvas object

  ## Returns

  `{:noreply, socket}` with updated objects list and push_event to client.
  """
  @impl true
  def handle_info({:object_deleted, object_id}, socket) do
    objects = Enum.reject(socket.assigns.objects, fn obj -> obj.id == object_id end)

    {:noreply,
     socket
     |> assign(:objects, objects)
     |> push_event("object_deleted", %{object_id: object_id})}
  end

  @doc """
  Handles object_locked broadcasts from PubSub (from other clients).

  Updates the object in local state to show it's locked and pushes to
  JavaScript for visual feedback (grayed out, different cursor).

  ## Parameters

  - `locked_object` - The object that was locked with locked_by field set

  ## Returns

  `{:noreply, socket}` with updated objects list and push_event to client.
  """
  @impl true
  def handle_info({:object_locked, locked_object}, socket) do
    objects =
      Enum.map(socket.assigns.objects, fn obj ->
        if obj.id == locked_object.id, do: locked_object, else: obj
      end)

    {:noreply,
     socket
     |> assign(:objects, objects)
     |> push_event("object_locked", %{object: locked_object})}
  end

  @doc """
  Handles object_unlocked broadcasts from PubSub (from other clients).

  Updates the object in local state to show it's unlocked and pushes to
  JavaScript for visual feedback (normal appearance).

  ## Parameters

  - `unlocked_object` - The object that was unlocked with locked_by set to nil

  ## Returns

  `{:noreply, socket}` with updated objects list and push_event to client.
  """
  @impl true
  def handle_info({:object_unlocked, unlocked_object}, socket) do
    objects =
      Enum.map(socket.assigns.objects, fn obj ->
        if obj.id == unlocked_object.id, do: unlocked_object, else: obj
      end)

    {:noreply,
     socket
     |> assign(:objects, objects)
     |> push_event("object_unlocked", %{object: unlocked_object})}
  end

  @doc """
  Handles presence_diff broadcasts from Phoenix Presence.

  Triggered when users join, leave, or update their presence metadata (cursor
  position). Fetches the latest presence list and pushes to JavaScript for
  updating user cursors and online user display.

  ## Presence Metadata

  - `online_at` - Unix timestamp when user joined
  - `cursor` - Map with x, y coordinates or nil
  - `color` - Hex color string for user identification
  - `name` - User display name
  - `email` - User email address

  ## Returns

  `{:noreply, socket}` with updated presences assign and push_event to client.
  """
  @impl true
  def handle_info(%Phoenix.Socket.Broadcast{event: "presence_diff", payload: _diff}, socket) do
    # Get current presences from the topic
    topic = socket.assigns.topic
    presences = Presence.list(topic)

    # Push presence updates to JavaScript
    {:noreply,
     socket
     |> assign(:presences, presences)
     |> push_event("presence_updated", %{presences: presences})}
  end

  @doc """
  Handles successful AI task completion messages.

  Called when the async AI task spawned by execute_ai_command completes
  successfully. Processes the result, creates objects, broadcasts to all
  clients, and updates UI with success/error message.

  ## Parameters

  - `ref` - Task reference to match against ai_task_ref
  - `result` - AI execution result from Agent.execute_command/2

  ## Result Processing

  Extracts created objects from AI results, broadcasts them to all clients,
  and displays success message with count of objects created.

  ## Returns

  `{:noreply, socket}` with ai_loading=false, objects updated, and flash message,
  or unchanged socket if ref doesn't match current task.
  """
  @impl true
  def handle_info({ref, result}, socket) when is_reference(ref) do
    # Only process if this is our AI task
    if ref == socket.assigns.ai_task_ref do
      # Demonitor the task (cleanup)
      Process.demonitor(ref, [:flush])

      socket = process_ai_result(result, socket)

      {:noreply,
       socket
       |> assign(:ai_loading, false)
       |> assign(:ai_task_ref, nil)}
    else
      {:noreply, socket}
    end
  end

  @doc """
  Handles AI task failure or crash via process monitoring.

  Called when the async AI task process crashes or exits abnormally. Logs
  the error and displays user-friendly error message.

  ## Parameters

  - `ref` - Task reference to match against ai_task_ref
  - `reason` - Crash reason (exception, exit signal, etc.)

  ## Returns

  `{:noreply, socket}` with ai_loading=false and error flash message,
  or unchanged socket if ref doesn't match current task.
  """
  @impl true
  def handle_info({:DOWN, ref, :process, _pid, reason}, socket) when is_reference(ref) do
    # Only process if this is our AI task
    if ref == socket.assigns.ai_task_ref do
      Logger.error("AI task crashed: #{inspect(reason)}")

      {:noreply,
       socket
       |> assign(:ai_loading, false)
       |> assign(:ai_task_ref, nil)
       |> put_flash(:error, "AI processing failed unexpectedly")}
    else
      {:noreply, socket}
    end
  end

  @doc """
  Handles AI task timeout after 30 seconds.

  Called when the AI task takes longer than 30 seconds to complete. Resets
  loading state and displays timeout error message to the user.

  ## Parameters

  - `ref` - Task reference to match against ai_task_ref

  ## Returns

  `{:noreply, socket}` with ai_loading=false and timeout error message,
  or unchanged socket if ref doesn't match current task (already completed).
  """
  @impl true
  def handle_info({:ai_timeout, ref}, socket) when is_reference(ref) do
    # Only process if this is still the current task
    if ref == socket.assigns.ai_task_ref do
      Logger.warning("AI task timed out after 30 seconds")

      {:noreply,
       socket
       |> assign(:ai_loading, false)
       |> assign(:ai_task_ref, nil)
       |> put_flash(:error, "AI request timed out after 30 seconds. Please try again.")}
    else
      # Timeout for an old task that already completed, ignore
      {:noreply, socket}
    end
  end

  @doc """
  Cleanup when the LiveView process terminates.

  Unsubscribes from PubSub topic to prevent memory leaks. Presence tracking
  is automatically cleaned up when the process dies. Also unlocks any objects
  that were locked by this user.

  ## Parameters

  - `reason` - Termination reason (normal, crash, timeout, etc.)
  - `socket` - The LiveView socket

  ## Returns

  `:ok`
  """
  @impl true
  def terminate(_reason, socket) do
    # Unlock any objects locked by this user
    if Map.has_key?(socket.assigns, :user_id) do
      user_id = socket.assigns.user_id
      canvas_id = socket.assigns[:canvas_id]

      if canvas_id do
        # Find and unlock all objects locked by this user on this canvas
        locked_objects =
          Canvases.list_objects(canvas_id)
          |> Enum.filter(fn obj -> obj.locked_by == user_id end)

        Enum.each(locked_objects, fn obj ->
          Canvases.unlock_object(obj.id)
          # Broadcast unlock to other clients
          Phoenix.PubSub.broadcast(
            CollabCanvas.PubSub,
            socket.assigns.topic,
            {:object_unlocked, %{obj | locked_by: nil}}
          )
        end)
      end
    end

    # Unsubscribe from PubSub topic
    if Map.has_key?(socket.assigns, :topic) do
      Phoenix.PubSub.unsubscribe(CollabCanvas.PubSub, socket.assigns.topic)
    end

    # Presence tracking is automatically cleaned up when process dies
    :ok
  end

  @doc false
  # Private helper to generate human-readable labels for canvas objects.
  # Groups objects by type and numbers them sequentially.
  # Returns a map of object_id => display_name (e.g., "Rectangle 1", "Circle 2")
  defp generate_object_labels(objects) do
    # Group objects by type and count occurrences
    objects
    |> Enum.group_by(& &1.type)
    |> Enum.flat_map(fn {type, objects_of_type} ->
      # Sort by ID to maintain consistent ordering
      objects_of_type
      |> Enum.sort_by(& &1.id)
      |> Enum.with_index(1)
      |> Enum.map(fn {object, index} ->
        # Capitalize type name (e.g., "rectangle" -> "Rectangle")
        type_name = String.capitalize(type)
        {object.id, "#{type_name} #{index}"}
      end)
    end)
    |> Map.new()
  end

  @doc false
  # Private helper to process AI agent results and update socket state.
  # Handles all possible result types from Agent.execute_command/2:
  # - {:ok, results} - Successfully created objects
  # - {:error, :canvas_not_found} - Canvas doesn't exist
  # - {:error, :missing_api_key} - Claude API key not configured
  # - {:error, {:api_error, status, body}} - API request failed
  # - {:error, {:request_failed, reason}} - Network/connection error
  # - {:error, :invalid_response_format} - AI response parsing failed
  # - {:error, reason} - Other errors
  defp process_ai_result(result, socket) do
    case result do
      {:ok, {:text_response, text}} ->
        # AI asked for clarification or provided text response
        socket
        |> assign(:ai_command, "")
        |> put_flash(:info, text)

      {:ok, {:toggle_labels, show}} ->
        # AI requested to show/hide object labels
        # Generate display names for all objects
        object_labels = generate_object_labels(socket.assigns.objects)

        # Push event to JavaScript to render labels
        socket
        |> push_event("toggle_object_labels", %{show: show, labels: object_labels})
        |> assign(:ai_command, "")
        |> assign(:show_labels, show)
        |> put_flash(:info, if(show, do: "Object labels shown", else: "Object labels hidden"))

      {:ok, results} when is_list(results) and length(results) == 0 ->
        # AI returned no tool calls - it either doesn't understand or can't perform the action
        socket
        |> assign(:ai_command, "")
        |> put_flash(:warning, "I couldn't perform that action. Try rephrasing your command or check if I have the right tools available.")

      {:ok, results} when is_list(results) ->
        # Check if this is a special non-object result (like toggle_labels)
        case results do
          [%{tool: "show_object_labels", result: {:ok, {:toggle_labels, show}}}] ->
            # Handle label toggle
            object_labels = generate_object_labels(socket.assigns.objects)

            socket
            |> push_event("toggle_object_labels", %{show: show, labels: object_labels})
            |> assign(:ai_command, "")
            |> assign(:show_labels, show)
            |> put_flash(:info, if(show, do: "Object labels shown", else: "Object labels hidden"))

          _ ->
            # Separate created objects from updated objects
            {created_objects, updated_objects} =
              results
              |> Enum.reduce({[], []}, fn result, {created, updated} ->
                case result do
                  # Handle create operations
                  %{tool: tool, result: {:ok, object}} when tool in ["create_shape", "create_text", "create_component"] and is_map(object) and is_map_key(object, :id) ->
                    {[object | created], updated}

                  # Handle update/move/arrange operations
                  %{tool: tool, result: {:ok, object}} when tool in ["move_object", "move_shape", "resize_object", "resize_shape", "rotate_object", "change_style", "update_text"] and is_map(object) and is_map_key(object, :id) ->
                    {created, [object | updated]}

                  # Handle arrange_objects which returns a success map
                  %{tool: "arrange_objects", result: {:ok, _success_map}, input: input} ->
                    # Fetch the actual updated objects from the database
                    object_ids = Map.get(input, "object_ids", [])
                    arranged_objects = Enum.map(object_ids, fn id ->
                      Canvases.get_object(id)
                    end) |> Enum.reject(&is_nil/1)
                    {created, arranged_objects ++ updated}

                  _ ->
                    {created, updated}
                end
              end)

        # Broadcast created objects
        Enum.each(created_objects, fn object ->
          Phoenix.PubSub.broadcast(
            CollabCanvas.PubSub,
            socket.assigns.topic,
            {:object_created, object}
          )
        end)

        # Broadcast updated objects
        Enum.each(updated_objects, fn object ->
          Phoenix.PubSub.broadcast(
            CollabCanvas.PubSub,
            socket.assigns.topic,
            {:object_updated, object}
          )
        end)

        # Update local state - merge created and updated
        new_created = created_objects
        existing_objects = socket.assigns.objects

        # Update existing objects with new data, add new objects
        updated_ids = MapSet.new(updated_objects, & &1.id)
        merged_objects =
          Enum.map(existing_objects, fn obj ->
            if MapSet.member?(updated_ids, obj.id) do
              Enum.find(updated_objects, obj, fn updated -> updated.id == obj.id end)
            else
              obj
            end
          end)

        final_objects = new_created ++ merged_objects

        total_count = length(created_objects) + length(updated_objects)

        message =
          if total_count > 0 do
            parts = []
            parts = if length(created_objects) > 0, do: ["created #{length(created_objects)}" | parts], else: parts
            parts = if length(updated_objects) > 0, do: ["updated #{length(updated_objects)}" | parts], else: parts
            "AI #{Enum.join(Enum.reverse(parts), " and ")} object(s) successfully"
          else
            "AI command processed (check canvas for results)"
          end

        # Push created objects to JavaScript
        socket_with_created = Enum.reduce(created_objects, socket, fn object, acc_socket ->
          push_event(acc_socket, "object_created", %{object: object})
        end)

        # Push updated objects to JavaScript for immediate rendering with animation
        socket_with_all = Enum.reduce(updated_objects, socket_with_created, fn object, acc_socket ->
          push_event(acc_socket, "object_updated", %{object: object, animate: true})
        end)

        socket_with_all
        |> assign(:objects, final_objects)
        |> assign(:ai_command, "")
        |> put_flash(:info, message)
        end

      {:error, :canvas_not_found} ->
        put_flash(socket, :error, "Canvas not found")

      {:error, :missing_api_key} ->
        put_flash(
          socket,
          :error,
          "AI API key not configured. Please set CLAUDE_API_KEY environment variable."
        )

      {:error, {:api_error, status, body}} ->
        Logger.error("AI API error: #{status} - #{inspect(body)}")

        error_msg =
          case body do
            %{"error" => %{"message" => msg}} when is_binary(msg) -> msg
            %{"error" => msg} when is_binary(msg) -> msg
            _ -> "AI API error (#{status})"
          end

        put_flash(socket, :error, error_msg)

      {:error, {:request_failed, reason}} ->
        Logger.error("AI request failed: #{inspect(reason)}")
        put_flash(socket, :error, "AI request failed: #{inspect(reason)}")

      {:error, :invalid_response_format} ->
        put_flash(socket, :error, "AI returned invalid response format")

      {:error, reason} ->
        Logger.error("AI command failed: #{inspect(reason)}")
        put_flash(socket, :error, "AI command failed: #{inspect(reason)}")
    end
  end

  @doc """
  Renders the canvas interface with toolbar, canvas area, and AI panel.

  The template includes:
  - Left toolbar with drawing tools and online user list
  - Center canvas area with PixiJS rendering via CanvasRenderer hook
  - Right AI assistant panel with command input and object list

  All real-time updates are handled via push_event to JavaScript hooks,
  which update the PixiJS canvas without full page re-renders.
  """
  @impl true
  def render(assigns) do
    ~H"""
    <div class="flex h-screen bg-gray-100">
      <!-- Flash Messages -->
      <.flash kind={:info} flash={@flash} />
      <.flash kind={:error} flash={@flash} />
      <.flash kind={:warning} flash={@flash} />

      <!-- Toolbar -->
      <div class="w-16 bg-white border-r border-gray-200 flex flex-col items-center py-4 space-y-2">
        <button
          phx-click="select_tool"
          phx-value-tool="select"
          class={[
            "w-12 h-12 rounded-lg flex items-center justify-center hover:bg-gray-100 transition-colors relative group",
            @selected_tool == "select" && "bg-blue-100 text-blue-600"
          ]}
          title="Select Tool (S)"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122"
            />
          </svg>
          <span class="absolute right-1 bottom-1 text-[10px] font-bold opacity-50">S</span>
        </button>

        <button
          phx-click="select_tool"
          phx-value-tool="rectangle"
          class={[
            "w-12 h-12 rounded-lg flex items-center justify-center hover:bg-gray-100 transition-colors relative group",
            @selected_tool == "rectangle" && "bg-blue-100 text-blue-600"
          ]}
          title="Rectangle Tool (R) - Click & drag to create"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <rect x="4" y="6" width="16" height="12" stroke-width="2" rx="2" />
          </svg>
          <span class="absolute right-1 bottom-1 text-[10px] font-bold opacity-50">R</span>
        </button>

        <button
          phx-click="select_tool"
          phx-value-tool="circle"
          class={[
            "w-12 h-12 rounded-lg flex items-center justify-center hover:bg-gray-100 transition-colors relative group",
            @selected_tool == "circle" && "bg-blue-100 text-blue-600"
          ]}
          title="Circle Tool (C) - Click & drag to create"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="8" stroke-width="2" />
          </svg>
          <span class="absolute right-1 bottom-1 text-[10px] font-bold opacity-50">C</span>
        </button>

        <button
          phx-click="select_tool"
          phx-value-tool="text"
          class={[
            "w-12 h-12 rounded-lg flex items-center justify-center hover:bg-gray-100 transition-colors relative group",
            @selected_tool == "text" && "bg-blue-100 text-blue-600"
          ]}
          title="Text Tool (T) - Click to add text"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"
            />
          </svg>
          <span class="absolute right-1 bottom-1 text-[10px] font-bold opacity-50">T</span>
        </button>

        <button
          phx-click="select_tool"
          phx-value-tool="delete"
          class={[
            "w-12 h-12 rounded-lg flex items-center justify-center hover:bg-gray-100 transition-colors relative group",
            @selected_tool == "delete" && "bg-red-100 text-red-600"
          ]}
          title="Delete Tool (D) - Click object to delete"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
            />
          </svg>
          <span class="absolute right-1 bottom-1 text-[10px] font-bold opacity-50">D</span>
        </button>

        <div class="flex-1"></div>

        <!-- Color Picker Button -->
        <button
          phx-click="toggle_color_picker"
          class={[
            "w-12 h-12 rounded-lg flex items-center justify-center hover:bg-gray-100 transition-colors relative group border-2",
            @show_color_picker && "bg-blue-100 border-blue-500",
            !@show_color_picker && "border-gray-300"
          ]}
          title="Color Picker"
          style={"background-color: #{@current_color}"}
        >
          <svg class="w-6 h-6 text-white drop-shadow-md" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
            />
          </svg>
        </button>

        <!-- Keyboard shortcuts help -->
        <div class="text-[10px] text-gray-400 text-center px-1 leading-tight mb-2">
          <div class="mb-1">Space + Drag = Pan</div>
          <div class="mb-1">2-Finger Scroll = Pan</div>
          <div>Ctrl + Scroll = Zoom</div>
        </div>

        <!-- Online Users -->
        <div class="border-t border-gray-200 pt-2 mt-2">
          <div class="text-[10px] text-gray-500 text-center mb-2 font-medium">
            ONLINE (<%= map_size(@presences) %>)
          </div>
          <%= for {user_id, %{metas: [meta | _]}} <- @presences do %>
            <div
              class="w-12 h-12 rounded-lg flex items-center justify-center mb-1 text-white font-bold text-xs relative group"
              style={"background-color: #{meta.color}"}
              title={"#{meta.email}#{if user_id == @user_id, do: " (You)", else: ""}"}
            >
              <%= String.first(meta.email || meta.name || "?") %>
              <%= if user_id == @user_id do %>
                <div class="absolute -bottom-1 -right-1 w-3 h-3 bg-green-500 rounded-full border-2 border-white"></div>
              <% end %>
            </div>
          <% end %>
        </div>
      </div>
      <!-- Main Canvas Area -->
      <div class="flex-1 flex flex-col">
        <!-- Top Bar -->
        <div class="h-14 bg-white border-b border-gray-200 flex items-center px-4">
          <h1 class="text-lg font-semibold text-gray-800"><%= @canvas.name %></h1>
          <div class="flex-1"></div>
          <span class="text-sm text-gray-500">
            Canvas ID: <%= @canvas_id %>
          </span>
        </div>
        <!-- Canvas Container -->
        <div
          id="canvas-container"
          phx-hook="CanvasRenderer"
          phx-update="ignore"
          class="flex-1 bg-white overflow-hidden"
          style="min-width: 0; min-height: 0;"
          data-objects={Jason.encode!(@objects)}
          data-presences={Jason.encode!(@presences)}
          data-user-id={@user_id}
          data-current-color={@current_color}
        >
          <!-- PixiJS will render here -->
        </div>
      </div>
      <!-- AI Panel -->
      <div class="w-80 bg-white border-l border-gray-200 flex flex-col">
        <div class="p-4 border-b border-gray-200">
          <h2 class="text-lg font-semibold text-gray-800">AI Assistant</h2>
          <p class="text-sm text-gray-500 mt-1">Describe what you want to create</p>
        </div>

        <div class="flex-1 p-4 overflow-y-auto">
          <div class="space-y-4">
            <!-- AI Command Input -->
            <form phx-change="ai_command_change">
              <label class="block text-sm font-medium text-gray-700 mb-2">
                Command
              </label>
              <textarea
                name="value"
                value={@ai_command}
                disabled={@ai_loading}
                class={[
                  "w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none",
                  @ai_loading && "bg-gray-50 cursor-not-allowed"
                ]}
                rows="4"
                placeholder="e.g., 'Create a blue rectangle' or 'Add a green circle'"
              ><%= @ai_command %></textarea>
            </form>

            <button
              id="ai-execute-button"
              phx-click="execute_ai_command"
              phx-value-command={@ai_command}
              disabled={@ai_command == "" || @ai_loading}
              class={[
                "w-full py-2 px-4 rounded-lg font-medium transition-colors flex items-center justify-center gap-2",
                (@ai_command == "" || @ai_loading) &&
                  "bg-gray-300 text-gray-500 cursor-not-allowed",
                @ai_command != "" && !@ai_loading &&
                  "bg-blue-600 text-white hover:bg-blue-700"
              ]}
            >
              <%= if @ai_loading do %>
                <svg
                  class="animate-spin h-5 w-5"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                >
                  <circle
                    class="opacity-25"
                    cx="12"
                    cy="12"
                    r="10"
                    stroke="currentColor"
                    stroke-width="4"
                  >
                  </circle>
                  <path
                    class="opacity-75"
                    fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  >
                  </path>
                </svg>
                Processing...
              <% else %>
                Generate
              <% end %>
            </button>
          </div>
          <!-- Example Commands -->
          <div class="mt-6">
            <h3 class="text-sm font-medium text-gray-700 mb-2">Example Commands:</h3>
            <ul class="text-sm text-gray-600 space-y-1">
              <li>• "Create a rectangle"</li>
              <li>• "Add a circle"</li>
              <li>• "Make a blue square"</li>
              <li class="text-blue-600 font-medium">• "Arrange selected horizontally"</li>
              <li class="text-blue-600 font-medium">• "Align selected objects to top"</li>
              <li class="text-blue-600 font-medium">• "Distribute vertically with 20px spacing"</li>
            </ul>
            <div class="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
              <p class="text-xs text-blue-700">
                Tip: Select multiple objects (Shift+click) before using layout commands!
              </p>
            </div>
          </div>
        </div>
        <!-- Objects List -->
        <div class="border-t border-gray-200 p-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-sm font-medium text-gray-700">
              Objects (<%= length(@objects) %>)
            </h3>
            <!-- Show Labels Toggle -->
            <button
              phx-click="toggle_labels"
              class="flex items-center gap-2 group"
              title={if @show_labels, do: "Hide object labels", else: "Show object labels"}
            >
              <span class="text-xs text-gray-600 group-hover:text-gray-900">Labels</span>
              <div class={[
                "relative inline-flex h-5 w-9 items-center rounded-full transition-colors",
                @show_labels && "bg-blue-600",
                !@show_labels && "bg-gray-300"
              ]}>
                <span class={[
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  @show_labels && "translate-x-5",
                  !@show_labels && "translate-x-1"
                ]} />
              </div>
            </button>
          </div>
          <div class="space-y-1 max-h-40 overflow-y-auto">
            <%= for object <- @objects do %>
              <div class="flex items-center justify-between text-sm py-1">
                <span class="text-gray-600"><%= object.type %></span>
                <button
                  phx-click="delete_object"
                  phx-value-id={object.id}
                  class="text-red-600 hover:text-red-800"
                  title="Delete"
                >
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                    />
                  </svg>
                </button>
              </div>
            <% end %>
          </div>
        </div>
      </div>

      <!-- Color Picker Popup -->
      <%= if @show_color_picker do %>
        <div class="fixed inset-0 z-50">
          <div class="absolute inset-0 bg-black opacity-25" phx-click="toggle_color_picker"></div>
          <div class="absolute top-4 left-20 z-10">
            <.live_component
              module={CollabCanvasWeb.Components.ColorPicker}
              id="color-picker"
              user_id={@current_user.id}
              current_color={@current_color}
            />
          </div>
        </div>
      <% end %>
    </div>
    """
  end
end
</file>

<file path="lib/collab_canvas_web/live/components_panel_live.ex">
defmodule CollabCanvasWeb.ComponentsPanelLive do
  @moduledoc """
  LiveComponent for displaying and managing the component library.

  This component provides a comprehensive interface for working with reusable components,
  including browsing, searching, filtering, and instantiating components via drag-and-drop.

  ## Features

  ### Component Library Display
  - Displays all published components with thumbnails
  - Shows component metadata (name, category, description)
  - Organizes components by category folders
  - Provides preview thumbnails generated from template data

  ### Search and Filter
  - Real-time search by component name or description
  - Filter by category (button, card, form, navigation, layout, icon, custom)
  - Case-insensitive search with debouncing
  - Combined search and filter functionality

  ### Drag-and-Drop Instantiation
  - Drag components from panel to canvas
  - Visual feedback during drag operations
  - Drop position determines instance placement
  - Automatically creates instances on the target canvas

  ### Real-Time Updates
  - Subscribes to component:created, component:updated, component:deleted events
  - Automatically updates component list when changes occur
  - Reflects changes from other users in real-time
  - Maintains search/filter state during updates

  ### Component Management
  - Create new components from selected objects
  - Update component properties (name, description, category)
  - Delete components with confirmation
  - Toggle component publishing status

  ## State Management

  The component assigns include:
  - `:id` - Unique identifier for this LiveComponent instance
  - `:canvas_id` - Canvas ID for subscribing to component events
  - `:components` - List of all published components
  - `:filtered_components` - Filtered list based on search/category
  - `:search_query` - Current search text
  - `:selected_category` - Current category filter (nil = all)
  - `:expanded_categories` - Set of expanded folder categories
  - `:dragging_component` - Component currently being dragged (if any)

  ## Event Flow

  1. User searches or filters components
  2. Client sends event to LiveComponent
  3. LiveComponent updates filtered_components
  4. UI re-renders with filtered results

  For drag-and-drop:
  1. User starts dragging a component
  2. JavaScript hook sends drag_start event
  3. User drops component on canvas
  4. JavaScript hook sends instantiate_component event
  5. LiveComponent calls Components.instantiate_component/3
  6. New instances are created and broadcast via PubSub
  """

  use CollabCanvasWeb, :live_component

  alias CollabCanvas.Components
  alias CollabCanvas.Components.Component

  require Logger

  @doc """
  Mounts the LiveComponent and initializes component library state.

  ## Responsibilities

  1. Subscribes to component events (created, updated, deleted, instantiated)
  2. Loads all published components from the database
  3. Initializes search and filter state
  4. Sets up default expanded categories

  ## Returns

  `{:ok, socket}` with initialized assigns
  """
  @impl true
  def mount(socket) do
    # Subscribe to component events
    Phoenix.PubSub.subscribe(CollabCanvas.PubSub, "component:created")
    Phoenix.PubSub.subscribe(CollabCanvas.PubSub, "component:updated")
    Phoenix.PubSub.subscribe(CollabCanvas.PubSub, "component:deleted")
    Phoenix.PubSub.subscribe(CollabCanvas.PubSub, "component:instantiated")

    {:ok, socket}
  end

  @doc """
  Updates the LiveComponent with new assigns.

  Called when parent LiveView passes new assigns to this component.
  Loads and filters components based on canvas_id and current search/filter state.

  ## Parameters

  - `assigns` - Map containing:
    - `:id` - Component instance ID
    - `:canvas_id` - Canvas ID for component context
  """
  @impl true
  def update(assigns, socket) do
    socket =
      socket
      |> assign(assigns)
      |> assign_new(:search_query, fn -> "" end)
      |> assign_new(:selected_category, fn -> nil end)
      |> assign_new(:expanded_categories, fn -> MapSet.new(["button", "card"]) end)
      |> assign_new(:dragging_component, fn -> nil end)

    # Load components
    components = load_components(socket.assigns.canvas_id)

    socket =
      socket
      |> assign(:components, components)
      |> apply_filters()

    {:ok, socket}
  end

  @doc """
  Handles search query input from the client.

  Updates the search query and re-filters the component list based on
  name and description matching.

  ## Parameters

  - `params` - Map containing "value" key with search text

  ## Returns

  `{:noreply, socket}` with updated search_query and filtered_components
  """
  @impl true
  def handle_event("search", %{"value" => query}, socket) do
    socket =
      socket
      |> assign(:search_query, String.downcase(query))
      |> apply_filters()

    {:noreply, socket}
  end

  @doc """
  Handles category filter selection from the client.

  Updates the category filter and re-filters the component list.

  ## Parameters

  - `params` - Map containing "category" key (or nil for all)

  ## Returns

  `{:noreply, socket}` with updated selected_category and filtered_components
  """
  @impl true
  def handle_event("filter_category", %{"category" => category}, socket) do
    category = if category == "", do: nil, else: category

    socket =
      socket
      |> assign(:selected_category, category)
      |> apply_filters()

    {:noreply, socket}
  end

  @doc """
  Handles category folder expand/collapse toggle.

  Toggles whether a category folder is expanded or collapsed in the UI.

  ## Parameters

  - `params` - Map containing "category" key

  ## Returns

  `{:noreply, socket}` with updated expanded_categories
  """
  @impl true
  def handle_event("toggle_category", %{"category" => category}, socket) do
    expanded = socket.assigns.expanded_categories

    expanded =
      if MapSet.member?(expanded, category) do
        MapSet.delete(expanded, category)
      else
        MapSet.put(expanded, category)
      end

    {:noreply, assign(socket, :expanded_categories, expanded)}
  end

  @doc """
  Handles drag start event from the client.

  Records which component is being dragged for reference during drop.

  ## Parameters

  - `params` - Map containing "component_id" key

  ## Returns

  `{:noreply, socket}` with updated dragging_component
  """
  @impl true
  def handle_event("drag_start", %{"component_id" => component_id}, socket) do
    component_id = if is_binary(component_id), do: String.to_integer(component_id), else: component_id
    component = Enum.find(socket.assigns.components, &(&1.id == component_id))

    {:noreply, assign(socket, :dragging_component, component)}
  end

  @doc """
  Handles drag end event from the client.

  Clears the dragging component reference.

  ## Returns

  `{:noreply, socket}` with cleared dragging_component
  """
  @impl true
  def handle_event("drag_end", _params, socket) do
    {:noreply, assign(socket, :dragging_component, nil)}
  end

  # Note: instantiate_component event is handled by parent LiveView (CanvasLive)
  # The drag-and-drop hook sends the event directly to the parent

  @doc """
  Handles component creation from selected objects.

  Creates a new reusable component from the given object IDs.

  ## Parameters

  - `params` - Map containing:
    - "object_ids" - List of object IDs to include in component
    - "name" - Component name
    - "category" - Component category
    - "description" - Optional description

  ## Returns

  `{:noreply, socket}` with flash message (success or error)
  """
  @impl true
  def handle_event("create_component", params, socket) do
    object_ids = params["object_ids"] || []
    name = params["name"]
    category = params["category"] || "custom"
    description = params["description"]

    # Get current user from parent
    user_id = get_current_user_id(socket)

    case Components.create_component(object_ids, name, category,
           canvas_id: socket.assigns.canvas_id,
           created_by: user_id,
           description: description,
           is_published: true
         ) do
      {:ok, component} ->
        # Component will be added via PubSub broadcast
        {:noreply, put_flash(socket, :info, "Component '#{component.name}' created successfully")}

      {:error, :objects_not_found} ->
        {:noreply, put_flash(socket, :error, "Some objects were not found")}

      {:error, :objects_must_belong_to_same_canvas} ->
        {:noreply, put_flash(socket, :error, "All objects must belong to the same canvas")}

      {:error, changeset} ->
        errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)
        error_msg = "Failed to create component: #{inspect(errors)}"
        {:noreply, put_flash(socket, :error, error_msg)}
    end
  end

  @doc """
  Handles component update requests.

  Updates component properties (name, description, category).

  ## Parameters

  - `params` - Map containing:
    - "component_id" - ID of component to update
    - Other fields to update (name, description, category, is_published)

  ## Returns

  `{:noreply, socket}` with flash message (success or error)
  """
  @impl true
  def handle_event("update_component", params, socket) do
    component_id = params["component_id"]
    component_id = if is_binary(component_id), do: String.to_integer(component_id), else: component_id

    changes =
      params
      |> Map.drop(["component_id"])
      |> Map.new(fn {k, v} -> {String.to_atom(k), v} end)

    case Components.update_component(component_id, changes) do
      {:ok, component} ->
        # Component will be updated via PubSub broadcast
        {:noreply, put_flash(socket, :info, "Component '#{component.name}' updated successfully")}

      {:error, :not_found} ->
        {:noreply, put_flash(socket, :error, "Component not found")}

      {:error, changeset} ->
        errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)
        error_msg = "Failed to update component: #{inspect(errors)}"
        {:noreply, put_flash(socket, :error, error_msg)}
    end
  end

  @doc """
  Handles instance property override requests.

  Allows overriding specific properties of a component instance without affecting
  the main component or other instances.

  ## Parameters

  - `params` - Map containing:
    - "instance_id" - ID of the instance object to override
    - "property" - Property name to override
    - "value" - New value for the property

  ## Returns

  `{:noreply, socket}` with flash message (success or error)
  """
  @impl true
  def handle_event("override_instance_property", params, socket) do
    instance_id = params["instance_id"]
    instance_id = if is_binary(instance_id), do: String.to_integer(instance_id), else: instance_id

    property = params["property"]
    value = params["value"]

    # Load current instance to get existing overrides
    case CollabCanvas.Canvases.get_object(instance_id) do
      nil ->
        {:noreply, put_flash(socket, :error, "Instance not found")}

      instance ->
        # Parse existing overrides
        overrides =
          case instance.instance_overrides do
            nil -> %{}
            json when is_binary(json) -> Jason.decode!(json)
            map when is_map(map) -> map
          end

        # Add new override
        overrides = Map.put(overrides, property, value)

        # Update instance
        case CollabCanvas.Canvases.update_object(instance_id, %{
               instance_overrides: Jason.encode!(overrides)
             }) do
          {:ok, _updated} ->
            {:noreply, put_flash(socket, :info, "Instance property overridden successfully")}

          {:error, :not_found} ->
            {:noreply, put_flash(socket, :error, "Instance not found")}

          {:error, _reason} ->
            {:noreply, put_flash(socket, :error, "Failed to override instance property")}
        end
    end
  end

  @doc """
  Handles component:created broadcasts from PubSub.

  Adds newly created components to the library.

  ## Parameters

  - `{:created, component, _metadata}` - Tuple with component struct

  ## Returns

  `{:noreply, socket}` with updated components list
  """
  @impl true
  def handle_info({:created, component, _metadata}, socket) do
    # Only show published components
    if component.is_published do
      components = [component | socket.assigns.components]

      socket =
        socket
        |> assign(:components, components)
        |> apply_filters()

      {:noreply, socket}
    else
      {:noreply, socket}
    end
  end

  @doc """
  Handles component:updated broadcasts from PubSub.

  Updates component in the library list.

  ## Parameters

  - `{:updated, component, _metadata}` - Tuple with updated component struct

  ## Returns

  `{:noreply, socket}` with updated components list
  """
  @impl true
  def handle_info({:updated, component, _metadata}, socket) do
    components =
      Enum.map(socket.assigns.components, fn c ->
        if c.id == component.id, do: component, else: c
      end)

    socket =
      socket
      |> assign(:components, components)
      |> apply_filters()

    {:noreply, socket}
  end

  @doc """
  Handles component:deleted broadcasts from PubSub.

  Removes deleted component from the library list.

  ## Parameters

  - `{:deleted, component, _metadata}` - Tuple with deleted component struct

  ## Returns

  `{:noreply, socket}` with updated components list
  """
  @impl true
  def handle_info({:deleted, component, _metadata}, socket) do
    components = Enum.reject(socket.assigns.components, fn c -> c.id == component.id end)

    socket =
      socket
      |> assign(:components, components)
      |> apply_filters()

    {:noreply, socket}
  end

  @doc """
  Handles component:instantiated broadcasts from PubSub.

  Can be used to show notifications or update UI when components are instantiated.

  ## Returns

  `{:noreply, socket}` - Currently no-op, can be extended for notifications
  """
  @impl true
  def handle_info({:instantiated, _component, _metadata}, socket) do
    {:noreply, socket}
  end

  # Private helper functions

  defp load_components(_canvas_id) do
    # Load all published components
    Components.list_published_components()
  end

  defp apply_filters(socket) do
    components = socket.assigns.components
    query = socket.assigns.search_query
    category = socket.assigns.selected_category

    filtered =
      components
      |> filter_by_search(query)
      |> filter_by_category(category)

    assign(socket, :filtered_components, filtered)
  end

  defp filter_by_search(components, ""), do: components

  defp filter_by_search(components, query) do
    query = String.downcase(query)

    Enum.filter(components, fn component ->
      name_match = String.contains?(String.downcase(component.name), query)

      description_match =
        if component.description do
          String.contains?(String.downcase(component.description), query)
        else
          false
        end

      name_match || description_match
    end)
  end

  defp filter_by_category(components, nil), do: components

  defp filter_by_category(components, category) do
    Enum.filter(components, fn component ->
      component.category == category
    end)
  end

  defp get_current_user_id(socket) do
    # Try to get user_id from parent assigns
    case socket.assigns do
      %{current_user: %{id: id}} -> id
      %{user_id: user_id} -> user_id
      _ -> nil
    end
  end

  defp generate_thumbnail_url(component) do
    # Generate a simple SVG thumbnail based on template data
    # In a real implementation, this could render a preview of the component
    template_data = component.template_data || "{}"

    case Jason.decode(template_data) do
      {:ok, objects} when is_list(objects) and length(objects) > 0 ->
        # Generate SVG from first object
        first_object = List.first(objects)
        type = first_object["type"]

        case type do
          "rectangle" -> generate_rectangle_svg()
          "circle" -> generate_circle_svg()
          "text" -> generate_text_svg()
          _ -> generate_default_svg()
        end

      _ ->
        generate_default_svg()
    end
  end

  defp generate_rectangle_svg do
    "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect x='10' y='20' width='80' height='60' fill='%233b82f6' rx='4'/%3E%3C/svg%3E"
  end

  defp generate_circle_svg do
    "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='40' fill='%2310b981'/%3E%3C/svg%3E"
  end

  defp generate_text_svg do
    "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext x='50' y='55' text-anchor='middle' font-size='32' fill='%236b7280'%3ET%3C/text%3E%3C/svg%3E"
  end

  defp generate_default_svg do
    "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect x='20' y='20' width='60' height='60' fill='%23e5e7eb' rx='8'/%3E%3C/svg%3E"
  end

  defp group_components_by_category(components) do
    Enum.group_by(components, fn component ->
      component.category || "custom"
    end)
  end

  defp category_icon(category) do
    case category do
      "button" -> "cursor-arrow-rays"
      "card" -> "rectangle-stack"
      "form" -> "document-text"
      "navigation" -> "bars-3"
      "layout" -> "squares-2x2"
      "icon" -> "star"
      "custom" -> "cube"
      _ -> "cube"
    end
  end

  defp category_color(category) do
    case category do
      "button" -> "blue"
      "card" -> "green"
      "form" -> "purple"
      "navigation" -> "orange"
      "layout" -> "pink"
      "icon" -> "yellow"
      "custom" -> "gray"
      _ -> "gray"
    end
  end

  @doc """
  Renders the components panel UI.

  The template includes:
  - Search bar for filtering components
  - Category filter dropdown
  - Folder-organized component list with expand/collapse
  - Component thumbnails with drag-and-drop support
  - Component metadata (name, category, description)
  """
  @impl true
  def render(assigns) do
    ~H"""
    <div class="h-full flex flex-col bg-white border-l border-gray-200">
      <!-- Header -->
      <div class="p-4 border-b border-gray-200">
        <h2 class="text-lg font-semibold text-gray-800">Components</h2>
        <p class="text-sm text-gray-500 mt-1">Drag to canvas to instantiate</p>
      </div>
      <!-- Search and Filter -->
      <div class="p-4 space-y-3 border-b border-gray-200">
        <!-- Search Input -->
        <div class="relative">
          <input
            type="text"
            phx-change="search"
            phx-target={@myself}
            phx-value-value={@search_query}
            phx-debounce="300"
            value={@search_query}
            placeholder="Search components..."
            class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
          <svg
            class="absolute left-3 top-2.5 w-5 h-5 text-gray-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
            />
          </svg>
        </div>
        <!-- Category Filter -->
        <div>
          <select
            phx-change="filter_category"
            phx-target={@myself}
            phx-value-category={@selected_category || ""}
            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          >
            <option value="">All Categories</option>
            <option value="button">Buttons</option>
            <option value="card">Cards</option>
            <option value="form">Forms</option>
            <option value="navigation">Navigation</option>
            <option value="layout">Layouts</option>
            <option value="icon">Icons</option>
            <option value="custom">Custom</option>
          </select>
        </div>
      </div>
      <!-- Component List -->
      <div class="flex-1 overflow-y-auto p-4">
        <%= if Enum.empty?(@filtered_components) do %>
          <div class="text-center py-8 text-gray-500">
            <svg
              class="mx-auto w-12 h-12 text-gray-400 mb-2"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"
              />
            </svg>
            <p class="text-sm">No components found</p>
            <%= if @search_query != "" || @selected_category do %>
              <p class="text-xs mt-1">Try adjusting your search or filter</p>
            <% end %>
          </div>
        <% else %>
          <%= for {category, components} <- group_components_by_category(@filtered_components) do %>
            <div class="mb-4">
              <!-- Category Header -->
              <button
                phx-click="toggle_category"
                phx-target={@myself}
                phx-value-category={category}
                class="w-full flex items-center justify-between px-3 py-2 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors mb-2"
              >
                <div class="flex items-center gap-2">
                  <svg
                    class={"w-5 h-5 text-#{category_color(category)}-600 transition-transform #{if MapSet.member?(@expanded_categories, category), do: "rotate-90", else: ""}"}
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M9 5l7 7-7 7"
                    />
                  </svg>
                  <span class="font-medium text-gray-700 capitalize"><%= category %></span>
                  <span class="text-xs text-gray-500">(<%= length(components) %>)</span>
                </div>
              </button>
              <!-- Component Cards -->
              <%= if MapSet.member?(@expanded_categories, category) do %>
                <div class="space-y-2 pl-2">
                  <%= for component <- components do %>
                    <div
                      id={"component-#{component.id}"}
                      draggable="true"
                      phx-hook="ComponentDraggable"
                      data-component-id={component.id}
                      class="group relative bg-white border border-gray-200 rounded-lg p-3 hover:border-blue-400 hover:shadow-md transition-all cursor-move"
                    >
                      <!-- Thumbnail -->
                      <div class="flex items-start gap-3">
                        <div class="flex-shrink-0 w-16 h-16 bg-gray-100 rounded-lg overflow-hidden border border-gray-200">
                          <img
                            src={generate_thumbnail_url(component)}
                            alt={component.name}
                            class="w-full h-full object-cover"
                          />
                        </div>
                        <!-- Info -->
                        <div class="flex-1 min-w-0">
                          <h3 class="font-medium text-gray-900 truncate">{component.name}</h3>
                          <p class="text-xs text-gray-500 capitalize mt-0.5">
                            {component.category || "custom"}
                          </p>
                          <%= if component.description do %>
                            <p class="text-xs text-gray-600 mt-1 line-clamp-2">
                              {component.description}
                            </p>
                          <% end %>
                        </div>
                      </div>
                      <!-- Drag Indicator -->
                      <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
                        <svg class="w-5 h-5 text-gray-400" fill="currentColor" viewBox="0 0 24 24">
                          <path d="M9 3h2v2H9V3zm0 4h2v2H9V7zm0 4h2v2H9v-2zm0 4h2v2H9v-2zm0 4h2v2H9v-2zm4-16h2v2h-2V3zm0 4h2v2h-2V7zm0 4h2v2h-2v-2zm0 4h2v2h-2v-2zm0 4h2v2h-2v-2z" />
                        </svg>
                      </div>
                    </div>
                  <% end %>
                </div>
              <% end %>
            </div>
          <% end %>
        <% end %>
      </div>
      <!-- Footer Info -->
      <div class="p-4 border-t border-gray-200 bg-gray-50">
        <div class="flex items-center justify-between text-xs text-gray-600">
          <span><%= length(@filtered_components) %> components</span>
          <span class="text-gray-500">Showing <%= length(@filtered_components) %> of <%= length(@components) %></span>
        </div>
      </div>
    </div>
    """
  end
end
</file>

<file path="lib/collab_canvas_web/live/dashboard_live.ex">
defmodule CollabCanvasWeb.DashboardLive do
  @moduledoc """
  LiveView module for the canvas dashboard and management interface.

  The DashboardLive module provides the main user interface for managing canvases,
  including listing all available canvases, creating new canvases, and deleting
  existing ones. This is the central hub where users can see all their canvases
  and navigate to individual canvas editing sessions.

  ## Features

  - **Canvas Listing**: Displays all canvases in the system with metadata including
    creator, creation date, and last updated timestamp
  - **Canvas Creation**: Interactive form for creating new named canvases
  - **Canvas Deletion**: Ability to delete canvases with confirmation
  - **User Access Control**: Requires authentication to access the dashboard
  - **Navigation**: Provides links to navigate to individual canvas editing interfaces

  ## Access Control

  This LiveView requires authentication. Unauthenticated users are redirected to
  the home page with a flash message indicating they must log in.

  ## State Management

  The module maintains the following socket assigns:
  - `:canvases` - List of all available canvases
  - `:user` / `:current_user` - The currently logged-in user
  - `:show_create_form` - Boolean flag controlling create form visibility
  - `:new_canvas_name` - String storing the new canvas name input

  ## Navigation Flow

  Users can navigate from this dashboard to individual canvas editing sessions by
  clicking "Open" on any canvas card, which redirects to `/canvas/:id` where the
  CanvasLive module takes over.
  """
  use CollabCanvasWeb, :live_view

  alias CollabCanvas.Canvases
  alias CollabCanvasWeb.Plugs.Auth

  @doc """
  Mounts the dashboard LiveView and loads user-specific canvas data.

  This callback is invoked when a user first navigates to the dashboard.
  It performs authentication checks and initializes the dashboard state.

  ## Parameters

  - `_params`: URL parameters (unused in this implementation)
  - `session`: The session map containing authentication tokens
  - `socket`: The LiveView socket

  ## Returns

  - `{:ok, socket}` with canvases loaded if user is authenticated
  - `{:ok, socket}` with redirect if user is not authenticated

  ## Authentication

  Uses the `Auth.assign_current_user/2` plug to verify authentication.
  If no user is found in the session, redirects to home page with an error flash.

  ## Initial State

  On successful mount, the socket is assigned:
  - All canvases in the system via `Canvases.list_all_canvases/0`
  - The authenticated user
  - `show_create_form: false` (form hidden by default)
  - `new_canvas_name: ""` (empty canvas name input)
  """
  @impl true
  def mount(_params, session, socket) do
    socket = Auth.assign_current_user(socket, session)

    case socket.assigns.current_user do
      nil ->
        {:ok,
         socket
         |> put_flash(:error, "You must be logged in to access the dashboard.")
         |> redirect(to: "/")}

      user ->
        canvases = Canvases.list_all_canvases()

        {:ok,
         socket
         |> assign(:canvases, canvases)
         |> assign(:user, user)
         |> assign(:show_create_form, false)
         |> assign(:new_canvas_name, "")}
    end
  end

  @doc """
  Toggles the visibility of the canvas creation form.

  This event handler shows or hides the inline form for creating a new canvas.
  It's triggered by clicking the "New Canvas" or "Cancel" button.

  ## Parameters

  - `_params`: Event parameters (unused)
  - `socket`: The current LiveView socket

  ## Returns

  - `{:noreply, socket}` with `:show_create_form` toggled

  ## Behavior

  Flips the boolean value of `socket.assigns.show_create_form`, causing the
  form to appear if it was hidden, or disappear if it was visible.
  """
  @impl true
  def handle_event("toggle_create_form", _params, socket) do
    {:noreply, assign(socket, :show_create_form, !socket.assigns.show_create_form)}
  end

  @doc """
  Updates the new canvas name input value in the socket state.

  This event handler is triggered when the user types in the canvas name input field.
  It captures the input value and stores it in the socket assigns for form state management.

  ## Parameters

  - `%{"value" => name}`: Event parameters containing the current input field value
  - `socket`: The current LiveView socket

  ## Returns

  - `{:noreply, socket}` with `:new_canvas_name` updated to the new value

  ## Usage

  Connected to the canvas name input field via `phx-blur="update_name"`, though
  could also be used with `phx-change` for real-time updates.
  """
  @impl true
  def handle_event("update_name", %{"value" => name}, socket) do
    {:noreply, assign(socket, :new_canvas_name, name)}
  end

  @doc """
  Creates a new canvas and updates the dashboard canvas list.

  This event handler processes canvas creation form submissions. It creates a new
  canvas associated with the current user, refreshes the canvas list, and navigates
  the user to the newly created canvas editing interface.

  ## Parameters

  - `%{"name" => name}`: Event parameters containing the canvas name from the form
  - `socket`: The current LiveView socket with the authenticated user

  ## Returns

  - `{:noreply, socket}` with updated state and navigation on success
  - `{:noreply, socket}` with error flash on failure

  ## Success Flow

  On successful canvas creation:
  1. Creates the canvas via `Canvases.create_canvas/2`
  2. Reloads the canvas list to include the new canvas
  3. Hides the creation form
  4. Clears the canvas name input
  5. Shows a success flash message
  6. Navigates to the new canvas editing page at `/canvas/:id`

  ## Error Handling

  If canvas creation fails (e.g., validation errors):
  1. Extracts error messages from the Ecto changeset
  2. Displays them in a flash message
  3. Keeps the form visible for correction

  ## Validation

  Canvas name validation is handled by the `Canvases.create_canvas/2` function
  and includes checks like presence, length constraints, etc.
  """
  @impl true
  def handle_event("create_canvas", %{"name" => name}, socket) do
    user = socket.assigns.current_user

    case Canvases.create_canvas(user.id, name) do
      {:ok, canvas} ->
        canvases = Canvases.list_all_canvases()

        {:noreply,
         socket
         |> assign(:canvases, canvases)
         |> assign(:show_create_form, false)
         |> assign(:new_canvas_name, "")
         |> put_flash(:info, "Canvas '#{canvas.name}' created successfully!")
         |> push_navigate(to: "/canvas/#{canvas.id}")}

      {:error, changeset} ->
        errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)
        error_message = errors |> Map.values() |> List.flatten() |> Enum.join(", ")

        {:noreply,
         socket
         |> put_flash(:error, "Failed to create canvas: #{error_message}")}
    end
  end

  @doc """
  Deletes a canvas and refreshes the dashboard canvas list.

  This event handler processes canvas deletion requests. It deletes the specified
  canvas from the database and updates the UI to reflect the change.

  ## Parameters

  - `%{"id" => canvas_id_str}`: Event parameters containing the canvas ID as a string
  - `socket`: The current LiveView socket

  ## Returns

  - `{:noreply, socket}` with updated canvas list and success flash on success
  - `{:noreply, socket}` with error flash on failure

  ## Success Flow

  On successful canvas deletion:
  1. Converts the string canvas ID to an integer
  2. Deletes the canvas via `Canvases.delete_canvas/1`
  3. Reloads the canvas list without the deleted canvas
  4. Shows a success flash message with the deleted canvas name

  ## Error Handling

  If canvas deletion fails:
  1. Shows a generic error flash message
  2. Keeps the canvas in the list

  ## UI Confirmation

  The deletion button in the template includes a `data-confirm` attribute that
  shows a browser confirmation dialog before triggering this event handler,
  helping prevent accidental deletions.

  ## Authorization

  Currently, this handler doesn't check if the current user has permission to
  delete the canvas. Consider adding authorization checks in production.
  """
  @impl true
  def handle_event("delete_canvas", %{"id" => canvas_id_str}, socket) do
    canvas_id = String.to_integer(canvas_id_str)

    case Canvases.delete_canvas(canvas_id) do
      {:ok, canvas} ->
        canvases = Canvases.list_all_canvases()

        {:noreply,
         socket
         |> assign(:canvases, canvases)
         |> put_flash(:info, "Canvas '#{canvas.name}' deleted successfully.")}

      {:error, _changeset} ->
        {:noreply,
         socket
         |> put_flash(:error, "Failed to delete canvas.")}
    end
  end

  @doc """
  Renders the dashboard HTML template.

  This callback generates the HTML for the dashboard interface, including the
  header, canvas creation form, and canvas grid display.

  ## Parameters

  - `assigns`: Map of template assigns including:
    - `:current_user` - The authenticated user
    - `:canvases` - List of all canvases
    - `:show_create_form` - Boolean controlling form visibility
    - `:new_canvas_name` - Current value of the canvas name input

  ## Template Structure

  - **Header**: Displays user welcome message and navigation links (Home, Logout)
  - **Create Button**: Toggles the canvas creation form
  - **Create Form**: Inline form for creating new canvases (conditionally shown)
  - **Empty State**: Friendly message when no canvases exist
  - **Canvas Grid**: Responsive grid of canvas cards with Open and Delete actions

  ## Canvas Cards

  Each canvas card displays:
  - Canvas name
  - Creator information
  - Last updated timestamp
  - "Open" button linking to `/canvas/:id`
  - "Delete" button with confirmation dialog

  ## Responsive Design

  The grid uses Tailwind CSS classes for responsive layouts:
  - Mobile: Single column
  - Tablet (md): 2 columns
  - Desktop (lg): 3 columns
  """
  @impl true
  def render(assigns) do
    ~H"""
    <div class="min-h-screen bg-gray-100">
      <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <header class="flex justify-between items-center mb-8">
          <div>
            <h1 class="text-3xl font-bold text-gray-900">My Canvases</h1>
            <p class="text-gray-600 mt-1">
              Welcome back, <%= @current_user.name || @current_user.email %>
            </p>
          </div>

          <div class="flex items-center gap-4">
            <a href="/" class="px-4 py-2 text-gray-700 hover:text-gray-900 transition">
              Home
            </a>
            <a
              href="/auth/logout"
              class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition"
            >
              Logout
            </a>
          </div>
        </header>

        <!-- Create Canvas Button -->
        <div class="mb-6">
          <button
            phx-click="toggle_create_form"
            class="px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold"
          >
            <%= if @show_create_form, do: "Cancel", else: "+ New Canvas" %>
          </button>
        </div>

        <!-- Create Canvas Form -->
        <%= if @show_create_form do %>
          <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <h3 class="text-xl font-semibold mb-4">Create New Canvas</h3>
            <form phx-submit="create_canvas" class="flex gap-4">
              <input
                type="text"
                name="name"
                value={@new_canvas_name}
                phx-blur="update_name"
                placeholder="Canvas name..."
                class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                required
              />
              <button
                type="submit"
                class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition"
              >
                Create
              </button>
            </form>
          </div>
        <% end %>

        <!-- Canvas List -->
        <%= if Enum.empty?(@canvases) do %>
          <div class="bg-white p-12 rounded-lg shadow-md text-center">
            <div class="text-6xl mb-4">🎨</div>
            <h3 class="text-2xl font-semibold text-gray-900 mb-2">No canvases yet</h3>
            <p class="text-gray-600 mb-6">
              Create your first canvas to start collaborating!
            </p>
            <button
              phx-click="toggle_create_form"
              class="px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold"
            >
              Create Canvas
            </button>
          </div>
        <% else %>
          <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
            <%= for canvas <- @canvases do %>
              <div class="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition">
                <h3 class="text-xl font-semibold text-gray-900 mb-2"><%= canvas.name %></h3>
                <p class="text-sm text-gray-600 mb-1">
                  Created by <%= canvas.user.name || canvas.user.email %>
                </p>
                <p class="text-sm text-gray-500 mb-4">
                  Updated <%= Calendar.strftime(canvas.updated_at, "%B %d, %Y") %>
                </p>

                <div class="flex gap-2">
                  <a
                    href={"/canvas/#{canvas.id}"}
                    class="flex-1 text-center px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition"
                  >
                    Open
                  </a>
                  <button
                    phx-click="delete_canvas"
                    phx-value-id={canvas.id}
                    data-confirm="Are you sure you want to delete this canvas?"
                    class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition"
                  >
                    Delete
                  </button>
                </div>
              </div>
            <% end %>
          </div>
        <% end %>
      </div>
    </div>
    """
  end
end
</file>

<file path="lib/collab_canvas_web/live/styles_panel_live.ex">
defmodule CollabCanvasWeb.StylesPanelLive do
  @moduledoc """
  LiveView component for managing color palettes, text styles, and effects.

  This module provides a complete styles management panel with real-time
  synchronization across multiple users. It integrates with the Styles context
  to provide CRUD operations for design styles and design token export.

  ## Features

  ### Style Management
  - Create, update, and delete color, text, and effect styles
  - Apply styles to canvas objects with one click
  - Real-time synchronization via PubSub
  - Style categories for organization (primary, secondary, heading, body, etc.)

  ### Design Token Export
  - Export styles in multiple formats: CSS, SCSS, JSON, JavaScript
  - Download design tokens for use in other projects
  - Maintains consistency across design and development

  ### Real-time Collaboration
  - All style changes are broadcast to connected collaborators
  - PubSub integration ensures instant updates
  - Performance target: < 50ms for style application

  ## State Management

  The socket assigns include:
  - `:canvas_id` - Canvas identifier for loading styles
  - `:styles` - List of all styles for this canvas
  - `:selected_style` - Currently selected style for preview
  - `:show_modal` - Boolean indicating if creation modal is open
  - `:modal_type` - Type of style being created ("color", "text", "effect")
  - `:export_format` - Selected export format for design tokens
  - `:topic` - PubSub topic string for style updates

  ## Usage

  This component is typically rendered as a side panel in the canvas view:

      <.live_component
        module={CollabCanvasWeb.StylesPanelLive}
        id="styles-panel"
        canvas_id={@canvas_id}
      />
  """

  use CollabCanvasWeb, :live_component

  alias CollabCanvas.Styles
  alias Phoenix.PubSub

  require Logger

  @impl true
  def mount(socket) do
    {:ok, socket}
  end

  @impl true
  def update(%{canvas_id: canvas_id} = assigns, socket) do
    # Subscribe to style changes if not already subscribed
    if connected?(socket) do
      topic = "styles:#{canvas_id}"
      PubSub.subscribe(CollabCanvas.PubSub, topic)
    end

    # Load all styles for this canvas
    styles = Styles.list_styles(canvas_id)

    {:ok,
     socket
     |> assign(assigns)
     |> assign(:canvas_id, canvas_id)
     |> assign(:styles, styles)
     |> assign(:selected_style, nil)
     |> assign(:show_modal, false)
     |> assign(:modal_type, "color")
     |> assign(:export_format, "css")
     |> assign(:topic, "styles:#{canvas_id}")}
  end

  @impl true
  def handle_event("open_create_modal", %{"type" => type}, socket) do
    {:noreply,
     socket
     |> assign(:show_modal, true)
     |> assign(:modal_type, type)}
  end

  @impl true
  def handle_event("close_modal", _params, socket) do
    {:noreply, assign(socket, :show_modal, false)}
  end

  @impl true
  def handle_event("create_style", params, socket) do
    canvas_id = socket.assigns.canvas_id
    style_type = params["type"]

    # Build style attributes based on type
    attrs = %{
      name: params["name"],
      type: style_type,
      category: params["category"],
      definition: build_definition(style_type, params)
    }

    case Styles.create_style(canvas_id, attrs) do
      {:ok, style} ->
        # Update local state (broadcast is handled by Styles context)
        styles = [style | socket.assigns.styles]

        {:noreply,
         socket
         |> assign(:styles, styles)
         |> assign(:show_modal, false)
         |> put_flash(:info, "Style '#{style.name}' created successfully")}

      {:error, changeset} ->
        errors = format_changeset_errors(changeset)

        {:noreply,
         socket
         |> put_flash(:error, "Failed to create style: #{errors}")}
    end
  end

  @impl true
  def handle_event("update_style", %{"id" => style_id} = params, socket) do
    style_id = String.to_integer(style_id)

    attrs = %{
      name: params["name"],
      category: params["category"],
      definition: build_definition(params["type"], params)
    }

    case Styles.update_style(style_id, attrs) do
      {:ok, updated_style} ->
        # Update local state
        styles =
          Enum.map(socket.assigns.styles, fn style ->
            if style.id == updated_style.id, do: updated_style, else: style
          end)

        {:noreply,
         socket
         |> assign(:styles, styles)
         |> put_flash(:info, "Style '#{updated_style.name}' updated successfully")}

      {:error, :not_found} ->
        {:noreply, put_flash(socket, :error, "Style not found")}

      {:error, changeset} ->
        errors = format_changeset_errors(changeset)

        {:noreply,
         socket
         |> put_flash(:error, "Failed to update style: #{errors}")}
    end
  end

  @impl true
  def handle_event("delete_style", %{"id" => style_id}, socket) do
    style_id = String.to_integer(style_id)

    case Styles.delete_style(style_id) do
      {:ok, deleted_style} ->
        # Update local state
        styles = Enum.reject(socket.assigns.styles, fn s -> s.id == deleted_style.id end)

        {:noreply,
         socket
         |> assign(:styles, styles)
         |> put_flash(:info, "Style '#{deleted_style.name}' deleted successfully")}

      {:error, :not_found} ->
        {:noreply, put_flash(socket, :error, "Style not found")}
    end
  end

  @impl true
  def handle_event("apply_style", %{"style_id" => style_id, "object_id" => object_id}, socket) do
    style_id = String.to_integer(style_id)
    object_id = String.to_integer(object_id)

    case Styles.apply_style(object_id, style_id) do
      {:ok, _updated_object} ->
        {:noreply,
         socket
         |> put_flash(:info, "Style applied successfully")}

      {:error, :not_found} ->
        {:noreply, put_flash(socket, :error, "Style or object not found")}

      {:error, :incompatible_type} ->
        {:noreply, put_flash(socket, :error, "Cannot apply this style to the selected object")}

      {:error, reason} ->
        {:noreply, put_flash(socket, :error, "Failed to apply style: #{inspect(reason)}")}
    end
  end

  @impl true
  def handle_event("select_export_format", %{"format" => format}, socket) do
    {:noreply, assign(socket, :export_format, format)}
  end

  @impl true
  def handle_event("export_design_tokens", _params, socket) do
    canvas_id = socket.assigns.canvas_id
    format = String.to_atom(socket.assigns.export_format)

    case Styles.export_design_tokens(canvas_id, format) do
      {:ok, tokens} ->
        # Send download event to client
        send(self(), {:download_tokens, tokens, format})

        {:noreply,
         socket
         |> put_flash(:info, "Design tokens exported as #{format}")}

      {:error, reason} ->
        {:noreply,
         socket
         |> put_flash(:error, "Failed to export: #{reason}")}
    end
  end

  @impl true
  def handle_event("select_style", %{"id" => style_id}, socket) do
    style_id = String.to_integer(style_id)
    selected_style = Enum.find(socket.assigns.styles, &(&1.id == style_id))

    {:noreply, assign(socket, :selected_style, selected_style)}
  end

  # Handle PubSub broadcasts for style changes
  @impl true
  def handle_info({:style_created, style}, socket) do
    # Check if style is already in our list (deduplication)
    exists? = Enum.any?(socket.assigns.styles, fn s -> s.id == style.id end)

    if exists? do
      {:noreply, socket}
    else
      styles = [style | socket.assigns.styles]
      {:noreply, assign(socket, :styles, styles)}
    end
  end

  @impl true
  def handle_info({:style_updated, updated_style}, socket) do
    styles =
      Enum.map(socket.assigns.styles, fn style ->
        if style.id == updated_style.id, do: updated_style, else: style
      end)

    {:noreply, assign(socket, :styles, styles)}
  end

  @impl true
  def handle_info({:style_deleted, style_id}, socket) do
    styles = Enum.reject(socket.assigns.styles, fn s -> s.id == style_id end)

    # Clear selection if deleted style was selected
    selected_style =
      if socket.assigns.selected_style && socket.assigns.selected_style.id == style_id do
        nil
      else
        socket.assigns.selected_style
      end

    {:noreply,
     socket
     |> assign(:styles, styles)
     |> assign(:selected_style, selected_style)}
  end

  @impl true
  def handle_info({:download_tokens, tokens, format}, socket) do
    # Push download event to JavaScript
    {:noreply,
     push_event(socket, "download_tokens", %{
       content: tokens,
       filename: "design-tokens.#{format}",
       format: format
     })}
  end

  # Helper to build style definition based on type
  defp build_definition("color", params) do
    %{
      "r" => String.to_integer(params["r"] || "0"),
      "g" => String.to_integer(params["g"] || "0"),
      "b" => String.to_integer(params["b"] || "0"),
      "a" => String.to_float(params["a"] || "1.0")
    }
  end

  defp build_definition("text", params) do
    %{
      "fontFamily" => params["fontFamily"] || "inherit",
      "fontSize" => String.to_integer(params["fontSize"] || "16"),
      "fontWeight" => String.to_integer(params["fontWeight"] || "400"),
      "lineHeight" => String.to_float(params["lineHeight"] || "1.5")
    }
  end

  defp build_definition("effect", params) do
    %{
      "type" => params["effectType"] || "shadow",
      "offsetX" => String.to_integer(params["offsetX"] || "0"),
      "offsetY" => String.to_integer(params["offsetY"] || "0"),
      "blur" => String.to_integer(params["blur"] || "0"),
      "color" => params["effectColor"] || "rgba(0,0,0,0.5)"
    }
  end

  defp build_definition(_, _params), do: %{}

  # Helper to format changeset errors
  defp format_changeset_errors(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
      Enum.reduce(opts, msg, fn {key, value}, acc ->
        String.replace(acc, "%{#{key}}", to_string(value))
      end)
    end)
    |> Enum.map(fn {field, errors} -> "#{field}: #{Enum.join(errors, ", ")}" end)
    |> Enum.join("; ")
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="h-full flex flex-col bg-white">
      <!-- Header -->
      <div class="p-4 border-b border-gray-200">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-lg font-semibold text-gray-800">Styles</h2>
          <button
            phx-click="export_design_tokens"
            phx-target={@myself}
            class="text-sm px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
            title="Export design tokens"
          >
            Export
          </button>
        </div>
        <p class="text-sm text-gray-500">Manage colors, text styles, and effects</p>
      </div>

      <!-- Export Format Selector -->
      <div class="px-4 py-2 border-b border-gray-200 bg-gray-50">
        <label class="block text-xs font-medium text-gray-700 mb-1">Export Format</label>
        <select
          phx-change="select_export_format"
          phx-target={@myself}
          class="w-full text-sm border border-gray-300 rounded-md px-2 py-1"
        >
          <option value="css" selected={@export_format == "css"}>CSS Custom Properties</option>
          <option value="scss" selected={@export_format == "scss"}>SCSS Variables</option>
          <option value="json" selected={@export_format == "json"}>JSON</option>
          <option value="js" selected={@export_format == "js"}>JavaScript/TypeScript</option>
        </select>
      </div>

      <!-- Styles List -->
      <div class="flex-1 overflow-y-auto">
        <!-- Color Styles Section -->
        <div class="p-4 border-b border-gray-200">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-sm font-semibold text-gray-700 uppercase tracking-wide">Colors</h3>
            <button
              phx-click="open_create_modal"
              phx-value-type="color"
              phx-target={@myself}
              class="text-xs px-2 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
            >
              + Add
            </button>
          </div>

          <div class="grid grid-cols-4 gap-2">
            <%= for style <- Enum.filter(@styles, &(&1.type == "color")) do %>
              <div
                phx-click="select_style"
                phx-value-id={style.id}
                phx-target={@myself}
                class={[
                  "aspect-square rounded-lg cursor-pointer border-2 transition-all group relative",
                  @selected_style && @selected_style.id == style.id &&
                    "border-blue-500 ring-2 ring-blue-200",
                  (!@selected_style || @selected_style.id != style.id) && "border-gray-200 hover:border-gray-300"
                ]}
                style={"background-color: #{format_color(style)}"}
                title={style.name}
              >
                <button
                  phx-click="delete_style"
                  phx-value-id={style.id}
                  phx-target={@myself}
                  class="absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity bg-white rounded-full p-0.5 shadow-sm"
                  title="Delete"
                >
                  <svg class="w-3 h-3 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M6 18L18 6M6 6l12 12"
                    />
                  </svg>
                </button>
              </div>
            <% end %>
          </div>

          <%= if Enum.empty?(Enum.filter(@styles, &(&1.type == "color"))) do %>
            <p class="text-sm text-gray-400 text-center py-4">No color styles yet</p>
          <% end %>
        </div>

        <!-- Text Styles Section -->
        <div class="p-4 border-b border-gray-200">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-sm font-semibold text-gray-700 uppercase tracking-wide">Text Styles</h3>
            <button
              phx-click="open_create_modal"
              phx-value-type="text"
              phx-target={@myself}
              class="text-xs px-2 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
            >
              + Add
            </button>
          </div>

          <div class="space-y-2">
            <%= for style <- Enum.filter(@styles, &(&1.type == "text")) do %>
              <div
                phx-click="select_style"
                phx-value-id={style.id}
                phx-target={@myself}
                class={[
                  "p-3 rounded-lg border cursor-pointer transition-all group relative",
                  @selected_style && @selected_style.id == style.id &&
                    "border-blue-500 bg-blue-50",
                  (!@selected_style || @selected_style.id != style.id) &&
                    "border-gray-200 hover:border-gray-300 hover:bg-gray-50"
                ]}
              >
                <div class="flex items-start justify-between">
                  <div class="flex-1">
                    <div class="text-sm font-medium text-gray-900 mb-1"><%= style.name %></div>
                    <div class="text-xs text-gray-500" style={format_text_preview(style)}>
                      The quick brown fox
                    </div>
                  </div>
                  <button
                    phx-click="delete_style"
                    phx-value-id={style.id}
                    phx-target={@myself}
                    class="opacity-0 group-hover:opacity-100 transition-opacity text-red-600 hover:text-red-800"
                    title="Delete"
                  >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M6 18L18 6M6 6l12 12"
                      />
                    </svg>
                  </button>
                </div>
              </div>
            <% end %>
          </div>

          <%= if Enum.empty?(Enum.filter(@styles, &(&1.type == "text"))) do %>
            <p class="text-sm text-gray-400 text-center py-4">No text styles yet</p>
          <% end %>
        </div>

        <!-- Effect Styles Section -->
        <div class="p-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-sm font-semibold text-gray-700 uppercase tracking-wide">Effects</h3>
            <button
              phx-click="open_create_modal"
              phx-value-type="effect"
              phx-target={@myself}
              class="text-xs px-2 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
            >
              + Add
            </button>
          </div>

          <div class="space-y-2">
            <%= for style <- Enum.filter(@styles, &(&1.type == "effect")) do %>
              <div
                phx-click="select_style"
                phx-value-id={style.id}
                phx-target={@myself}
                class={[
                  "p-3 rounded-lg border cursor-pointer transition-all group relative",
                  @selected_style && @selected_style.id == style.id &&
                    "border-blue-500 bg-blue-50",
                  (!@selected_style || @selected_style.id != style.id) &&
                    "border-gray-200 hover:border-gray-300 hover:bg-gray-50"
                ]}
              >
                <div class="flex items-center justify-between">
                  <div class="text-sm font-medium text-gray-900"><%= style.name %></div>
                  <button
                    phx-click="delete_style"
                    phx-value-id={style.id}
                    phx-target={@myself}
                    class="opacity-0 group-hover:opacity-100 transition-opacity text-red-600 hover:text-red-800"
                    title="Delete"
                  >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M6 18L18 6M6 6l12 12"
                      />
                    </svg>
                  </button>
                </div>
              </div>
            <% end %>
          </div>

          <%= if Enum.empty?(Enum.filter(@styles, &(&1.type == "effect"))) do %>
            <p class="text-sm text-gray-400 text-center py-4">No effect styles yet</p>
          <% end %>
        </div>
      </div>

      <!-- Style Creation Modal -->
      <%= if @show_modal do %>
        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4">
            <div class="p-4 border-b border-gray-200 flex items-center justify-between">
              <h3 class="text-lg font-semibold text-gray-900">
                Create <%= String.capitalize(@modal_type) %> Style
              </h3>
              <button
                phx-click="close_modal"
                phx-target={@myself}
                class="text-gray-400 hover:text-gray-600"
              >
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>

            <form phx-submit="create_style" phx-target={@myself} class="p-4 space-y-4">
              <input type="hidden" name="type" value={@modal_type} />

              <!-- Name Field -->
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Name</label>
                <input
                  type="text"
                  name="name"
                  required
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  placeholder="e.g., Primary Blue"
                />
              </div>

              <!-- Category Field -->
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Category</label>
                <select
                  name="category"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                >
                  <%= if @modal_type == "color" do %>
                    <option value="primary">Primary</option>
                    <option value="secondary">Secondary</option>
                    <option value="accent">Accent</option>
                    <option value="neutral">Neutral</option>
                  <% end %>
                  <%= if @modal_type == "text" do %>
                    <option value="heading">Heading</option>
                    <option value="body">Body</option>
                    <option value="caption">Caption</option>
                  <% end %>
                  <%= if @modal_type == "effect" do %>
                    <option value="shadow">Shadow</option>
                    <option value="blur">Blur</option>
                  <% end %>
                </select>
              </div>

              <!-- Type-specific Fields -->
              <%= if @modal_type == "color" do %>
                <div class="grid grid-cols-4 gap-2">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">R</label>
                    <input
                      type="number"
                      name="r"
                      min="0"
                      max="255"
                      value="0"
                      required
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">G</label>
                    <input
                      type="number"
                      name="g"
                      min="0"
                      max="255"
                      value="0"
                      required
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">B</label>
                    <input
                      type="number"
                      name="b"
                      min="0"
                      max="255"
                      value="0"
                      required
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">A</label>
                    <input
                      type="number"
                      name="a"
                      min="0"
                      max="1"
                      step="0.1"
                      value="1.0"
                      required
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                </div>
              <% end %>

              <%= if @modal_type == "text" do %>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Font Family</label>
                  <input
                    type="text"
                    name="fontFamily"
                    value="Arial, sans-serif"
                    required
                    class="w-full px-3 py-2 border border-gray-300 rounded-md"
                  />
                </div>
                <div class="grid grid-cols-3 gap-2">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Size (px)</label>
                    <input
                      type="number"
                      name="fontSize"
                      value="16"
                      required
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Weight</label>
                    <input
                      type="number"
                      name="fontWeight"
                      value="400"
                      required
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Line Height</label>
                    <input
                      type="number"
                      name="lineHeight"
                      step="0.1"
                      value="1.5"
                      required
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                </div>
              <% end %>

              <%= if @modal_type == "effect" do %>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Effect Type</label>
                  <select
                    name="effectType"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md"
                  >
                    <option value="shadow">Shadow</option>
                    <option value="blur">Blur</option>
                  </select>
                </div>
                <div class="grid grid-cols-3 gap-2">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Offset X</label>
                    <input
                      type="number"
                      name="offsetX"
                      value="0"
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Offset Y</label>
                    <input
                      type="number"
                      name="offsetY"
                      value="2"
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Blur</label>
                    <input
                      type="number"
                      name="blur"
                      value="4"
                      class="w-full px-2 py-2 border border-gray-300 rounded-md text-sm"
                    />
                  </div>
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Color</label>
                  <input
                    type="text"
                    name="effectColor"
                    value="rgba(0,0,0,0.5)"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md"
                  />
                </div>
              <% end %>

              <!-- Actions -->
              <div class="flex items-center justify-end gap-2 pt-4">
                <button
                  type="button"
                  phx-click="close_modal"
                  phx-target={@myself}
                  class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50 transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                >
                  Create Style
                </button>
              </div>
            </form>
          </div>
        </div>
      <% end %>
    </div>
    """
  end

  # Helper to format color for display
  defp format_color(style) do
    definition = Styles.Style.decode_definition(style)

    case definition do
      %{"r" => r, "g" => g, "b" => b, "a" => a} when a < 1.0 ->
        "rgba(#{r}, #{g}, #{b}, #{a})"

      %{"r" => r, "g" => g, "b" => b} ->
        "rgb(#{r}, #{g}, #{b})"

      _ ->
        "#cccccc"
    end
  end

  # Helper to format text style for preview
  defp format_text_preview(style) do
    definition = Styles.Style.decode_definition(style)

    [
      "font-family: #{definition["fontFamily"] || "inherit"}",
      "font-size: #{definition["fontSize"] || 16}px",
      "font-weight: #{definition["fontWeight"] || 400}",
      "line-height: #{definition["lineHeight"] || 1.5}"
    ]
    |> Enum.join("; ")
  end
end
</file>

<file path="lib/collab_canvas_web/plugs/auth.ex">
defmodule CollabCanvasWeb.Plugs.Auth do
  @moduledoc """
  Authentication plug for protecting routes and LiveViews.

  This plug checks if a user is authenticated by verifying the session.
  It can be used in the router pipeline or individual controller/LiveView actions.
  """

  import Plug.Conn
  import Phoenix.Controller

  alias CollabCanvas.Accounts

  @doc """
  Loads the current user from the session.

  ## Usage

  In your router:

      pipeline :authenticated do
        plug CollabCanvasWeb.Plugs.Auth, :load_current_user
      end

  In a LiveView:

      def mount(_params, session, socket) do
        socket = assign_current_user(socket, session)
        ...
      end
  """
  def init(opts), do: opts

  def call(conn, :load_current_user) do
    case get_session(conn, :user_id) do
      nil ->
        conn
        |> assign(:current_user, nil)

      user_id ->
        case Accounts.get_user(user_id) do
          nil ->
            conn
            |> clear_session()
            |> assign(:current_user, nil)

          user ->
            conn
            |> assign(:current_user, user)
        end
    end
  end

  def call(conn, :require_authenticated) do
    case conn.assigns[:current_user] do
      nil ->
        conn
        |> put_flash(:error, "You must be logged in to access this page.")
        |> redirect(to: "/")
        |> halt()

      _user ->
        conn
    end
  end

  @doc """
  Assigns the current user to a LiveView socket from the session.

  ## Example

      def mount(_params, session, socket) do
        socket = assign_current_user(socket, session)

        if socket.assigns.current_user do
          {:ok, socket}
        else
          {:ok, redirect(socket, to: "/")}
        end
      end
  """
  def assign_current_user(socket, session) do
    case session["user_id"] do
      nil ->
        Phoenix.Component.assign(socket, :current_user, nil)

      user_id ->
        case Accounts.get_user(user_id) do
          nil ->
            Phoenix.Component.assign(socket, :current_user, nil)

          user ->
            Phoenix.Component.assign(socket, :current_user, user)
        end
    end
  end

  @doc """
  Checks if a user is authenticated (has a valid session).

  Returns `true` if the user is logged in, `false` otherwise.
  """
  def authenticated?(conn) do
    conn.assigns[:current_user] != nil
  end

  @doc """
  Gets the current user from the connection assigns.

  Returns `nil` if no user is authenticated.
  """
  def current_user(conn) do
    conn.assigns[:current_user]
  end

  @doc """
  LiveView on_mount hook for authentication.

  ## Usage

      defmodule MyAppWeb.MyLive do
        use MyAppWeb, :live_view

        on_mount {CollabCanvasWeb.Plugs.Auth, :require_authenticated_user}

        ...
      end
  """
  def on_mount(:load_current_user, _params, session, socket) do
    {:cont, assign_current_user(socket, session)}
  end

  def on_mount(:require_authenticated_user, _params, session, socket) do
    socket = assign_current_user(socket, session)

    if socket.assigns.current_user do
      {:cont, socket}
    else
      socket =
        socket
        |> Phoenix.LiveView.put_flash(:error, "You must be logged in to access this page.")
        |> Phoenix.LiveView.redirect(to: "/")

      {:halt, socket}
    end
  end
end
</file>

<file path="lib/collab_canvas_web/endpoint.ex">
defmodule CollabCanvasWeb.Endpoint do
  @moduledoc """
  The HTTP/WebSocket server endpoint for the CollabCanvas application.

  This module configures the Phoenix endpoint that handles all incoming HTTP and WebSocket
  connections. It sets up the Plug pipeline, LiveView sockets, static asset serving, and
  session management for the collaborative canvas application.

  ## HTTP/WebSocket Server

  The endpoint serves as the entry point for all client connections:
  - HTTP requests are processed through the configured Plug pipeline
  - WebSocket connections are established for LiveView real-time updates
  - Static assets are served efficiently with optional gzip compression

  ## LiveView Socket Configuration

  LiveView sockets are mounted at `/live` and support both WebSocket and long-polling
  transports. Session data is passed to LiveView processes via `connect_info`, enabling
  stateful real-time interactions for the collaborative canvas features.

  ## Plug Pipeline

  The endpoint configures a series of Plugs that process requests in order:

  1. `Plug.Static` - Serves static files from `priv/static` with conditional gzip compression
  2. Development-only plugs (when code reloading is enabled):
     - `Phoenix.LiveReloader` - Auto-reloads browser on code changes
     - `Phoenix.CodeReloader` - Recompiles code on each request
     - `Phoenix.Ecto.CheckRepoStatus` - Ensures database is running and migrated
  3. `Phoenix.LiveDashboard.RequestLogger` - Logs requests for LiveDashboard inspection
  4. `Plug.RequestId` - Generates unique request IDs for tracing
  5. `Plug.Telemetry` - Emits telemetry events for monitoring
  6. `Plug.Parsers` - Parses request bodies (URL-encoded, multipart, JSON)
  7. `Plug.MethodOverride` - Allows method override via `_method` parameter
  8. `Plug.Head` - Converts HEAD requests to GET requests
  9. `Plug.Session` - Manages cookie-based session storage
  10. `CollabCanvasWeb.Router` - Routes requests to appropriate controllers/LiveViews

  ## Static Asset Serving

  Static files are served from `priv/static` directory at the root path `/`. In production
  (when code reloading is disabled), assets are served with gzip compression for improved
  performance. Only files matching paths defined in `CollabCanvasWeb.static_paths/0` are
  served.

  ## Session Management

  Sessions are stored in signed cookies to prevent tampering while remaining readable on
  the client side. The session configuration includes:

  - `store: :cookie` - Sessions stored in browser cookies
  - `key: "_collab_canvas_key"` - Cookie name for session data
  - `signing_salt: "baMCDlhj"` - Salt for cryptographic signing
  - `same_site: "Lax"` - CSRF protection via SameSite cookie attribute

  ## Security Considerations

  - Session cookies are cryptographically signed to prevent tampering
  - SameSite attribute set to "Lax" provides CSRF protection
  - Static file serving is restricted to explicitly allowed paths
  - Request logging is available for security auditing via LiveDashboard

  ## Development Features

  When code reloading is enabled (development environment):
  - Live browser reload on file changes
  - Automatic code recompilation
  - Database repository status checks
  - Enhanced debugging via LiveDashboard request logger
  """
  use Phoenix.Endpoint, otp_app: :collab_canvas

  # The session will be stored in the cookie and signed,
  # this means its contents can be read but not tampered with.
  # Set :encryption_salt if you would also like to encrypt it.
  @session_options [
    store: :cookie,
    key: "_collab_canvas_key",
    signing_salt: "baMCDlhj",
    same_site: "Lax"
  ]

  socket "/live", Phoenix.LiveView.Socket,
    websocket: [connect_info: [session: @session_options]],
    longpoll: [connect_info: [session: @session_options]]

  # Serve at "/" the static files from "priv/static" directory.
  #
  # When code reloading is disabled (e.g., in production),
  # the `gzip` option is enabled to serve compressed
  # static files generated by running `phx.digest`.
  plug Plug.Static,
    at: "/",
    from: :collab_canvas,
    gzip: not code_reloading?,
    only: CollabCanvasWeb.static_paths()

  # Code reloading can be explicitly enabled under the
  # :code_reloader configuration of your endpoint.
  if code_reloading? do
    socket "/phoenix/live_reload/socket", Phoenix.LiveReloader.Socket
    plug Phoenix.LiveReloader
    plug Phoenix.CodeReloader
    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :collab_canvas
  end

  plug Phoenix.LiveDashboard.RequestLogger,
    param_key: "request_logger",
    cookie_key: "request_logger"

  plug Plug.RequestId
  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

  plug Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: ["*/*"],
    json_decoder: Phoenix.json_library()

  plug Plug.MethodOverride
  plug Plug.Head
  plug Plug.Session, @session_options
  plug CollabCanvasWeb.Router
end
</file>

<file path="lib/collab_canvas_web/gettext.ex">
defmodule CollabCanvasWeb.Gettext do
  @moduledoc """
  A module providing Internationalization with a gettext-based API.

  By using [Gettext](https://hexdocs.pm/gettext), your module compiles translations
  that you can use in your application. To use this Gettext backend module,
  call `use Gettext` and pass it as an option:

      use Gettext, backend: CollabCanvasWeb.Gettext

      # Simple translation
      gettext("Here is the string to translate")

      # Plural translation
      ngettext("Here is the string to translate",
               "Here are the strings to translate",
               3)

      # Domain-based translation
      dgettext("errors", "Here is the error message to translate")

  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.
  """
  use Gettext.Backend, otp_app: :collab_canvas
end
</file>

<file path="lib/collab_canvas_web/presence.ex">
defmodule CollabCanvasWeb.Presence do
  @moduledoc """
  Provides real-time presence tracking for collaborative features.

  This module tracks online users and their cursor positions using Phoenix Presence,
  which provides CRDT-backed conflict-free replicated data types for distributed
  presence tracking across multiple nodes.

  ## Usage

      # Track a user in a canvas room
      {:ok, _} = Presence.track(self(), "canvas:123", user_id, %{
        online_at: System.system_time(:second),
        cursor: %{x: 0, y: 0},
        color: "#3b82f6",
        name: "User Name"
      })

      # List all present users
      Presence.list("canvas:123")

      # Get presence for a specific user
      Presence.get_by_key("canvas:123", user_id)
  """

  use Phoenix.Presence,
    otp_app: :collab_canvas,
    pubsub_server: CollabCanvas.PubSub
end
</file>

<file path="lib/collab_canvas_web/router.ex">
defmodule CollabCanvasWeb.Router do
  @moduledoc """
  Defines the application's routing structure and request pipelines.

  ## Overview

  This router configures all HTTP routes and LiveView endpoints for the CollabCanvas
  application, organizing them into logical scopes with appropriate pipeline processing.

  ## Pipelines

  ### Browser Pipeline

  The `:browser` pipeline is used for traditional web requests and LiveView connections.
  It includes:

  - HTML content acceptance
  - Session management (`fetch_session`)
  - LiveView flash message support (`fetch_live_flash`)
  - Root layout configuration
  - CSRF protection (`protect_from_forgery`)
  - Security headers (`put_secure_browser_headers`)

  ### API Pipeline

  The `:api` pipeline is used for JSON API endpoints and includes:

  - JSON content acceptance

  ## Routes

  ### Health Check Route

  - `GET /health` - Health check endpoint (no authentication required)
    - Uses API pipeline for JSON responses
    - Handled by `HealthController.index/2`

  ### Main Application Routes (Browser Pipeline)

  - `GET /` - Home page
    - Handled by `PageController.home/2`

  - `GET /dashboard` - Dashboard LiveView
    - Real-time collaborative canvas management interface
    - Handled by `DashboardLive`

  - `GET /canvas/:id` - Individual canvas LiveView
    - Real-time collaborative drawing interface
    - Handles live object manipulation and multi-user collaboration
    - Handled by `CanvasLive`

  ### Authentication Routes (Browser Pipeline)

  OAuth authentication flow using Ueberauth:

  - `GET /auth/logout` - User logout
  - `GET /auth/:provider` - Initiate OAuth flow with provider
  - `GET /auth/:provider/callback` - OAuth callback handler
  - `POST /auth/:provider/callback` - OAuth callback handler (POST variant)

  Supported providers are configured via Ueberauth in the application config.

  ### Development Routes

  When `:dev_routes` is enabled in configuration (development environment):

  - `GET /dev/dashboard` - Phoenix LiveDashboard for monitoring
  - `/dev/mailbox` - Swoosh email preview interface

  **Note:** These routes should be properly secured before enabling in production.

  ## Security Considerations

  - All browser routes include CSRF protection via `:protect_from_forgery`
  - LiveDashboard and development tools are conditionally compiled based on environment
  - Health check endpoint bypasses authentication for monitoring purposes
  - OAuth callbacks support both GET and POST methods for provider compatibility
  """
  use CollabCanvasWeb, :router

  pipeline :browser do
    plug(:accepts, ["html"])
    plug(:fetch_session)
    plug(:fetch_live_flash)
    plug(:put_root_layout, html: {CollabCanvasWeb.Layouts, :root})
    plug(:protect_from_forgery)
    plug(:put_secure_browser_headers)
  end

  pipeline :api do
    plug(:accepts, ["json"])
  end

  # Health check endpoint (no auth required)
  scope "/", CollabCanvasWeb do
    pipe_through(:api)
    get("/health", HealthController, :index)
  end

  scope "/", CollabCanvasWeb do
    pipe_through(:browser)

    get("/", PageController, :home)
    live("/dashboard", DashboardLive)
    live("/canvas/:id", CanvasLive)
  end

  # Auth routes
  scope "/auth", CollabCanvasWeb do
    pipe_through(:browser)

    get("/logout", AuthController, :logout)
    get("/:provider", AuthController, :request)
    get("/:provider/callback", AuthController, :callback)
    post("/:provider/callback", AuthController, :callback)
  end

  # Other scopes may use custom stacks.

  # Enable LiveDashboard and Swoosh mailbox preview in development
  if Application.compile_env(:collab_canvas, :dev_routes) do
    # If you want to use the LiveDashboard in production, you should put
    # it behind authentication and allow only admins to access it.
    # If your application does not have an admins-only section yet,
    # you can use Plug.BasicAuth to set up some basic authentication
    # as long as you are also using SSL (which you should anyway).
    import Phoenix.LiveDashboard.Router

    scope "/dev" do
      pipe_through(:browser)

      live_dashboard("/dashboard", metrics: CollabCanvasWeb.Telemetry)
      forward("/mailbox", Plug.Swoosh.MailboxPreview)
    end
  end
end
</file>

<file path="lib/collab_canvas_web/telemetry.ex">
defmodule CollabCanvasWeb.Telemetry do
  use Supervisor
  import Telemetry.Metrics

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    children = [
      # Telemetry poller will execute the given period measurements
      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
      # Add reporters as children of your supervision tree.
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  def metrics do
    [
      # Phoenix Metrics
      summary("phoenix.endpoint.start.system_time",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.endpoint.stop.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.start.system_time",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.exception.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.stop.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.socket_connected.duration",
        unit: {:native, :millisecond}
      ),
      sum("phoenix.socket_drain.count"),
      summary("phoenix.channel_joined.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_handled_in.duration",
        tags: [:event],
        unit: {:native, :millisecond}
      ),

      # Database Metrics
      summary("collab_canvas.repo.query.total_time",
        unit: {:native, :millisecond},
        description: "The sum of the other measurements"
      ),
      summary("collab_canvas.repo.query.decode_time",
        unit: {:native, :millisecond},
        description: "The time spent decoding the data received from the database"
      ),
      summary("collab_canvas.repo.query.query_time",
        unit: {:native, :millisecond},
        description: "The time spent executing the query"
      ),
      summary("collab_canvas.repo.query.queue_time",
        unit: {:native, :millisecond},
        description: "The time spent waiting for a database connection"
      ),
      summary("collab_canvas.repo.query.idle_time",
        unit: {:native, :millisecond},
        description:
          "The time the connection spent waiting before being checked out for the query"
      ),

      # VM Metrics
      summary("vm.memory.total", unit: {:byte, :kilobyte}),
      summary("vm.total_run_queue_lengths.total"),
      summary("vm.total_run_queue_lengths.cpu"),
      summary("vm.total_run_queue_lengths.io")
    ]
  end

  defp periodic_measurements do
    [
      # A module, function and arguments to be invoked periodically.
      # This function must call :telemetry.execute/3 and a metric must be added above.
      # {CollabCanvasWeb, :count_users, []}
    ]
  end
end
</file>

<file path="lib/collab_canvas_web.ex">
defmodule CollabCanvasWeb do
  @moduledoc """
  The entrypoint for defining your web interface, such
  as controllers, components, channels, and so on.

  This can be used in your application as:

      use CollabCanvasWeb, :controller
      use CollabCanvasWeb, :html

  The definitions below will be executed for every controller,
  component, etc, so keep them short and clean, focused
  on imports, uses and aliases.

  Do NOT define functions inside the quoted expressions
  below. Instead, define additional modules and import
  those modules here.
  """

  def static_paths, do: ~w(assets fonts images favicon.ico robots.txt)

  def router do
    quote do
      use Phoenix.Router, helpers: false

      # Import common connection and controller functions to use in pipelines
      import Plug.Conn
      import Phoenix.Controller
      import Phoenix.LiveView.Router
    end
  end

  def channel do
    quote do
      use Phoenix.Channel
    end
  end

  def controller do
    quote do
      use Phoenix.Controller, formats: [:html, :json]

      use Gettext, backend: CollabCanvasWeb.Gettext

      import Plug.Conn

      unquote(verified_routes())
    end
  end

  def live_view do
    quote do
      use Phoenix.LiveView

      unquote(html_helpers())
    end
  end

  def live_component do
    quote do
      use Phoenix.LiveComponent

      unquote(html_helpers())
    end
  end

  def html do
    quote do
      use Phoenix.Component

      # Import convenience functions from controllers
      import Phoenix.Controller,
        only: [get_csrf_token: 0, view_module: 1, view_template: 1]

      # Include general helpers for rendering HTML
      unquote(html_helpers())
    end
  end

  defp html_helpers do
    quote do
      # Translation
      use Gettext, backend: CollabCanvasWeb.Gettext

      # HTML escaping functionality
      import Phoenix.HTML
      # Core UI components
      import CollabCanvasWeb.CoreComponents

      # Common modules used in templates
      alias Phoenix.LiveView.JS
      alias CollabCanvasWeb.Layouts

      # Routes generation with the ~p sigil
      unquote(verified_routes())
    end
  end

  def verified_routes do
    quote do
      use Phoenix.VerifiedRoutes,
        endpoint: CollabCanvasWeb.Endpoint,
        router: CollabCanvasWeb.Router,
        statics: CollabCanvasWeb.static_paths()
    end
  end

  @doc """
  When used, dispatch to the appropriate controller/live_view/etc.
  """
  defmacro __using__(which) when is_atom(which) do
    apply(__MODULE__, which, [])
  end
end
</file>

<file path="lib/collab_canvas.ex">
defmodule CollabCanvas do
  @moduledoc """
  CollabCanvas keeps the contexts that define your domain
  and business logic.

  Contexts are also responsible for managing your data, regardless
  if it comes from the database, an external API or others.
  """
end
</file>

<file path="priv/gettext/en/LC_MESSAGES/errors.po">
## `msgid`s in this file come from POT (.pot) files.
##
## Do not add, change, or remove `msgid`s manually here as
## they're tied to the ones in the corresponding POT file
## (with the same domain).
##
## Use `mix gettext.extract --merge` or `mix gettext.merge`
## to merge POT files into PO files.
msgid ""
msgstr ""
"Language: en\n"

## From Ecto.Changeset.cast/4
msgid "can't be blank"
msgstr ""

## From Ecto.Changeset.unique_constraint/3
msgid "has already been taken"
msgstr ""

## From Ecto.Changeset.put_change/3
msgid "is invalid"
msgstr ""

## From Ecto.Changeset.validate_acceptance/3
msgid "must be accepted"
msgstr ""

## From Ecto.Changeset.validate_format/3
msgid "has invalid format"
msgstr ""

## From Ecto.Changeset.validate_subset/3
msgid "has an invalid entry"
msgstr ""

## From Ecto.Changeset.validate_exclusion/3
msgid "is reserved"
msgstr ""

## From Ecto.Changeset.validate_confirmation/3
msgid "does not match confirmation"
msgstr ""

## From Ecto.Changeset.no_assoc_constraint/3
msgid "is still associated with this entry"
msgstr ""

msgid "are still associated with this entry"
msgstr ""

## From Ecto.Changeset.validate_length/3
msgid "should have %{count} item(s)"
msgid_plural "should have %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} character(s)"
msgid_plural "should be %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} byte(s)"
msgid_plural "should be %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at least %{count} item(s)"
msgid_plural "should have at least %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} character(s)"
msgid_plural "should be at least %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} byte(s)"
msgid_plural "should be at least %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at most %{count} item(s)"
msgid_plural "should have at most %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} character(s)"
msgid_plural "should be at most %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} byte(s)"
msgid_plural "should be at most %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

## From Ecto.Changeset.validate_number/3
msgid "must be less than %{number}"
msgstr ""

msgid "must be greater than %{number}"
msgstr ""

msgid "must be less than or equal to %{number}"
msgstr ""

msgid "must be greater than or equal to %{number}"
msgstr ""

msgid "must be equal to %{number}"
msgstr ""
</file>

<file path="priv/gettext/errors.pot">
## This is a PO Template file.
##
## `msgid`s here are often extracted from source code.
## Add new translations manually only if they're dynamic
## translations that can't be statically extracted.
##
## Run `mix gettext.extract` to bring this file up to
## date. Leave `msgstr`s empty as changing them here has no
## effect: edit them in PO (`.po`) files instead.
## From Ecto.Changeset.cast/4
msgid "can't be blank"
msgstr ""

## From Ecto.Changeset.unique_constraint/3
msgid "has already been taken"
msgstr ""

## From Ecto.Changeset.put_change/3
msgid "is invalid"
msgstr ""

## From Ecto.Changeset.validate_acceptance/3
msgid "must be accepted"
msgstr ""

## From Ecto.Changeset.validate_format/3
msgid "has invalid format"
msgstr ""

## From Ecto.Changeset.validate_subset/3
msgid "has an invalid entry"
msgstr ""

## From Ecto.Changeset.validate_exclusion/3
msgid "is reserved"
msgstr ""

## From Ecto.Changeset.validate_confirmation/3
msgid "does not match confirmation"
msgstr ""

## From Ecto.Changeset.no_assoc_constraint/3
msgid "is still associated with this entry"
msgstr ""

msgid "are still associated with this entry"
msgstr ""

## From Ecto.Changeset.validate_length/3
msgid "should have %{count} item(s)"
msgid_plural "should have %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} character(s)"
msgid_plural "should be %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} byte(s)"
msgid_plural "should be %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at least %{count} item(s)"
msgid_plural "should have at least %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} character(s)"
msgid_plural "should be at least %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} byte(s)"
msgid_plural "should be at least %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at most %{count} item(s)"
msgid_plural "should have at most %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} character(s)"
msgid_plural "should be at most %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} byte(s)"
msgid_plural "should be at most %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

## From Ecto.Changeset.validate_number/3
msgid "must be less than %{number}"
msgstr ""

msgid "must be greater than %{number}"
msgstr ""

msgid "must be less than or equal to %{number}"
msgstr ""

msgid "must be greater than or equal to %{number}"
msgstr ""

msgid "must be equal to %{number}"
msgstr ""
</file>

<file path="priv/repo/migrations/.formatter.exs">
[
  import_deps: [:ecto_sql],
  inputs: ["*.exs"]
]
</file>

<file path="priv/repo/migrations/20251013211812_create_users.exs">
defmodule CollabCanvas.Repo.Migrations.CreateUsers do
  use Ecto.Migration

  def change do
    create table(:users) do
      add :email, :string, null: false
      add :name, :string
      add :avatar, :text
      add :provider, :string
      add :provider_uid, :string
      add :last_login, :utc_datetime

      timestamps(type: :utc_datetime)
    end

    create unique_index(:users, [:email])
    create unique_index(:users, [:provider, :provider_uid])
  end
end
</file>

<file path="priv/repo/migrations/20251013211824_create_canvases.exs">
defmodule CollabCanvas.Repo.Migrations.CreateCanvases do
  use Ecto.Migration

  def change do
    create table(:canvases) do
      add :name, :string, null: false
      add :user_id, references(:users, on_delete: :delete_all), null: false

      timestamps(type: :utc_datetime)
    end

    create index(:canvases, [:user_id])
  end
end
</file>

<file path="priv/repo/migrations/20251013211830_create_objects.exs">
defmodule CollabCanvas.Repo.Migrations.CreateObjects do
  use Ecto.Migration

  def change do
    create table(:objects) do
      add :canvas_id, references(:canvases, on_delete: :delete_all), null: false
      add :type, :string, null: false
      add :data, :text
      add :position, :map

      timestamps(type: :utc_datetime)
    end

    create index(:objects, [:canvas_id])
  end
end
</file>

<file path="priv/repo/migrations/20251014120000_add_locked_by_to_objects.exs">
defmodule CollabCanvas.Repo.Migrations.AddLockedByToObjects do
  use Ecto.Migration

  def change do
    alter table(:objects) do
      add(:locked_by, :string)
    end

    create(index(:objects, [:locked_by]))
  end
end
</file>

<file path="priv/repo/migrations/20251016171355_create_components.exs">
defmodule CollabCanvas.Repo.Migrations.CreateComponents do
  use Ecto.Migration

  def change do
    create table(:components) do
      add :name, :string, null: false
      add :description, :text
      add :category, :string
      add :canvas_id, references(:canvases, on_delete: :delete_all), null: false
      add :created_by, references(:users, on_delete: :nilify_all)
      add :is_published, :boolean, default: false, null: false
      add :template_data, :text

      timestamps(type: :utc_datetime)
    end

    create index(:components, [:canvas_id])
    create index(:components, [:created_by])
    create index(:components, [:category])
  end
end
</file>

<file path="priv/repo/migrations/20251016171421_create_styles.exs">
defmodule CollabCanvas.Repo.Migrations.CreateStyles do
  use Ecto.Migration

  def change do
    create table(:styles) do
      add :name, :string, null: false
      add :type, :string, null: false
      add :category, :string
      add :definition, :text, null: false
      add :canvas_id, references(:canvases, on_delete: :delete_all), null: false
      add :created_by, references(:users, on_delete: :nilify_all)

      timestamps(type: :utc_datetime)
    end

    create index(:styles, [:canvas_id])
    create index(:styles, [:created_by])
    create index(:styles, [:type])
    create index(:styles, [:category])
  end
end
</file>

<file path="priv/repo/migrations/20251016171424_add_component_fields_to_objects.exs">
defmodule CollabCanvas.Repo.Migrations.AddComponentFieldsToObjects do
  use Ecto.Migration

  def change do
    alter table(:objects) do
      add :component_id, references(:components, on_delete: :nilify_all)
      add :is_main_component, :boolean, default: false, null: false
      add :instance_overrides, :text
    end

    create index(:objects, [:component_id])
  end
end
</file>

<file path="priv/repo/migrations/20251017023740_create_canvas_user_viewports.exs">
defmodule CollabCanvas.Repo.Migrations.CreateCanvasUserViewports do
  use Ecto.Migration

  def change do
    create table(:canvas_user_viewports) do
      add :user_id, references(:users, on_delete: :delete_all), null: false
      add :canvas_id, references(:canvases, on_delete: :delete_all), null: false
      add :viewport_x, :float, null: false, default: 0.0
      add :viewport_y, :float, null: false, default: 0.0
      add :zoom, :float, null: false, default: 1.0

      timestamps(type: :utc_datetime)
    end

    create unique_index(:canvas_user_viewports, [:user_id, :canvas_id])
    create index(:canvas_user_viewports, [:canvas_id])
  end
end
</file>

<file path="priv/repo/migrations/20251017041802_create_user_color_preferences.exs">
defmodule CollabCanvas.Repo.Migrations.CreateUserColorPreferences do
  use Ecto.Migration

  def change do
    create table(:user_color_preferences) do
      add :user_id, references(:users, on_delete: :delete_all), null: false
      add :recent_colors, :text, default: "[]", null: false  # JSON array of up to 10 recent hex colors
      add :favorite_colors, :text, default: "[]", null: false  # JSON array of pinned favorite hex colors
      add :default_color, :string, default: "#000000", null: false  # Default color for new objects

      timestamps(type: :utc_datetime)
    end

    create unique_index(:user_color_preferences, [:user_id])
  end
end
</file>

<file path="priv/repo/seeds.exs">
# Script for populating the database. You can run it as:
#
#     mix run priv/repo/seeds.exs
#
# Inside the script, you can read and write to any of your
# repositories directly:
#
#     CollabCanvas.Repo.insert!(%CollabCanvas.SomeSchema{})
#
# We recommend using the bang functions (`insert!`, `update!`
# and so on) as they will fail if something goes wrong.
</file>

<file path="priv/static/images/logo.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 48" fill="currentColor" aria-hidden="true">
  <path
    d="m26.371 33.477-.552-.1c-3.92-.729-6.397-3.1-7.57-6.829-.733-2.324.597-4.035 3.035-4.148 1.995-.092 3.362 1.055 4.57 2.39 1.557 1.72 2.984 3.558 4.514 5.305 2.202 2.515 4.797 4.134 8.347 3.634 3.183-.448 5.958-1.725 8.371-3.828.363-.316.761-.592 1.144-.886l-.241-.284c-2.027.63-4.093.841-6.205.735-3.195-.16-6.24-.828-8.964-2.582-2.486-1.601-4.319-3.746-5.19-6.611-.704-2.315.736-3.934 3.135-3.6.948.133 1.746.56 2.463 1.165.583.493 1.143 1.015 1.738 1.493 2.8 2.25 6.712 2.375 10.265-.068-5.842-.026-9.817-3.24-13.308-7.313-1.366-1.594-2.7-3.216-4.095-4.785-2.698-3.036-5.692-5.71-9.79-6.623C12.8-.623 7.745.14 2.893 2.361 1.926 2.804.997 3.319 0 4.149c.494 0 .763.006 1.032 0 2.446-.064 4.28 1.023 5.602 3.024.962 1.457 1.415 3.104 1.761 4.798.513 2.515.247 5.078.544 7.605.761 6.494 4.08 11.026 10.26 13.346 2.267.852 4.591 1.135 7.172.555ZM10.751 3.852c-.976.246-1.756-.148-2.56-.962 1.377-.343 2.592-.476 3.897-.528-.107.848-.607 1.306-1.336 1.49Zm32.002 37.924c-.085-.626-.62-.901-1.04-1.228-1.857-1.446-4.03-1.958-6.333-2-1.375-.026-2.735-.128-4.031-.61-.595-.22-1.26-.505-1.244-1.272.015-.78.693-1 1.31-1.184.505-.15 1.026-.247 1.6-.382-1.46-.936-2.886-1.065-4.787-.3-2.993 1.202-5.943 1.06-8.926-.017-1.684-.608-3.179-1.563-4.735-2.408l-.077.057c1.29 2.115 3.034 3.817 5.004 5.271 3.793 2.8 7.936 4.471 12.784 3.73A66.714 66.714 0 0 1 37 40.877c1.98-.16 3.866.398 5.753.899Zm-9.14-30.345c-.105-.076-.206-.266-.42-.069 1.745 2.36 3.985 4.098 6.683 5.193 4.354 1.767 8.773 2.07 13.293.51 3.51-1.21 6.033-.028 7.343 3.38.19-3.955-2.137-6.837-5.843-7.401-2.084-.318-4.01.373-5.962.94-5.434 1.575-10.485.798-15.094-2.553Zm27.085 15.425c.708.059 1.416.123 2.124.185-1.6-1.405-3.55-1.517-5.523-1.404-3.003.17-5.167 1.903-7.14 3.972-1.739 1.824-3.31 3.87-5.903 4.604.043.078.054.117.066.117.35.005.699.021 1.047.005 3.768-.17 7.317-.965 10.14-3.7.89-.86 1.685-1.817 2.544-2.71.716-.746 1.584-1.159 2.645-1.07Zm-8.753-4.67c-2.812.246-5.254 1.409-7.548 2.943-1.766 1.18-3.654 1.738-5.776 1.37-.374-.066-.75-.114-1.124-.17l-.013.156c.135.07.265.151.405.207.354.14.702.308 1.07.395 4.083.971 7.992.474 11.516-1.803 2.221-1.435 4.521-1.707 7.013-1.336.252.038.503.083.756.107.234.022.479.255.795.003-2.179-1.574-4.526-2.096-7.094-1.872Zm-10.049-9.544c1.475.051 2.943-.142 4.486-1.059-.452.04-.643.04-.827.076-2.126.424-4.033-.04-5.733-1.383-.623-.493-1.257-.974-1.889-1.457-2.503-1.914-5.374-2.555-8.514-2.5.05.154.054.26.108.315 3.417 3.455 7.371 5.836 12.369 6.008Zm24.727 17.731c-2.114-2.097-4.952-2.367-7.578-.537 1.738.078 3.043.632 4.101 1.728a13 13 0 0 0 1.182 1.106c1.6 1.29 4.311 1.352 5.896.155-1.861-.726-1.861-.726-3.601-2.452Zm-21.058 16.06c-1.858-3.46-4.981-4.24-8.59-4.008a9.667 9.667 0 0 1 2.977 1.39c.84.586 1.547 1.311 2.243 2.055 1.38 1.473 3.534 2.376 4.962 2.07-.656-.412-1.238-.848-1.592-1.507Zl-.006.006-.036-.004.021.018.012.053Za.127.127 0 0 0 .015.043c.005.008.038 0 .058-.002Zl-.008.01.005.026.024.014Z"
    fill="#FD4F00"
  />
</svg>
</file>

<file path="priv/static/robots.txt">
# See https://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file
#
# To ban all spiders from the entire site uncomment the next two lines:
# User-agent: *
# Disallow: /
</file>

<file path="rel/env.sh.eex">
#!/bin/sh

# Configure distributed Elixir for Fly.io
ip=$(grep fly-local-6pn /etc/hosts | cut -f 1)
if [ -n "$ip" ]; then
  export ELIXIR_ERL_OPTIONS="-proto_dist inet6_tcp"
  export ERL_AFLAGS="-proto_dist inet6_tcp"
fi

# Set the release to work across nodes
export RELEASE_DISTRIBUTION=name
export RELEASE_NODE=<%= @release.name %>@${FLY_APP_NAME}.internal
</file>

<file path=".dockerignore">
# This file excludes paths from the Docker build context.
#
# By default, Docker's build context includes all files (and folders) in the
# current directory. Even if a file isn't copied into the container it is still sent to
# the Docker daemon.
#
# There are multiple reasons to exclude files from the build context:
#
# 1. Prevent nested folders from being copied into the container (ex: exclude
#    /assets/node_modules when copying /assets)
# 2. Reduce the size of the build context and improve build time (ex. /build, /deps, /doc)
# 3. Avoid sending files containing sensitive information
#
# More information on using .dockerignore is available here:
# https://docs.docker.com/engine/reference/builder/#dockerignore-file

.dockerignore

# Ignore git, but keep git HEAD and refs to access current commit hash if needed:
#
# $ cat .git/HEAD | awk '{print ".git/"$2}' | xargs cat
# d0b8727759e1e0e7aa3d41707d12376e373d5ecc
.git
!.git/HEAD
!.git/refs

# Common development/test artifacts
/cover/
/doc/
/test/
/tmp/
.elixir_ls

# Mix artifacts
/_build/
/deps/
*.ez

# Generated on crash by the VM
erl_crash.dump

# Static artifacts - These should be fetched and built inside the Docker image
/assets/node_modules/
/priv/static/assets/
/priv/static/cache_manifest.json

# Database files
*.db
*.db-shm
*.db-wal

# Environment variables and secrets
.env
.env.*
!.env.example

# Operating System files
.DS_Store
Thumbs.db

# Editor/IDE files
.vscode/
.idea/
*.swp
*.swo
*~
</file>

<file path=".env.example">
# Auth0 Configuration
AUTH0_DOMAIN=your_auth0_domain.auth0.com
AUTH0_CLIENT_ID=your_client_id_here
AUTH0_CLIENT_SECRET=your_client_secret_here
AUTH0_CALLBACK_URL=http://localhost:4000/auth/callback

# Claude API Configuration
# Get your API key from: https://console.anthropic.com/
CLAUDE_API_KEY=your_claude_api_key_here
</file>

<file path=".formatter.exs">
[
  import_deps: [:ecto, :ecto_sql, :phoenix],
  subdirectories: ["priv/*/migrations"],
  plugins: [Phoenix.LiveView.HTMLFormatter],
  inputs: ["*.{heex,ex,exs}", "{config,lib,test}/**/*.{heex,ex,exs}", "priv/*/seeds.exs"]
]
</file>

<file path=".gitignore">
# The directory Mix will write compiled artifacts to.
/_build/

# If you run "mix test --cover", coverage assets end up here.
/cover/

# The directory Mix downloads your dependencies sources to.
/deps/

# Where 3rd-party dependencies like ExDoc output generated docs.
/doc/

# Ignore .fetch files in case you like to edit your project deps locally.
/.fetch

# If the VM crashes, it generates a dump, let's ignore it too.
erl_crash.dump

# Also ignore archive artifacts (built via "mix archive.build").
*.ez

# Temporary files, for example, from tests.
/tmp/

# Ignore package tarball (built via "mix hex.build").
collab_canvas-*.tar

# Ignore assets that are produced by build tools.
/priv/static/assets/

# Ignore digested assets cache.
/priv/static/cache_manifest.json

# In case you use Node.js/npm, you want to ignore these.
npm-debug.log
/assets/node_modules/

# Database files
*.db
*.db-*

.worktree/

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
dev-debug.log
# Dependency directories
node_modules/
# Environment variables
.env
# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
# OS specific
.DS_Store

# Task files
# tasks.json
# tasks/
</file>

<file path="AGENTS.md">
This is a web application written using the Phoenix web framework.

## Project guidelines

- Use `mix precommit` alias when you are done with all changes and fix any pending issues
- Use the already included and available `:req` (`Req`) library for HTTP requests, **avoid** `:httpoison`, `:tesla`, and `:httpc`. Req is included by default and is the preferred HTTP client for Phoenix apps

### Phoenix v1.8 guidelines

- **Always** begin your LiveView templates with `<Layouts.app flash={@flash} ...>` which wraps all inner content
- The `MyAppWeb.Layouts` module is aliased in the `my_app_web.ex` file, so you can use it without needing to alias it again
- Anytime you run into errors with no `current_scope` assign:
  - You failed to follow the Authenticated Routes guidelines, or you failed to pass `current_scope` to `<Layouts.app>`
  - **Always** fix the `current_scope` error by moving your routes to the proper `live_session` and ensure you pass `current_scope` as needed
- Phoenix v1.8 moved the `<.flash_group>` component to the `Layouts` module. You are **forbidden** from calling `<.flash_group>` outside of the `layouts.ex` module
- Out of the box, `core_components.ex` imports an `<.icon name="hero-x-mark" class="w-5 h-5"/>` component for for hero icons. **Always** use the `<.icon>` component for icons, **never** use `Heroicons` modules or similar
- **Always** use the imported `<.input>` component for form inputs from `core_components.ex` when available. `<.input>` is imported and using it will will save steps and prevent errors
- If you override the default input classes (`<.input class="myclass px-2 py-1 rounded-lg">)`) class with your own values, no default classes are inherited, so your
custom classes must fully style the input

### JS and CSS guidelines

- **Use Tailwind CSS classes and custom CSS rules** to create polished, responsive, and visually stunning interfaces.
- Tailwindcss v4 **no longer needs a tailwind.config.js** and uses a new import syntax in `app.css`:

      @import "tailwindcss" source(none);
      @source "../css";
      @source "../js";
      @source "../../lib/my_app_web";

- **Always use and maintain this import syntax** in the app.css file for projects generated with `phx.new`
- **Never** use `@apply` when writing raw css
- **Always** manually write your own tailwind-based components instead of using daisyUI for a unique, world-class design
- Out of the box **only the app.js and app.css bundles are supported**
  - You cannot reference an external vendor'd script `src` or link `href` in the layouts
  - You must import the vendor deps into app.js and app.css to use them
  - **Never write inline <script>custom js</script> tags within templates**

### UI/UX & design guidelines

- **Produce world-class UI designs** with a focus on usability, aesthetics, and modern design principles
- Implement **subtle micro-interactions** (e.g., button hover effects, and smooth transitions)
- Ensure **clean typography, spacing, and layout balance** for a refined, premium look
- Focus on **delightful details** like hover effects, loading states, and smooth page transitions


<!-- usage-rules-start -->

<!-- phoenix:elixir-start -->
## Elixir guidelines

- Elixir lists **do not support index based access via the access syntax**

  **Never do this (invalid)**:

      i = 0
      mylist = ["blue", "green"]
      mylist[i]

  Instead, **always** use `Enum.at`, pattern matching, or `List` for index based list access, ie:

      i = 0
      mylist = ["blue", "green"]
      Enum.at(mylist, i)

- Elixir variables are immutable, but can be rebound, so for block expressions like `if`, `case`, `cond`, etc
  you *must* bind the result of the expression to a variable if you want to use it and you CANNOT rebind the result inside the expression, ie:

      # INVALID: we are rebinding inside the `if` and the result never gets assigned
      if connected?(socket) do
        socket = assign(socket, :val, val)
      end

      # VALID: we rebind the result of the `if` to a new variable
      socket =
        if connected?(socket) do
          assign(socket, :val, val)
        end

- **Never** nest multiple modules in the same file as it can cause cyclic dependencies and compilation errors
- **Never** use map access syntax (`changeset[:field]`) on structs as they do not implement the Access behaviour by default. For regular structs, you **must** access the fields directly, such as `my_struct.field` or use higher level APIs that are available on the struct if they exist, `Ecto.Changeset.get_field/2` for changesets
- Elixir's standard library has everything necessary for date and time manipulation. Familiarize yourself with the common `Time`, `Date`, `DateTime`, and `Calendar` interfaces by accessing their documentation as necessary. **Never** install additional dependencies unless asked or for date/time parsing (which you can use the `date_time_parser` package)
- Don't use `String.to_atom/1` on user input (memory leak risk)
- Predicate function names should not start with `is_` and should end in a question mark. Names like `is_thing` should be reserved for guards
- Elixir's builtin OTP primitives like `DynamicSupervisor` and `Registry`, require names in the child spec, such as `{DynamicSupervisor, name: MyApp.MyDynamicSup}`, then you can use `DynamicSupervisor.start_child(MyApp.MyDynamicSup, child_spec)`
- Use `Task.async_stream(collection, callback, options)` for concurrent enumeration with back-pressure. The majority of times you will want to pass `timeout: :infinity` as option

## Mix guidelines

- Read the docs and options before using tasks (by using `mix help task_name`)
- To debug test failures, run tests in a specific file with `mix test test/my_test.exs` or run all previously failed tests with `mix test --failed`
- `mix deps.clean --all` is **almost never needed**. **Avoid** using it unless you have good reason
<!-- phoenix:elixir-end -->

<!-- phoenix:phoenix-start -->
## Phoenix guidelines

- Remember Phoenix router `scope` blocks include an optional alias which is prefixed for all routes within the scope. **Always** be mindful of this when creating routes within a scope to avoid duplicate module prefixes.

- You **never** need to create your own `alias` for route definitions! The `scope` provides the alias, ie:

      scope "/admin", AppWeb.Admin do
        pipe_through :browser

        live "/users", UserLive, :index
      end

  the UserLive route would point to the `AppWeb.Admin.UserLive` module

- `Phoenix.View` no longer is needed or included with Phoenix, don't use it
<!-- phoenix:phoenix-end -->

<!-- phoenix:ecto-start -->
## Ecto Guidelines

- **Always** preload Ecto associations in queries when they'll be accessed in templates, ie a message that needs to reference the `message.user.email`
- Remember `import Ecto.Query` and other supporting modules when you write `seeds.exs`
- `Ecto.Schema` fields always use the `:string` type, even for `:text`, columns, ie: `field :name, :string`
- `Ecto.Changeset.validate_number/2` **DOES NOT SUPPORT the `:allow_nil` option**. By default, Ecto validations only run if a change for the given field exists and the change value is not nil, so such as option is never needed
- You **must** use `Ecto.Changeset.get_field(changeset, :field)` to access changeset fields
- Fields which are set programatically, such as `user_id`, must not be listed in `cast` calls or similar for security purposes. Instead they must be explicitly set when creating the struct
<!-- phoenix:ecto-end -->

<!-- phoenix:html-start -->
## Phoenix HTML guidelines

- Phoenix templates **always** use `~H` or .html.heex files (known as HEEx), **never** use `~E`
- **Always** use the imported `Phoenix.Component.form/1` and `Phoenix.Component.inputs_for/1` function to build forms. **Never** use `Phoenix.HTML.form_for` or `Phoenix.HTML.inputs_for` as they are outdated
- When building forms **always** use the already imported `Phoenix.Component.to_form/2` (`assign(socket, form: to_form(...))` and `<.form for={@form} id="msg-form">`), then access those forms in the template via `@form[:field]`
- **Always** add unique DOM IDs to key elements (like forms, buttons, etc) when writing templates, these IDs can later be used in tests (`<.form for={@form} id="product-form">`)
- For "app wide" template imports, you can import/alias into the `my_app_web.ex`'s `html_helpers` block, so they will be available to all LiveViews, LiveComponent's, and all modules that do `use MyAppWeb, :html` (replace "my_app" by the actual app name)

- Elixir supports `if/else` but **does NOT support `if/else if` or `if/elsif`. **Never use `else if` or `elseif` in Elixir**, **always** use `cond` or `case` for multiple conditionals.

  **Never do this (invalid)**:

      <%= if condition do %>
        ...
      <% else if other_condition %>
        ...
      <% end %>

  Instead **always** do this:

      <%= cond do %>
        <% condition -> %>
          ...
        <% condition2 -> %>
          ...
        <% true -> %>
          ...
      <% end %>

- HEEx require special tag annotation if you want to insert literal curly's like `{` or `}`. If you want to show a textual code snippet on the page in a `<pre>` or `<code>` block you *must* annotate the parent tag with `phx-no-curly-interpolation`:

      <code phx-no-curly-interpolation>
        let obj = {key: "val"}
      </code>

  Within `phx-no-curly-interpolation` annotated tags, you can use `{` and `}` without escaping them, and dynamic Elixir expressions can still be used with `<%= ... %>` syntax

- HEEx class attrs support lists, but you must **always** use list `[...]` syntax. You can use the class list syntax to conditionally add classes, **always do this for multiple class values**:

      <a class={[
        "px-2 text-white",
        @some_flag && "py-5",
        if(@other_condition, do: "border-red-500", else: "border-blue-100"),
        ...
      ]}>Text</a>

  and **always** wrap `if`'s inside `{...}` expressions with parens, like done above (`if(@other_condition, do: "...", else: "...")`)

  and **never** do this, since it's invalid (note the missing `[` and `]`):

      <a class={
        "px-2 text-white",
        @some_flag && "py-5"
      }> ...
      => Raises compile syntax error on invalid HEEx attr syntax

- **Never** use `<% Enum.each %>` or non-for comprehensions for generating template content, instead **always** use `<%= for item <- @collection do %>`
- HEEx HTML comments use `<%!-- comment --%>`. **Always** use the HEEx HTML comment syntax for template comments (`<%!-- comment --%>`)
- HEEx allows interpolation via `{...}` and `<%= ... %>`, but the `<%= %>` **only** works within tag bodies. **Always** use the `{...}` syntax for interpolation within tag attributes, and for interpolation of values within tag bodies. **Always** interpolate block constructs (if, cond, case, for) within tag bodies using `<%= ... %>`.

  **Always** do this:

      <div id={@id}>
        {@my_assign}
        <%= if @some_block_condition do %>
          {@another_assign}
        <% end %>
      </div>

  and **Never** do this – the program will terminate with a syntax error:

      <%!-- THIS IS INVALID NEVER EVER DO THIS --%>
      <div id="<%= @invalid_interpolation %>">
        {if @invalid_block_construct do}
        {end}
      </div>
<!-- phoenix:html-end -->

<!-- phoenix:liveview-start -->
## Phoenix LiveView guidelines

- **Never** use the deprecated `live_redirect` and `live_patch` functions, instead **always** use the `<.link navigate={href}>` and  `<.link patch={href}>` in templates, and `push_navigate` and `push_patch` functions LiveViews
- **Avoid LiveComponent's** unless you have a strong, specific need for them
- LiveViews should be named like `AppWeb.WeatherLive`, with a `Live` suffix. When you go to add LiveView routes to the router, the default `:browser` scope is **already aliased** with the `AppWeb` module, so you can just do `live "/weather", WeatherLive`
- Remember anytime you use `phx-hook="MyHook"` and that js hook manages its own DOM, you **must** also set the `phx-update="ignore"` attribute
- **Never** write embedded `<script>` tags in HEEx. Instead always write your scripts and hooks in the `assets/js` directory and integrate them with the `assets/js/app.js` file

### LiveView streams

- **Always** use LiveView streams for collections for assigning regular lists to avoid memory ballooning and runtime termination with the following operations:
  - basic append of N items - `stream(socket, :messages, [new_msg])`
  - resetting stream with new items - `stream(socket, :messages, [new_msg], reset: true)` (e.g. for filtering items)
  - prepend to stream - `stream(socket, :messages, [new_msg], at: -1)`
  - deleting items - `stream_delete(socket, :messages, msg)`

- When using the `stream/3` interfaces in the LiveView, the LiveView template must 1) always set `phx-update="stream"` on the parent element, with a DOM id on the parent element like `id="messages"` and 2) consume the `@streams.stream_name` collection and use the id as the DOM id for each child. For a call like `stream(socket, :messages, [new_msg])` in the LiveView, the template would be:

      <div id="messages" phx-update="stream">
        <div :for={{id, msg} <- @streams.messages} id={id}>
          {msg.text}
        </div>
      </div>

- LiveView streams are *not* enumerable, so you cannot use `Enum.filter/2` or `Enum.reject/2` on them. Instead, if you want to filter, prune, or refresh a list of items on the UI, you **must refetch the data and re-stream the entire stream collection, passing reset: true**:

      def handle_event("filter", %{"filter" => filter}, socket) do
        # re-fetch the messages based on the filter
        messages = list_messages(filter)

        {:noreply,
        socket
        |> assign(:messages_empty?, messages == [])
        # reset the stream with the new messages
        |> stream(:messages, messages, reset: true)}
      end

- LiveView streams *do not support counting or empty states*. If you need to display a count, you must track it using a separate assign. For empty states, you can use Tailwind classes:

      <div id="tasks" phx-update="stream">
        <div class="hidden only:block">No tasks yet</div>
        <div :for={{id, task} <- @stream.tasks} id={id}>
          {task.name}
        </div>
      </div>

  The above only works if the empty state is the only HTML block alongside the stream for-comprehension.

- **Never** use the deprecated `phx-update="append"` or `phx-update="prepend"` for collections

### LiveView tests

- `Phoenix.LiveViewTest` module and `LazyHTML` (included) for making your assertions
- Form tests are driven by `Phoenix.LiveViewTest`'s `render_submit/2` and `render_change/2` functions
- Come up with a step-by-step test plan that splits major test cases into small, isolated files. You may start with simpler tests that verify content exists, gradually add interaction tests
- **Always reference the key element IDs you added in the LiveView templates in your tests** for `Phoenix.LiveViewTest` functions like `element/2`, `has_element/2`, selectors, etc
- **Never** tests again raw HTML, **always** use `element/2`, `has_element/2`, and similar: `assert has_element?(view, "#my-form")`
- Instead of relying on testing text content, which can change, favor testing for the presence of key elements
- Focus on testing outcomes rather than implementation details
- Be aware that `Phoenix.Component` functions like `<.form>` might produce different HTML than expected. Test against the output HTML structure, not your mental model of what you expect it to be
- When facing test failures with element selectors, add debug statements to print the actual HTML, but use `LazyHTML` selectors to limit the output, ie:

      html = render(view)
      document = LazyHTML.from_fragment(html)
      matches = LazyHTML.filter(document, "your-complex-selector")
      IO.inspect(matches, label: "Matches")

### Form handling

#### Creating a form from params

If you want to create a form based on `handle_event` params:

    def handle_event("submitted", params, socket) do
      {:noreply, assign(socket, form: to_form(params))}
    end

When you pass a map to `to_form/1`, it assumes said map contains the form params, which are expected to have string keys.

You can also specify a name to nest the params:

    def handle_event("submitted", %{"user" => user_params}, socket) do
      {:noreply, assign(socket, form: to_form(user_params, as: :user))}
    end

#### Creating a form from changesets

When using changesets, the underlying data, form params, and errors are retrieved from it. The `:as` option is automatically computed too. E.g. if you have a user schema:

    defmodule MyApp.Users.User do
      use Ecto.Schema
      ...
    end

And then you create a changeset that you pass to `to_form`:

    %MyApp.Users.User{}
    |> Ecto.Changeset.change()
    |> to_form()

Once the form is submitted, the params will be available under `%{"user" => user_params}`.

In the template, the form form assign can be passed to the `<.form>` function component:

    <.form for={@form} id="todo-form" phx-change="validate" phx-submit="save">
      <.input field={@form[:field]} type="text" />
    </.form>

Always give the form an explicit, unique DOM ID, like `id="todo-form"`.

#### Avoiding form errors

**Always** use a form assigned via `to_form/2` in the LiveView, and the `<.input>` component in the template. In the template **always access forms this**:

    <%!-- ALWAYS do this (valid) --%>
    <.form for={@form} id="my-form">
      <.input field={@form[:field]} type="text" />
    </.form>

And **never** do this:

    <%!-- NEVER do this (invalid) --%>
    <.form for={@changeset} id="my-form">
      <.input field={@changeset[:field]} type="text" />
    </.form>

- You are FORBIDDEN from accessing the changeset in the template as it will cause errors
- **Never** use `<.form let={f} ...>` in the template, instead **always use `<.form for={@form} ...>`**, then drive all form references from the form assign as in `@form[:field]`. The UI should **always** be driven by a `to_form/2` assigned in the LiveView module that is derived from a changeset
<!-- phoenix:liveview-end -->

<!-- usage-rules-end -->
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

CollabCanvas is a real-time collaborative canvas application built with Phoenix LiveView and PixiJS. Think Figma-lite: multiple users can simultaneously create, edit, and manipulate shapes, text, and UI components on a shared canvas with real-time synchronization.

**Tech Stack:**
- **Backend:** Elixir 1.15+, Phoenix 1.8, Phoenix LiveView 1.1
- **Database:** SQLite (via Ecto 3.13)
- **Frontend:** JavaScript (ES6+), PixiJS v8 (WebGL canvas rendering)
- **Build:** Vite (ESM bundler), Tailwind CSS 4.1.7
- **Auth:** Auth0 via Ueberauth
- **Real-time:** Phoenix PubSub (multi-user sync), Phoenix Presence (cursor tracking)
- **AI:** Claude 3.5 Sonnet API (natural language canvas commands)

## Development Commands

```bash
# Initial setup (install deps, create DB, compile assets)
mix setup

# Start development server (http://localhost:4000)
mix phx.server

# Interactive Elixir shell with app loaded
iex -S mix phx.server

# Database operations
mix ecto.create           # Create database
mix ecto.migrate          # Run migrations
mix ecto.reset            # Drop, create, migrate, seed
mix ecto.rollback         # Rollback last migration

# Testing
mix test                  # Run all tests
mix test test/path/to/file_test.exs          # Single file
mix test test/path/to/file_test.exs:42       # Single test at line 42

# Code quality (pre-commit workflow)
mix precommit             # Compile with warnings-as-errors, format, test

# Asset management
npm install --prefix assets              # Install JS dependencies
npm run dev --prefix assets              # Vite dev server (auto in mix phx.server)
npm run build --prefix assets            # Production build
mix tailwind collab_canvas               # Compile Tailwind CSS
```

## Architecture Overview

### Real-Time Collaboration Flow

CollabCanvas uses a **LiveView + PubSub + Presence** architecture for multi-user collaboration:

1. **Client Action** → User draws/edits on PixiJS canvas (JavaScript)
2. **LiveView Event** → JS hook sends event to `CanvasLive` via `phx-` bindings
3. **Server Processing** → LiveView validates, persists to SQLite via `Canvases` context
4. **PubSub Broadcast** → Change broadcast to topic `"canvas:{canvas_id}"` via `Phoenix.PubSub`
5. **All Clients Update** → All connected LiveViews receive broadcast via `handle_info/2`
6. **Client Rendering** → Server pushes event to JS hooks, which update PixiJS canvas

**Key files:**
- `lib/collab_canvas_web/live/canvas_live.ex` - LiveView orchestration (1762 lines)
- `lib/collab_canvas/canvases.ex` - Database context for canvas/object CRUD
- `assets/js/hooks/canvas_manager.js` - PixiJS rendering and user interaction

### AI-Powered Canvas Manipulation

Natural language commands (e.g., "create 3 blue circles in a row") are processed via:

1. **AI Agent** (`lib/collab_canvas/ai/agent.ex`) - Calls Claude API with function calling tools
2. **Tool Definitions** (`lib/collab_canvas/ai/tools.ex`) - Defines 15+ tools (create_shape, arrange_objects, etc.)
3. **Layout Engine** (`lib/collab_canvas/ai/layout.ex`) - Algorithms for grid, circular, constraint-based layouts
4. **Component Builder** (`lib/collab_canvas/ai/component_builder.ex`) - Builds complex UI (login forms, navbars, cards)

**AI Execution Flow:**
- User types command → `execute_ai_command` event → `Task.async` spawns AI call (non-blocking)
- Claude API returns tool calls → Agent executes tools → Objects created/updated → PubSub broadcast
- 30-second timeout protection, graceful error handling

**Supported AI providers:**
- Claude (default) via `CLAUDE_API_KEY`
- OpenAI via `OPENAI_API_KEY` + `AI_PROVIDER=openai`
- Groq via `GROQ_API_KEY` + `AI_PROVIDER=groq`

### Database Schema

**Core entities:**
- `canvases` - User-owned workspaces
- `objects` - Shapes/text on canvases (polymorphic: rectangles, circles, text, components)
  - `position: map` - `%{x: float, y: float}`
  - `data: text` - JSON blob with type-specific properties (width, height, color, text content, etc.)
  - `locked_by: string` - User ID for edit locking (prevents conflicts)
- `canvas_user_viewports` - Saves per-user viewport position/zoom for each canvas
- `components` - Reusable UI component templates
- `styles` - Shared styling definitions

**Important:** Objects use JSON `data` field for flexibility. Always decode with `Jason.decode!` before reading, encode with `Jason.encode!` before writing.

### Object Locking System

Prevents simultaneous edits to the same object:

1. User selects object → `lock_object` event → `Canvases.lock_object(object_id, user_id)`
2. Server checks `locked_by` field → Returns `:already_locked` if locked by another user
3. On success → Broadcast `{:object_locked, object}` to all clients → Visual feedback (grayed out)
4. User deselects → `unlock_object` event → `locked_by` set to `nil` → Broadcast unlock
5. On disconnect → `terminate/2` callback unlocks all objects for that user

**Key functions:**
- `Canvases.lock_object/2` - Acquire lock
- `Canvases.unlock_object/2` - Release lock
- `Canvases.check_lock/1` - Query lock status

### Frontend Architecture (PixiJS)

**File structure:**
- `assets/js/app.js` - Entry point, initializes LiveView socket and hooks
- `assets/js/hooks/canvas_manager.js` - Main PixiJS hook, handles all canvas rendering
- `assets/js/core/canvas_manager.js` - Core PixiJS logic (object creation, selection, dragging)
- `assets/js/core/performance_monitor.js` - FPS tracking and performance metrics

**PixiJS integration:**
- LiveView hook lifecycle: `mounted()` initializes PixiJS app, `destroyed()` cleans up
- Server events (`push_event`) trigger PixiJS updates (create, update, delete objects)
- Client events (`pushEvent`) send user actions to server (object created, dragged, etc.)

**Pan & zoom:**
- Space + drag = pan canvas
- Ctrl/Cmd + scroll = zoom in/out
- Two-finger scroll (trackpad) = pan
- Viewport position auto-saved to DB on change

## Context Modules (Business Logic Layer)

Phoenix contexts provide clean separation between web and domain logic:

- **`CollabCanvas.Canvases`** - Canvas and object management (CRUD operations)
  - `create_canvas/2`, `get_canvas_with_preloads/2`, `list_user_canvases/1`
  - `create_object/3`, `update_object/2`, `delete_object/1`
  - `lock_object/2`, `unlock_object/2`, `check_lock/1`
  - `save_viewport/3`, `get_viewport/2`

- **`CollabCanvas.Accounts`** - User management
  - `get_user/1`, `create_user/1`, `find_or_create_user_from_auth/1`

- **`CollabCanvas.Components`** - Component templates
  - `create_component/1`, `instantiate_component/2` (creates objects from template)

- **`CollabCanvas.Styles`** - Shared styles
  - `create_style/1`, `apply_style_to_object/2`

**Convention:** Always use context functions, never query Ecto directly from LiveViews or controllers.

## LiveView Patterns

### Event Handling

```elixir
# Handle event from client
def handle_event("create_object", %{"type" => type} = params, socket) do
  # 1. Validate and transform params
  # 2. Call context function (Canvases.create_object)
  # 3. Broadcast to PubSub topic
  # 4. Update local state
  # 5. Push event to JS hook (push_event)
  {:noreply, socket}
end

# Handle PubSub broadcast from other clients
def handle_info({:object_created, object}, socket) do
  # 1. Check for duplicates (originating client already has it)
  # 2. Update local state
  # 3. Push event to JS hook
  {:noreply, socket}
end
```

### Async Operations (AI Commands)

```elixir
# Spawn non-blocking task
task = Task.async(fn -> Agent.execute_command(command, canvas_id) end)
Process.send_after(self(), {:ai_timeout, task.ref}, 30_000)
{:noreply, assign(socket, ai_loading: true, ai_task_ref: task.ref)}

# Handle task completion
def handle_info({ref, result}, socket) when is_reference(ref) do
  if ref == socket.assigns.ai_task_ref do
    Process.demonitor(ref, [:flush])
    # Process result...
  end
end
```

## Important Patterns & Conventions

### JSON Data Handling

Objects store type-specific data in a JSON blob:

```elixir
# Creating object with data
data = %{width: 100, height: 50, color: "#FF0000"}
attrs = %{
  position: %{x: 10, y: 20},
  data: Jason.encode!(data)  # ALWAYS encode before saving
}
Canvases.create_object(canvas_id, "rectangle", attrs)

# Reading object data
object = Canvases.get_object(object_id)
decoded_data = Jason.decode!(object.data)  # ALWAYS decode after reading
width = decoded_data["width"]
```

### PubSub Topics

Each canvas has a dedicated topic:

```elixir
topic = "canvas:#{canvas_id}"

# Subscribe on mount
Phoenix.PubSub.subscribe(CollabCanvas.PubSub, topic)

# Broadcast changes
Phoenix.PubSub.broadcast(CollabCanvas.PubSub, topic, {:object_created, object})
Phoenix.PubSub.broadcast(CollabCanvas.PubSub, topic, {:object_updated, object})
Phoenix.PubSub.broadcast(CollabCanvas.PubSub, topic, {:object_deleted, object_id})
```

### Presence Tracking (User Cursors)

```elixir
# Track user on mount
Presence.track(self(), topic, user_id, %{
  online_at: System.system_time(:second),
  cursor: nil,
  color: "#3b82f6",
  name: user.name,
  email: user.email
})

# Update cursor position
Presence.update(self(), topic, user_id, fn meta ->
  Map.put(meta, :cursor, %{x: x, y: y})
end)

# Handle presence changes
def handle_info(%Phoenix.Socket.Broadcast{event: "presence_diff"}, socket) do
  presences = Presence.list(topic)
  {:noreply, socket |> assign(:presences, presences) |> push_event("presence_updated", %{presences: presences})}
end
```

## Testing Conventions

- Tests live in `test/collab_canvas` and `test/collab_canvas_web`
- Context tests: Test CRUD operations, validation, edge cases
- LiveView tests: Use `Phoenix.LiveViewTest` helpers (`live/2`, `render_click/2`, etc.)
- Always test happy path + error cases (not found, validation failures)

## Configuration Files

- **`config/config.exs`** - Base config (shared across all environments)
- **`config/dev.exs`** - Development-specific (DB path, live reload, debug settings)
- **`config/runtime.exs`** - Runtime config (reads env vars: `CLAUDE_API_KEY`, `AUTH0_*`, etc.)
- **`.env`** - Local secrets (NOT committed, used by `dotenvy` in dev)

**Required environment variables for AI features:**
- `CLAUDE_API_KEY` - Anthropic API key for AI commands (default provider)
- `OPENAI_API_KEY` - OpenAI GPT-4 (optional, set `AI_PROVIDER=openai`)
- `GROQ_API_KEY` - Groq Llama 3.3 (optional, set `AI_PROVIDER=groq`)

## Performance Considerations

- **Layout operations** must complete in <500ms for up to 50 objects (per PRD requirement)
- **Batch updates** use `update_objects_batch` for multi-select drag (transactional, single broadcast)
- **PixiJS rendering** is optimized via:
  - Object pooling for rectangles/circles
  - Texture atlasing for icons
  - Performance monitoring (`performance_monitor.js`)
- **Database queries** use preloading to avoid N+1 queries (`get_canvas_with_preloads/2`)

## Common Tasks

### Adding a New Object Type

1. Update `Object` schema in `lib/collab_canvas/canvases/object.ex` (if needed)
2. Add AI tool definition in `lib/collab_canvas/ai/tools.ex`
3. Implement tool handler in `lib/collab_canvas/ai/agent.ex` (`execute_tool_call/2`)
4. Add PixiJS rendering logic in `assets/js/core/canvas_manager.js`
5. Update LiveView event handlers in `lib/collab_canvas_web/live/canvas_live.ex`

### Adding a New AI Tool

1. Define tool schema in `Tools.get_tool_definitions/0` with name, description, parameters
2. Implement `execute_tool_call/2` clause in `Agent` module
3. Test with AI command: "Create a {your new feature}"

### Adding a New LiveView Event

1. Add `phx-click` or `phx-` binding in template (`render/1`)
2. Implement `handle_event/3` in LiveView module
3. Add corresponding `handle_info/2` for PubSub broadcast if needed
4. Update JS hook to trigger event (`this.pushEvent("event_name", data)`)

## Migration Workflow

```bash
# Generate migration
mix ecto.gen.migration add_field_to_objects

# Edit generated file in priv/repo/migrations/
# Run migration
mix ecto.migrate

# Rollback if needed
mix ecto.rollback
```

## Debugging Tips

- **LiveView debugging:** Use `IO.inspect(socket.assigns, label: "ASSIGNS")` in event handlers
- **PubSub debugging:** Add `require Logger` and `Logger.info("Broadcast: ...")` in broadcasts
- **AI debugging:** Check `Logger.info` output in terminal for Claude API requests/responses
- **PixiJS debugging:** Open browser DevTools Console, check for errors in `canvas_manager.js`
- **Database debugging:** Use `Ecto.Adapters.SQL.explain/2` for query performance

## Code Style

- **Elixir:** Follow `mix format` style (runs on `mix precommit`)
- **JavaScript:** ES6+ syntax, async/await preferred over promises
- **Documentation:** Use `@moduledoc` and `@doc` for all public functions
- **Naming:**
  - Elixir: `snake_case` for functions/variables
  - JavaScript: `camelCase` for functions/variables
  - Phoenix: Plural context names (`Canvases`, not `Canvas`), singular schema names

## Deployment Notes

- Built with `mix phx.digest` for asset fingerprinting
- Uses Bandit web server (configured in `config/config.exs`)
- SQLite database path configured in `config/runtime.exs`
- Auth0 OAuth callback URL must match production domain
</file>

<file path="Dockerfile">
# Find eligible builder and runner images on Docker Hub. We use Debian
# instead of Alpine to avoid DNS issues in production.
#
# https://hub.docker.com/_/elixir - Official Elixir images
# https://hub.docker.com/_/debian - Official Debian images
#
# This file is based on these images:
#
#   - https://hub.docker.com/_/elixir - for the build image
#   - https://hub.docker.com/_/debian - for the release image
#   - https://pkgs.org/ - resource for finding needed packages
#
ARG ELIXIR_VERSION=1.15
ARG DEBIAN_VERSION=bookworm-slim

ARG BUILDER_IMAGE="elixir:${ELIXIR_VERSION}-slim"
ARG RUNNER_IMAGE="debian:${DEBIAN_VERSION}"

FROM ${BUILDER_IMAGE} as builder

# install build dependencies (including Node.js for npm)
RUN apt-get update -y && apt-get install -y build-essential git curl \
    && curl -fsSL https://deb.nodesource.com/setup_20.x | bash - \
    && apt-get install -y nodejs \
    && apt-get clean && rm -f /var/lib/apt/lists/*_*

# prepare build dir
WORKDIR /app

# install hex + rebar
RUN mix local.hex --force && \
    mix local.rebar --force

# set build ENV
ENV MIX_ENV="prod"

# install mix dependencies
COPY mix.exs mix.lock ./
RUN mix deps.get --only $MIX_ENV
RUN mkdir config

# copy compile-time config files before we compile dependencies
# to ensure any relevant config change will trigger the dependencies
# to be re-compiled.
COPY config/config.exs config/${MIX_ENV}.exs config/
RUN mix deps.compile

COPY priv priv

COPY lib lib

# Install npm dependencies before copying all assets
COPY assets/package.json assets/package-lock.json ./assets/
RUN cd assets && npm ci --prefer-offline --no-audit --progress=false

COPY assets assets

# compile assets
RUN mix assets.deploy

# Compile the release
RUN mix compile

# Changes to config/runtime.exs don't require recompiling the code
COPY config/runtime.exs config/

COPY rel rel
RUN mix release

# start a new build stage so that the final image will only contain
# the compiled release and other runtime necessities
FROM ${RUNNER_IMAGE}

RUN apt-get update -y && \
  apt-get install -y libstdc++6 openssl libncurses5 locales ca-certificates \
  && apt-get clean && rm -f /var/lib/apt/lists/*_*

# Set the locale
RUN sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen

ENV LANG en_US.UTF-8
ENV LANGUAGE en_US:en
ENV LC_ALL en_US.UTF-8

WORKDIR "/app"
RUN chown nobody /app

# set runner ENV
ENV MIX_ENV="prod"

# Only copy the final release from the build stage
COPY --from=builder --chown=nobody:root /app/_build/${MIX_ENV}/rel/collab_canvas ./

USER nobody

# If using an environment that doesn't automatically reap zombie processes, it is
# advised to add an init process such as tini via `apt-get install`
# above and adding an entrypoint. See https://github.com/krallin/tini for details
# ENV TINI_VERSION v0.19.0
# ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini
# RUN chmod +x /tini
# ENTRYPOINT ["/tini", "--"]

# Appended by flyctl for IPv6 support
ENV ECTO_IPV6="true"
ENV ERL_AFLAGS="-proto_dist inet6_tcp"

# Ensure Phoenix server starts
ENV PHX_SERVER="true"

# Start the Phoenix server
CMD ["/app/bin/collab_canvas", "start"]
</file>

<file path="fly.toml">
# fly.toml app configuration file generated for ph-beam
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.

app = 'ph-beam'
primary_region = 'ord'
kill_signal = 'SIGTERM'

[build]

# Commented out: run migrations manually via SSH console
# [deploy]
#   release_command = '/app/bin/collab_canvas eval "CollabCanvas.Release.migrate()"'

[env]
  PHX_HOST = 'ph-beam.fly.dev'
  PORT = '8080'
  DATABASE_PATH = '/data/collab_canvas.db'
  ECTO_IPV6 = 'true'
  ERL_AFLAGS = '-proto_dist inet6_tcp'

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = 'suspend'
  auto_start_machines = true
  min_machines_running = 1
  processes = ['app']

  [[http_service.checks]]
    interval = '30s'
    timeout = '10s'
    grace_period = '30s'
    method = 'GET'
    path = '/health'

[[mounts]]
  source = 'ph'
  destination = '/data'
  initial_size = '1gb'

[[vm]]
  memory = '1gb'
  cpu_kind = 'shared'
  cpus = 1
</file>

<file path="mix.exs">
defmodule CollabCanvas.MixProject do
  use Mix.Project

  def project do
    [
      app: :collab_canvas,
      version: "0.1.0",
      elixir: "~> 1.15",
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps(),
      releases: releases(),
      compilers: [:phoenix_live_view] ++ Mix.compilers(),
      listeners: [Phoenix.CodeReloader]
    ]
  end

  # Configuration for the OTP application.
  #
  # Type `mix help compile.app` for more information.
  def application do
    [
      mod: {CollabCanvas.Application, []},
      extra_applications: [:logger, :runtime_tools]
    ]
  end

  def cli do
    [
      preferred_envs: [precommit: :test]
    ]
  end

  # Specifies which paths to compile per environment.
  defp elixirc_paths(:test), do: ["lib", "test/support"]
  defp elixirc_paths(_), do: ["lib"]

  # Specifies your project dependencies.
  #
  # Type `mix help deps` for examples and options.
  defp deps do
    [
      {:phoenix, "~> 1.8.1"},
      {:phoenix_ecto, "~> 4.5"},
      {:ecto_sql, "~> 3.13"},
      {:ecto_sqlite3, ">= 0.0.0"},
      {:phoenix_html, "~> 4.1"},
      {:phoenix_live_reload, "~> 1.2", only: :dev},
      {:phoenix_live_view, "~> 1.1.0"},
      {:lazy_html, ">= 0.1.0", only: :test},
      {:phoenix_live_dashboard, "~> 0.8.3"},
      {:tailwind, "~> 0.3", runtime: Mix.env() == :dev},
      {:heroicons,
       github: "tailwindlabs/heroicons",
       tag: "v2.2.0",
       sparse: "optimized",
       app: false,
       compile: false,
       depth: 1},
      {:swoosh, "~> 1.16"},
      {:req, "~> 0.5"},
      {:ueberauth, "~> 0.10"},
      {:ueberauth_auth0, "~> 2.1"},
      {:telemetry_metrics, "~> 1.0"},
      {:telemetry_poller, "~> 1.0"},
      {:gettext, "~> 0.26"},
      {:jason, "~> 1.2"},
      {:dns_cluster, "~> 0.2.0"},
      {:bandit, "~> 1.5"},
      {:dotenvy, "~> 0.8"}
    ]
  end

  # Aliases are shortcuts or tasks specific to the current project.
  # For example, to install project dependencies and perform other setup tasks, run:
  #
  #     $ mix setup
  #
  # See the documentation for `Mix` for more info on aliases.
  defp aliases do
    [
      setup: ["deps.get", "ecto.setup", "assets.setup", "assets.build"],
      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
      "ecto.reset": ["ecto.drop", "ecto.setup"],
      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"],
      "assets.setup": ["tailwind.install --if-missing", "cmd npm install --prefix assets"],
      "assets.build": ["compile", "cmd npm run build --prefix assets", "tailwind collab_canvas"],
      "assets.deploy": [
        "cmd npm run build --prefix assets",
        "tailwind collab_canvas --minify",
        "phx.digest"
      ],
      precommit: ["compile --warning-as-errors", "deps.unlock --unused", "format", "test"]
    ]
  end

  defp releases do
    [
      collab_canvas: [
        include_executables_for: [:unix],
        steps: [:assemble, :tar]
      ]
    ]
  end
end
</file>

</files>
